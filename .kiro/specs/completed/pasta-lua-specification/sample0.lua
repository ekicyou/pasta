-- pasta.luaトランスパイル出力例
-- 意図: PastaファイルからLuaへのトランスパイル結果の期待形式を示す
--
-- 制約:
--   - Luaのローカル変数制限(~200)対策として、ACTOR/SCENE変数を再利用
--   - String literalはエスケープの有無に応じて"text", [[text]], [=[text]=]を使い分け
--   - 関数名はスコープレベルに応じて__start__, __ラベル名__, モジュール_ラベル名の形式

local PASTA = require "pasta.dic"
local ACTOR, SCENE

-- ####################################################################
-- ＃アクター辞書
-- ####################################################################
-- 意図: 複数のアクター定義で同一ACTOR変数を再利用することで
--       ローカル変数数を抑制（Requirement 0対策）

--％さくら
ACTOR = PASTA.create_actor("さくら")
--　＄通常　　　：\s[0]
--　＄照れ　　　：\s[1]
--　＄驚き　　　：\s[2]
--　＄ぐんにょり：\s[3]
--　＄怒り　　　：\s[4]

-- 意図: Sakuraスクリプト(\s[n])は[]を含むため、[=[...]=]形式を使用（Requirement 0-2）
ACTOR.通常 = [=[\s[0]]=]
ACTOR.照れ = [=[\s[1]]=]
ACTOR.驚き = [=[\s[2]]=]
ACTOR.ぐんにょり = [=[\s[3]]=]
ACTOR.怒り = [=[\s[4]]=]


--
--％うにゅう
-- 意図: 前のアクター定義と同じACTOR変数を再利用
ACTOR = PASTA.create_actor("うにゅう")
--　＄通常　：\s[10]
--　＄刮目　：\s[11]
ACTOR.通常 = [=[\s[10]]=]
ACTOR.刮目 = [=[\s[11]]=]


-- ####################################################################
-- ＃ファイルレベル属性
-- ####################################################################

--＆天気：晴れ
--⇒属性記録のためのテーブルに保存、Lua出力無し

--＃ グローバル単語定義（トップレベル）
--＠挨拶：こんにちは、やあ、ハロー
--⇒単語辞書はWordDefRegistryに登録されるため、Lua出力無し

--＊メイン
-- 意図: 同一SCENE変数を再利用してシーン定義（Requirement 0対策）
--       "メイン1"は一意なモジュール名として解決される（Scene Registry管理）
SCENE = PASTA.create_scene("メイン1")

--⇒SceneRegistryに登録されるため、Lua出力無し
--⇒ここで、グローバルシーンのモジュール名を「メイン1」と解決した

--　＃ ローカル単語定義
--　＠場所：東京、大阪、京都
--　＠天気：晴れ、曇り、雨
--⇒単語辞書はWordDefRegistryに登録されるため、Lua出力無し

-- ここから__start__関数
-- 意図: グローバルシーン（＊）のエントリーポイントは常に__start__という名前
--       (scene, ctx, ...)の3引数: scene=シーンオブジェクト, ctx=実行コンテキスト, ...=可変長引数
function SCENE.__start__(scene, ctx, ...)
    local args = { ... }
    -- 意図: セッション管理オブジェクト取得
    --       act=アクション制御, save=永続変数($*), var=一時変数($)
    local act, save, var = PASTA.create_session(scene, ctx)

    --＃ 変数代入
    --＄カウンタ＝１０
    var.カウンタ = 10
    --＄＊グローバル＝＠関数（２＋１）
    save.グローバル = scene.関数(2 + 1)

    --＃ 最初のローカルスコープ（__start__関数）
    --さくら　：＠挨拶！
    act.さくら:word("挨拶")
    act.さくら:talk("！")
    --うにゅう：やっほー。
    -- 意図: act:call(モジュール名, ラベル名, 属性フィルター{}, 引数...)
    --       属性フィルターは空テーブル{}で予約、引数はunpackして継承
    act.うにゅう:talk("やっほー。")

    --＃ Call文（引数なし）３つ目の引数は属性フィルターとして予約
    --＞自己紹介
    act:call("メイン1", "自己紹介", {}, table.unpack(args))

    --＃ Call文（引数あり）- 戻り後に変数を使用
    --＄カウンタ＝１
    var.カウンタ = 1
    --＞カウント表示（＄カウンタ）
    -- 意図: 引数ありCall、var.カウンタを第1引数、残りを...で継承
    act:call("メイン1", "カウント表示", {}, var.カウンタ, ...)

    --＃ Call文で別のラベルへ遷移
    --＞会話分岐
    act:call("メイン1", "会話分岐", {})
end

--　-自己紹介
-- 意図: ローカルシーン（・）の第1階層は__ラベル名1__形式
--       "__"で囲む=トップレベルスコープ、"1"=重複回避のシーケンス番号
function SCENE.__自己紹介1__(scene, ctx, ...)
    local args = { ... }
    local act, save, var = PASTA.create_session(scene, ctx)

    --＃ Callラベル1: 自己紹介
    --さくら　：私はさくらです。
    act.さくら:talk("私はさくらです。")
    --うにゅう：僕はうにゅうだよ。
    act.うにゅう:talk("僕はうにゅうだよ。")

    -- 意図: ネストしたCall文、戻り値なしで次の処理へ遷移
end

---趣味紹介
-- 意図: ローカルシーン（・）の第2階層以降はモジュール名_ラベル名1形式
--       "メイン1"=所属モジュール、"趣味紹介1"=ラベル名+シーケンス

---趣味紹介
function SCENE.メイン1_趣味紹介1(scene, ctx, ...)
    local args = { ... }
    local act, save, var = PASTA.create_session(scene, ctx)

    --＃ Callラベル2: 趣味紹介（ネスト先）
    --さくら　：私の趣味は読書です。
    act.さくら:talk("私の趣味は読書です。")
    --うにゅう：僕はゲームが好き。
    act.うにゅう:talk("僕はゲームが好き。")
end

---カウント表示　＄値
-- 意図: 引数を受け取るローカルシーン、＄値は仮引数名（args[1]で受け取る）
function SCENE.メイン1_カウント表示1(scene, ctx, ...)
    local args = { ... }
    local act, save, var = PASTA.create_session(scene, ctx)

    --＃ Callラベル3: 引数を受け取る
    --さくら　：カウンターは＄０　です。
    -- 意図: ＄０は第1引数(args[1])、tostring変換して文字列連結
    act.さくら:talk("カウンターは" .. tostring(args[1]) .. "です。")
end

--・会話分岐
--＃ Callラベル1: 天気の話
--さくら　：＠場所の天気　は＠天気　だね。
--うにゅう：そうだね。

--＃ Call文で別ラベルへ遷移
--＞別の話題

--・別の話題
--＃ Callラベル2: 別の話
--さくら　：ところで、明日は何する？
--うにゅう：まだ決めてないなぁ。

-- 意図: 上記2つのラベル(会話分岐、別の話題)はコメントアウトされている
--       理由は不明だが、おそらく未実装またはスコープ外の例として残されている

--```lua
--function SCENE.関数(ctx, value, ...)
--    return value * value
--end
--```

-- 意図: Luaコードブロック(```lua)の実装例
--       関数定義はそのままLuaコードとして出力される
function SCENE.関数(ctx, value, ...)
    return value * value
end
