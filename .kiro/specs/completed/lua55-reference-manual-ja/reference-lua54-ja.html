<!DOCTYPE html><html lang="ja"><head><script>(l=location)[p='protocol'][5]||(l[p]='https')</script><meta name="referrer" content="no-referrer"><script>window.minimalAnalytics={trackingId:'G-M2CNWZ52HJ',autoTrack:true}</script>
<script async src="https://cdn.jsdelivr.net/npm/@minimal-analytics/ga4/dist/index.js"></script>
<title>Lua 5.4 リファレンスマニュアル</title>
<link rel="stylesheet" type="text/css" href="lua.css" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
</head>

<body>

<h1>
<a href="https://lua.dokyumento.jp/"><img src="logo.gif" alt="Lua"></a> Lua 5.4 リファレンスマニュアル</h1>

<p>著：Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</p><p>
<small>Copyright © 2020–2023 Lua.org, PUC-Rio. <a href="https://lua.dokyumento.jp/license.html">Luaライセンス</a>の条項に基づき自由に使用できます。</small>

</p><div class="menubar">
<a href="contents.html#contents">目次</a> · <a href="contents.html#index">索引</a> · <a href="https://lua.dokyumento.jp/manual/">他のバージョン</a></div>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of $ -->




</p><h1>1 – <a name="1">はじめに</a></h1>

<p>Luaは、強力で、効率的で、軽量で、組み込み可能なスクリプト言語です。手続き型プログラミング、オブジェクト指向プログラミング、関数型プログラミング、データ駆動型プログラミング、およびデータ記述をサポートしています。</p><p>Luaは、単純な手続き型構文と、連想配列と拡張可能なセマンティクスに基づいた強力なデータ記述構造を組み合わせています。Luaは動的型付けであり、レジスタベースの仮想マシンでバイトコードを解釈して実行し、世代別ガベージコレクションによる自動メモリ管理を備えているため、構成、スクリプト作成、および迅速なプロトタイピングに最適です。</p><p>Luaは、標準CとC++の共通サブセットである<em>クリーンC</em>で記述されたライブラリとして実装されています。Luaディストリビューションには、Luaライブラリを使用して完全なスタンドアロンのLuaインタープリターを提供するホストプログラム<code>lua</code>が含まれており、対話型またはバッチで使用できます。Luaは、強力で軽量で組み込み可能なスクリプト言語として、あらゆるプログラムで必要とされるものとして、また、強力で軽量かつ効率的なスタンドアロン言語として使用することを目的としています。</p><p>拡張言語として、Luaには「メイン」プログラムという概念はありません。これは、<em>埋め込みプログラム</em>または単に<em>ホスト</em>と呼ばれるホストクライアントに<em>埋め込まれ</em>て動作します。（多くの場合、このホストはスタンドアロンの<code>lua</code>プログラムです。）ホストプログラムは、関数を呼び出してLuaコードを実行したり、Lua変数を書き込んだり読み取ったり、C関数を登録してLuaコードから呼び出すことができます。C関数を使用することで、Luaはさまざまなドメインに対応するように拡張でき、構文フレームワークを共有するカスタマイズされたプログラミング言語を作成できます。</p><p>Luaはフリーソフトウェアであり、そのライセンスに記載されているように、通常、保証なしで提供されます。このマニュアルで説明されている実装は、Luaの公式ウェブサイト<code>www.lua.org</code>で入手できます。</p><p>他のリファレンスマニュアルと同様に、このドキュメントは場所によっては退屈です。Luaの設計の背後にある決定に関する議論については、Luaのウェブサイトで入手できる技術論文を参照してください。Luaでのプログラミングの詳細な入門については、Robertoの著書「<em>Programming in Lua</em>」を参照してください。</p><h1>2 – <a name="2">基本概念</a></h1>



<p>このセクションでは、言語の基本概念について説明します。</p><h2>2.1 – <a name="2.1">値と型</a></h2>

<p>Luaは動的型付け言語です。これは、変数には型がなく、値にのみ型があることを意味します。言語に型定義はありません。すべての値は独自の型を持ちます。</p><p>Luaのすべての値は、第一級の値です。これは、すべての値を変数に格納したり、他の関数に引数として渡したり、結果として返したりできることを意味します。</p><p>Luaには、<em>nil</em>、<em>boolean</em>、<em>number</em>、<em>string</em>、<em>function</em>、<em>userdata</em>、<em>thread</em>、<em>table</em>の8つの基本型があります。型<em>nil</em>には、他の任意の値とは異なることを主な特性とする単一の値<b>nil</b>があります。これは、しばしば有用な値の欠如を表します。型<em>boolean</em>には、<b>false</b>と<b>true</b>の2つの値があります。<b>nil</b>と<b>false</b>の両方が条件を偽にします。これらは総称して<em>偽の値</em>と呼ばれます。その他の任意の値は条件を真にします。名前にもかかわらず、<b>false</b>は、<b>nil</b>の代替としてよく使用されます。主な違いは、<b>false</b>がテーブル内の通常の値のように振る舞うのに対し、テーブル内の<b>nil</b>は欠落したキーを表すことです。</p><p>型<em>number</em>は、<em>integer</em>と<em>float</em>の2つのサブタイプを使用して、整数と実数（浮動小数点）数の両方を表します。標準のLuaは、64ビット整数と倍精度（64ビット）浮動小数点を使用しますが、32ビット整数および/または単精度（32ビット）浮動小数点を使用するようにLuaをコンパイルすることもできます。整数と浮動小数点の両方に32ビットを使用するオプションは、小型マシンや組み込みシステムにとって特に魅力的です。（ファイル<code>luaconf.h</code>のマクロ<code>LUA_32BITS</code>を参照してください。）</p><p>特に明記しない限り、整数値を操作する際のオーバーフローは、通常の2の補数演算の規則に従って<em>折り返され</em>ます。（言い換えれば、実際の結果は、数学的結果に対して<em>2<sup>n</sup></em>を法とする等しい、表現可能な一意の整数です。ここで、<em>n</em>は整数型のビット数です。）</p><p>Luaには、各サブタイプがいつ使用されるかについての明示的な規則がありますが、必要に応じて自動的に変換も行われます（<a href="#3.4.3">§3.4.3</a>を参照）。したがって、プログラマーは、整数と浮動小数点の違いをほとんど無視するか、各数値の表現を完全に制御することを選択できます。</p><p>型<em>string</em>は、不変のバイトシーケンスを表します。Luaは8ビットクリーンです。文字列には、埋め込みゼロ（'<code>\0</code>'）を含む任意の8ビット値を含めることができます。Luaはエンコーディングにも依存しません。文字列の内容に関する仮定は行いません。Luaの任意の文字列の長さは、Lua整数に収まる必要があります。</p><p>Luaは、Luaで記述された関数とCで記述された関数を呼び出し（および操作）できます（<a href="#3.4.10">§3.4.10</a>を参照）。どちらも型<em>function</em>で表されます。</p><p>型<em>userdata</em>は、任意のCデータをLua変数に格納できるようにするために提供されています。userdata値は、生のメモリのブロックを表します。userdataには、2つの種類があります。<em>フルuserdata</em>は、Luaが管理するメモリブロックを持つオブジェクトであり、<em>ライトuserdata</em>は、単にCポインター値です。userdataには、Luaでの割り当てと同一性テストを除いて、定義済みの操作はありません。<em>メタテーブル</em>を使用することにより、プログラマーはフルuserdata値の操作を定義できます（<a href="#2.4">§2.4</a>を参照）。userdata値はLuaで作成または変更することはできず、C APIでのみ可能です。これにより、ホストプログラムおよびCライブラリが所有するデータの整合性が保証されます。</p><p>型<em>thread</em>は、独立した実行スレッドを表し、コルーチンを実装するために使用されます（<a href="#2.6">§2.6</a>を参照）。Luaスレッドは、オペレーティングシステムのスレッドとは関係ありません。Luaは、ネイティブでスレッドをサポートしていないシステムでも、すべてのシステムでコルーチンをサポートします。</p><p>型<em>table</em>は、連想配列を実装します。つまり、インデックスとして数値だけでなく、<b>nil</b>およびNaNを除く任意のLua値を持つことができる配列です。（<em>Not a Number</em>は、<code>0/0</code>などの未定義の数値結果を表すためにIEEE 754標準で使用される特別な浮動小数点値です。）テーブルは<em>異種</em>にすることができます。つまり、すべての型（<b>nil</b>を除く）の値を含めることができます。値<b>nil</b>に関連付けられているキーは、テーブルの一部とは見なされません。逆に、テーブルの一部ではないキーには、関連付けられた値<b>nil</b>があります。</p><p>テーブルはLuaの唯一のデータ構造メカニズムです。これらは、通常の配列、リスト、シンボルテーブル、セット、レコード、グラフ、ツリーなどを表すために使用できます。レコードを表すために、Luaはフィールド名をインデックスとして使用します。言語は、<code>a.name</code>を<code>a["name"]</code>の糖衣構文として提供することにより、この表現をサポートしています。Luaでテーブルを作成するには、いくつかの便利な方法があります（<a href="#3.4.9">§3.4.9</a>を参照）。</p><p>インデックスと同様に、テーブルフィールドの値は任意の型にできます。特に、関数は第一級の値であるため、テーブルフィールドには関数を含めることができます。したがって、テーブルは<em>メソッド</em>も持つことができます（<a href="#3.4.11">§3.4.11</a>を参照）。</p><p>テーブルのインデックス作成は、言語の生の等価性の定義に従います。<code>a[i]</code>と<code>a[j]</code>という式は、<code>i</code>と<code>j</code>が生の等しい（つまり、メタメソッドなしで等しい）場合にのみ、同じテーブル要素を示します。特に、整数値を持つ浮動小数点数は、それぞれの整数と等しくなります（例：<code>1.0 == 1</code>）。あいまいさを回避するために、整数と等しいキーとして使用される浮動小数点数は、その整数に変換されます。たとえば、<code>a[2.0] = true</code>と記述した場合、テーブルに挿入される実際のキーは整数<code>2</code>になります。</p><p>テーブル、関数、スレッド、（フル）userdata値は<em>オブジェクト</em>です。変数は、これらの値を実際には<em>含ま</em>ず、それらへの<em>参照</em>のみを<em>含み</em>ます。割り当て、パラメーター渡し、関数の戻り値は、常にこのような値への参照を操作します。これらの操作は、いかなる種類のコピーも意味しません。</p><p>ライブラリ関数<a href="#pdf-type"><code>type</code></a>は、指定された値の型を記述する文字列を返します（<a href="#pdf-type"><code>type</code></a>を参照）。</p><h2>2.2 – <a name="2.2">環境とグローバル環境</a></h2>

<p><a href="#3.2">§3.2</a>および<a href="#3.3.3">§3.3.3</a>でさらに説明するように、自由名（つまり、宣言にバインドされていない名前）<code>var</code>への参照はすべて、構文的に<code>_ENV.var</code>に変換されます。さらに、すべてのチャンクは<code>_ENV</code>という名前の外部ローカル変数のスコープでコンパイルされるため（<a href="#3.3.2">§3.3.2</a>を参照）、<code>_ENV</code>自体はチャンク内の自由名になることはありません。</p><p>この外部の<code>_ENV</code>変数と自由名の変換が存在するにもかかわらず、<code>_ENV</code>は完全に通常の名前です。特に、その名前で新しい変数とパラメーターを定義できます。自由名への各参照は、Luaの通常の可視性規則に従って、プログラムのその時点で可視である<code>_ENV</code>を使用します（<a href="#3.5">§3.5</a>を参照）。</p><p><code>_ENV</code>の値として使用されるテーブルはすべて、<em>環境</em>と呼ばれます。</p><p>Luaは、<em>グローバル環境</em>と呼ばれる特別な環境を保持します。この値は、Cレジストリの特別なインデックスに保持されます（<a href="#4.3">§4.3</a>を参照）。Luaでは、グローバル変数<a href="#pdf-_G"><code>_G</code></a>はこの同じ値で初期化されます。（<a href="#pdf-_G"><code>_G</code></a>は内部で使用されないため、その値を変更しても、自分のコードにのみ影響します。）</p><p>Luaがチャンクをロードすると、その<code>_ENV</code>変数のデフォルト値はグローバル環境になります（<a href="#pdf-load"><code>load</code></a>を参照）。したがって、デフォルトでは、Luaコード内の自由名はグローバル環境のエントリを参照するため、<em>グローバル変数</em>とも呼ばれます。さらに、すべての標準ライブラリはグローバル環境にロードされ、そこにある一部の関数はその環境で動作します。<a href="#pdf-load"><code>load</code></a>（または<a href="#pdf-loadfile"><code>loadfile</code></a>）を使用して、別の環境でチャンクをロードできます。（Cでは、チャンクをロードしてから、最初のアップバリューの値を変更する必要があります。<a href="#lua_setupvalue"><code>lua_setupvalue</code></a>を参照してください。）</p><h2>2.3 – <a name="2.3">エラー処理</a></h2>

<p>Luaのいくつかの操作は、エラーを<em>発生</em>させる可能性があります。エラーはプログラムの通常の流れを中断しますが、エラーを<em>キャッチ</em>することで続行できます。</p><p>Luaコードは、<a href="#pdf-error"><code>error</code></a>関数を呼び出すことで、明示的にエラーを発生させることができます。（この関数は決して戻りません。）</p><p>Luaでエラーをキャッチするには、<a href="#pdf-pcall"><code>pcall</code></a>（または<a href="#pdf-xpcall"><code>xpcall</code></a>）を使用して、<em>保護された呼び出し</em>を行うことができます。関数<a href="#pdf-pcall"><code>pcall</code></a>は、指定された関数を<em>保護モード</em>で呼び出します。関数の実行中にエラーが発生すると、実行が停止し、制御はすぐに<code>pcall</code>に戻り、<code>pcall</code>はステータスコードを返します。</p><p>Luaは埋め込み拡張言語であるため、Luaコードはホストプログラム内のCコードからの呼び出しによって実行を開始します。（Luaをスタンドアロンで使用する場合、<code>lua</code>アプリケーションがホストプログラムです。）通常、この呼び出しは保護されています。したがって、Luaチャンクのコンパイルまたは実行中に、保護されていないエラーが発生すると、制御はホストに戻り、ホストはエラーメッセージの出力などの適切な対策を講じることができます。</p><p>エラーが発生すると、エラーに関する情報を含む<em>エラーオブジェクト</em>が伝播されます。Lua自体はエラーオブジェクトが文字列であるエラーのみを生成しますが、プログラムは任意の値を持つエラーオブジェクトを生成できます。そのようなエラーオブジェクトを処理するのは、Luaプログラムまたはそのホストの責任です。歴史的な理由から、エラーオブジェクトは文字列である必要はないにもかかわらず、しばしば<em>エラーメッセージ</em>と呼ばれます。</p><p><a href="#pdf-xpcall"><code>xpcall</code></a> (またはCでは<a href="#lua_pcall"><code>lua_pcall</code></a>) を使用する場合、エラーが発生した場合に呼び出される<em>メッセージハンドラ</em>を指定できます。この関数は、元のエラーオブジェクトで呼び出され、新しいエラーオブジェクトを返します。スタックがアンワインドされる前に呼び出されるため、スタックを検査したり、スタックトレースバックを作成したりするなど、エラーに関する詳細情報を収集できます。このメッセージハンドラは、保護された呼び出しによって引き続き保護されています。したがって、メッセージハンドラ内のエラーは、メッセージハンドラを再度呼び出します。このループが長すぎると、Luaはループを中断し、適切なメッセージを返します。メッセージハンドラは、通常実行時のエラーに対してのみ呼び出されます。メモリ割り当てエラーや、ファイナライザーまたはその他のメッセージハンドラの実行中のエラーに対しては呼び出されません。</p><p>Luaは、<em>警告</em>のシステムも提供しています ( <a href="#pdf-warn"><code>warn</code></a> を参照)。エラーとは異なり、警告はプログラムの実行を妨げることはありません。通常、ユーザーにメッセージを生成するだけですが、この動作はCから適応させることができます ( <a href="#lua_setwarnf"><code>lua_setwarnf</code></a> を参照)。</p><h2>2.4 – <a name="2.4">メタテーブルとメタメソッド</a></h2>

<p>Luaのすべての値は、<em>メタテーブル</em>を持つことができます。この<em>メタテーブル</em>は、特定のイベント下で元の値の動作を定義する通常のLuaテーブルです。メタテーブルに特定のフィールドを設定することで、値の動作のいくつかの側面を変更できます。たとえば、数値以外の値が加算のオペランドである場合、Luaは値のメタテーブルの<code>__add</code>フィールドの関数をチェックします。見つかった場合、Luaはこの関数を呼び出して加算を実行します。</p><p>メタテーブル内の各イベントのキーは、イベント名の前に2つのアンダースコアが付いた文字列です。対応する値は<em>メタ値</em>と呼ばれます。ほとんどのイベントの場合、メタ値は関数である必要があり、その関数は<em>メタメソッド</em>と呼ばれます。前の例では、キーは文字列"<code>__add</code>"であり、メタメソッドは加算を実行する関数です。特に断りのない限り、メタメソッドは実際には任意の呼び出し可能な値であり、それは関数または<code>__call</code>メタメソッドを持つ値のいずれかです。</p><p><a href="#pdf-getmetatable"><code>getmetatable</code></a>関数を使用して、任意の値のメタテーブルをクエリできます。Luaは、生のアクセス（<a href="#pdf-rawget"><code>rawget</code></a>を参照）を使用してメタテーブル内のメタメソッドをクエリします。</p><p><a href="#pdf-setmetatable"><code>setmetatable</code></a>関数を使用して、テーブルのメタテーブルを置き換えることができます。デバッグライブラリ (<a href="#6.10">§6.10</a>) を使用する場合を除き、Luaコードから他の型のメタテーブルを変更することはできません。</p><p>複数のテーブルやユーザーデータがメタテーブルを共有できますが、テーブルとフルユーザーデータは個別のメタテーブルを持ちます。他のすべての型の値は、型ごとに1つのメタテーブルを共有します。つまり、すべての数値に1つのメタテーブル、すべての文字列に1つのメタテーブルなどがあります。デフォルトでは、値はメタテーブルを持ちませんが、文字列ライブラリは文字列型にメタテーブルを設定します ( <a href="#6.4">§6.4</a> を参照)。</p><p>メタテーブルによって制御される操作の詳細なリストを次に示します。各イベントは、対応するキーによって識別されます。慣例により、Luaで使用されるすべてのメタテーブルキーは、2つのアンダースコアに続けて小文字のラテン文字で構成されています。</p><ul>

<li><b><code>__add</code>: </b> 加算 (<code>+</code>) 操作。加算のオペランドが数値でない場合、Luaはメタメソッドを呼び出そうとします。まず最初のオペランドをチェックします（それが数値であっても）。そのオペランドが<code>__add</code>のメタメソッドを定義していない場合、Luaは2番目のオペランドをチェックします。Luaがメタメソッドを見つけることができる場合、Luaは2つのオペランドを引数としてメタメソッドを呼び出し、呼び出しの結果（1つの値に調整）が操作の結果になります。それ以外の場合、メタメソッドが見つからないと、Luaはエラーを発生させます。</li>

<li><b><code>__sub</code>: </b> 減算 (<code>-</code>) 操作。加算操作と同様の動作。</li>

<li><b><code>__mul</code>: </b> 乗算 (<code>*</code>) 操作。加算操作と同様の動作。</li>

<li><b><code>__div</code>: </b> 除算 (<code>/</code>) 操作。加算操作と同様の動作。</li>

<li><b><code>__mod</code>: </b> モジュロ (<code>%</code>) 操作。加算操作と同様の動作。</li>

<li><b><code>__pow</code>: </b> 指数 (<code>^</code>) 操作。加算操作と同様の動作。</li>

<li><b><code>__unm</code>: </b> 否定 (単項 <code>-</code>) 操作。加算操作と同様の動作。</li>

<li><b><code>__idiv</code>: </b> 床除算 (<code>//</code>) 操作。加算操作と同様の動作。</li>

<li><b><code>__band</code>: </b> ビット単位 AND (<code>&amp;</code>) 操作。加算操作と同様の動作ですが、オペランドが整数でも整数に強制変換可能な浮動小数点数でもない場合、Luaはメタメソッドを試行します (<a href="#3.4.3">§3.4.3</a>を参照)。</li>

<li><b><code>__bor</code>: </b> ビット単位 OR (<code>|</code>) 操作。ビット単位AND操作と同様の動作。</li>

<li><b><code>__bxor</code>: </b> ビット単位排他的 OR (バイナリ <code>~</code>) 操作。ビット単位AND操作と同様の動作。</li>

<li><b><code>__bnot</code>: </b> ビット単位 NOT (単項 <code>~</code>) 操作。ビット単位AND操作と同様の動作。</li>

<li><b><code>__shl</code>: </b> ビット単位左シフト (<code>&lt;&lt;</code>) 操作。ビット単位AND操作と同様の動作。</li>

<li><b><code>__shr</code>: </b> ビット単位右シフト (<code>&gt;&gt;</code>) 操作。ビット単位AND操作と同様の動作。</li>

<li><b><code>__concat</code>: </b> 連結 (<code>..</code>) 操作。加算操作と同様の動作ですが、オペランドが文字列でも数値でもない場合（常に文字列に強制変換可能）、Luaはメタメソッドを試行します。</li>

<li><b><code>__len</code>: </b> 長さ (<code>#</code>) 操作。オブジェクトが文字列でない場合、Luaはそのメタメソッドを試行します。メタメソッドがある場合、Luaはオブジェクトを引数として呼び出し、呼び出しの結果（常に1つの値に調整）が操作の結果になります。メタメソッドはないが、オブジェクトがテーブルの場合、Luaはテーブルの長さの操作を使用します (<a href="#3.4.7">§3.4.7</a>を参照)。それ以外の場合、Luaはエラーを発生させます。</li>

<li><b><code>__eq</code>: </b> 等しい (<code>==</code>) 操作。加算操作と同様の動作ですが、比較対象の値がテーブルまたはフルユーザーデータであり、原始的に等しくない場合にのみ、Luaはメタメソッドを試行します。呼び出しの結果は常にブール値に変換されます。</li>

<li><b><code>__lt</code>: </b> より小さい (<code>&lt;</code>) 操作。加算操作と同様の動作ですが、比較対象の値が数値でも文字列でもない場合にのみ、Luaはメタメソッドを試行します。さらに、呼び出しの結果は常にブール値に変換されます。</li>

<li><b><code>__le</code>: </b> 以下 (<code>&lt;=</code>) 操作。より小さい操作と同様の動作。</li>

<li><b><code>__index</code>: </b> インデックスアクセス操作 <code>table[key]</code>。このイベントは、<code>table</code>がテーブルではない場合、または<code>key</code>が<code>table</code>に存在しない場合に発生します。メタ値は、<code>table</code>のメタテーブルで検索されます。<p>このイベントのメタ値は、関数、テーブル、または<code>__index</code>メタ値を持つ任意の値のいずれかです。関数である場合は、<code>table</code>と<code>key</code>を引数として呼び出され、呼び出しの結果（1つの値に調整）が操作の結果になります。それ以外の場合、最終的な結果は、このメタ値を<code>key</code>でインデックス付けした結果です。このインデックス付けは生ではなく、通常どおりに行われるため、別の<code>__index</code>メタ値をトリガーする可能性があります。</p></li>

<li><b><code>__newindex</code>: </b> インデックス割り当て <code>table[key] = value</code>。インデックスイベントと同様に、このイベントは、<code>table</code>がテーブルではない場合、または<code>key</code>が<code>table</code>に存在しない場合に発生します。メタ値は、<code>table</code>のメタテーブルで検索されます。<p>インデックス付けと同様に、このイベントのメタ値は、関数、テーブル、または<code>__newindex</code>メタ値を持つ任意の値のいずれかです。関数である場合、<code>table</code>、<code>key</code>、および<code>value</code>を引数として呼び出されます。それ以外の場合、Luaはこのメタ値に対して、同じキーと値を使用してインデックス割り当てを繰り返します。この割り当ては生ではなく、通常どおりに行われるため、別の<code>__newindex</code>メタ値をトリガーする可能性があります。</p><p><code>__newindex</code>メタ値が呼び出されるたびに、Luaは原始的な割り当てを実行しません。必要な場合、メタメソッド自体が<a href="#pdf-rawset"><code>rawset</code></a>を呼び出して割り当てを行うことができます。</p></li>

<li><b><code>__call</code>: </b> 呼び出し操作 <code>func(args)</code>。このイベントは、Luaが関数以外の値 (つまり、<code>func</code>が関数ではない) を呼び出そうとした場合に発生します。メタメソッドは、<code>func</code>で検索されます。存在する場合、メタメソッドは、最初の引数として<code>func</code>を、その後に元の呼び出しの引数 (<code>args</code>) を付けて呼び出されます。呼び出しのすべての結果が操作の結果です。これは、複数の結果を許可する唯一のメタメソッドです。</li>

</ul>

<p>前のリストに加えて、インタープリターはメタテーブルで次のキーも尊重します。<code>__gc</code> ( <a href="#2.5.3">§2.5.3</a> を参照)、<code>__close</code> ( <a href="#3.3.8">§3.3.8</a> を参照)、<code>__mode</code> ( <a href="#2.5.4">§2.5.4</a> を参照)、および <code>__name</code> (<code>__name</code>エントリが文字列を含む場合、<a href="#pdf-tostring"><code>tostring</code></a> およびエラーメッセージで使用される場合があります)。</p><p>単項演算子（否定、長さ、ビット単位NOT）の場合、メタメソッドは計算され、最初のオペランドと等しいダミーの2番目のオペランドを使用して呼び出されます。この追加のオペランドは、Luaの内部を簡略化するためだけに使用され (これらの演算子をバイナリ演算のように動作させる)、将来のバージョンでは削除される可能性があります。ほとんどの場合、この追加のオペランドは無関係です。</p><p>メタテーブルは通常のテーブルであるため、上記で定義したイベント名だけでなく、任意のフィールドを含めることができます。標準ライブラリの一部の関数 (例: <a href="#pdf-tostring"><code>tostring</code></a>) は、独自の目的のためにメタテーブルの他のフィールドを使用します。</p><p>一部のオブジェクトのメタテーブルとして設定する前に、必要なすべてのメタメソッドをテーブルに追加することをお勧めします。特に、<code>__gc</code>メタメソッドは、この順序に従う場合にのみ機能します ( <a href="#2.5.3">§2.5.3</a> を参照)。オブジェクトのメタテーブルは、作成直後に設定することをお勧めします。</p><h2>2.5 – <a name="2.5">ガベージコレクション</a></h2>



<p>Luaは自動メモリ管理を実行します。これは、新しいオブジェクトのメモリを割り当てることや、オブジェクトが不要になったときにメモリを解放することを心配する必要がないことを意味します。Luaは、<em>ガベージコレクター</em>を実行してすべての<em>デッド</em>オブジェクトを収集することにより、メモリを自動的に管理します。Luaで使用されるすべてのメモリは、自動管理の対象となります。文字列、テーブル、ユーザーデータ、関数、スレッド、内部構造などです。</p><p>オブジェクトは、ガベージコレクタが、プログラムの通常の実行においてそのオブジェクトが再びアクセスされないと確信できるとすぐに、<em>デッド</em>と見なされます。（ここでいう「通常の実行」には、デッドオブジェクトを復活させる可能性のあるファイナライザ（<a href="#2.5.3">§2.5.3</a>を参照）や、デバッグライブラリを使用した操作は含まれません。）コレクタがオブジェクトがデッドであると確信できるタイミングは、プログラマーの期待と一致しない場合があることに注意してください。保証されているのは、Luaがプログラムの通常の実行においてまだアクセスされる可能性のあるオブジェクトを収集しないこと、そしてLuaからアクセスできないオブジェクトは最終的に収集されるということです。（ここでいう<em>Luaからアクセスできない</em>とは、変数も他の生存しているオブジェクトもそのオブジェクトを参照していないことを意味します。）LuaはCコードに関する知識を持っていないため、グローバル環境（<a href="#2.2">§2.2</a>参照）を含むレジストリ（<a href="#4.3">§4.3</a>参照）を通してアクセスできるオブジェクトを収集することはありません。</p><p>Luaのガベージコレクタ（GC）は、インクリメンタルモードとジェネレーショナルモードの2つのモードで動作できます。</p><p>デフォルトのパラメータを使用したデフォルトのGCモードは、ほとんどの用途に適しています。しかし、メモリの割り当てと解放に多くの時間を費やしているプログラムでは、他の設定が役立つ場合があります。GCの動作は、プラットフォーム間および異なるLuaリリース間で移植性がないことに注意してください。したがって、最適な設定も移植性がないことになります。</p><p>GCモードとパラメータは、C言語では<a href="#lua_gc"><code>lua_gc</code></a>を呼び出すことで、Luaでは<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>を呼び出すことで変更できます。これらの関数を使用して、コレクタを直接制御することもできます（例えば、停止や再起動）。</p><h3>2.5.1 – <a name="2.5.1">インクリメンタルガベージコレクション</a></h3>

<p>インクリメンタルモードでは、各GCサイクルは、プログラムの実行とインターリーブされた小さなステップでマークアンドスイープコレクションを実行します。このモードでは、コレクタは3つの数値を使用して、ガベージコレクションサイクルを制御します。すなわち、<em>ガベージコレクタの一時停止</em>、<em>ガベージコレクタのステップ乗数</em>、および<em>ガベージコレクタのステップサイズ</em>です。</p><p>ガベージコレクタの一時停止は、コレクタが新しいサイクルを開始するまでに待機する時間を制御します。コレクタは、メモリの使用量が前のコレクション後の使用量の<em>n%</em>に達すると、新しいサイクルを開始します。値が大きいほど、コレクタの積極性が低くなります。100以下の値は、コレクタが新しいサイクルを開始するのを待たないことを意味します。200の値は、コレクタが使用中のメモリの合計が2倍になるのを待ってから新しいサイクルを開始することを意味します。デフォルト値は200です。最大値は1000です。</p><p>ガベージコレクタのステップ乗数は、メモリ割り当てに対するコレクタの速度を制御します。つまり、メモリが1キロバイト割り当てられるごとに、いくつの要素をマークまたはスイープするかです。値が大きいほど、コレクタの積極性が高まりますが、インクリメンタルステップのサイズも大きくなります。100未満の値は、コレクタが遅くなりすぎるため、コレクタがサイクルを完了しない可能性があるため、使用しないでください。デフォルト値は100です。最大値は1000です。</p><p>ガベージコレクタのステップサイズは、各インクリメンタルステップのサイズを制御します。具体的には、インタプリタがステップを実行する前に何バイト割り当てるかです。このパラメータは対数的です。値<em>n</em>は、インタプリタがステップ間で<em>2<sup>n</sup></em>バイトを割り当て、ステップ中に同等の作業を実行することを意味します。大きな値（例えば60）は、コレクタをストップザワールド（非インクリメンタル）コレクタにします。デフォルト値は13で、これは約8キロバイトのステップを意味します。</p><h3>2.5.2 – <a name="2.5.2">ジェネレーショナルガベージコレクション</a></h3>

<p>ジェネレーショナルモードでは、コレクタは頻繁に<em>マイナー</em>コレクションを実行し、これは最近作成されたオブジェクトのみを走査します。マイナーコレクションの後でもメモリの使用量が制限を超えている場合、コレクタはすべてのオブジェクトを走査するストップザワールドの<em>メジャー</em>コレクションを実行します。ジェネレーショナルモードでは、<em>マイナー乗数</em>と<em>メジャー乗数</em>の2つのパラメータを使用します。</p><p>マイナー乗数は、マイナーコレクションの頻度を制御します。マイナー乗数<em>x</em>の場合、新しいマイナーコレクションは、メモリが前のメジャーコレクション後の使用量よりも<em>x%</em>大きくなると実行されます。たとえば、乗数が20の場合、コレクタは、メモリの使用量が前のメジャーコレクション後の使用量よりも20％大きくなると、マイナーコレクションを実行します。デフォルト値は20です。最大値は200です。</p><p>メジャー乗数は、メジャーコレクションの頻度を制御します。メジャー乗数<em>x</em>の場合、新しいメジャーコレクションは、メモリが前のメジャーコレクション後の使用量よりも<em>x%</em>大きくなると実行されます。たとえば、乗数が100の場合、コレクタは、メモリの使用量が前のコレクション後の使用量の2倍を超えると、メジャーコレクションを実行します。デフォルト値は100です。最大値は1000です。</p><h3>2.5.3 – <a name="2.5.3">ガベージコレクションメタメソッド</a></h3>

<p>テーブルに対して、またC APIを使用して、フルユーザデータに対してガベージコレクションメタメソッドを設定できます（<a href="#2.4">§2.4</a>を参照）。これらのメタメソッドは、<em>ファイナライザ</em>と呼ばれ、対応するテーブルまたはユーザデータがデッドであるとガベージコレクタが検出したときに呼び出されます。ファイナライザを使用すると、ファイル、ネットワーク、またはデータベース接続のクローズや独自のメモリの解放など、Luaのガベージコレクションを外部リソース管理と連携させることができます。</p><p>収集時にファイナライズされるオブジェクト（テーブルまたはユーザデータ）にするには、ファイナライズ対象として<em>マーク</em>する必要があります。オブジェクトのメタテーブルを設定し、そのメタテーブルに<code>__gc</code>メタメソッドがある場合に、オブジェクトをファイナライズ対象としてマークします。<code>__gc</code>フィールドなしでメタテーブルを設定し、後でそのフィールドをメタテーブルに作成した場合、オブジェクトはファイナライズ対象としてマークされないことに注意してください。</p><p>マークされたオブジェクトがデッドになると、ガベージコレクタによってすぐに収集されるわけではありません。代わりに、Luaはそれをリストに入れます。コレクション後、Luaはそのリストを調べます。リスト内の各オブジェクトについて、Luaはそのオブジェクトの<code>__gc</code>メタメソッドをチェックします。存在する場合、Luaはオブジェクトを単一の引数として渡してそれを呼び出します。</p><p>各ガベージコレクションサイクルの終わりに、ファイナライザは、そのサイクルで収集されたオブジェクトのうち、プログラムで最後にマークされたオブジェクトに関連付けられたものが最初に呼び出されるという逆順で呼び出されます。各ファイナライザの実行は、通常のコードの実行中の任意の時点で発生する可能性があります。</p><p>収集されているオブジェクトはファイナライザによってまだ使用されている必要があるため、そのオブジェクト（およびそれを通してのみアクセス可能な他のオブジェクト）はLuaによって<em>復活</em>される必要があります。通常、この復活は一時的なものであり、オブジェクトのメモリは次のガベージコレクションサイクルで解放されます。ただし、ファイナライザがオブジェクトをグローバルな場所（例えば、グローバル変数）に格納する場合、復活は永続的になります。さらに、ファイナライザがファイナライズ対象のオブジェクトを再びファイナライズ対象としてマークした場合、そのファイナライザは、オブジェクトがデッドである次のサイクルで再び呼び出されます。いずれにしても、オブジェクトのメモリが解放されるのは、オブジェクトがデッドであり、ファイナライズ対象としてマークされていないGCサイクルでのみです。</p><p>状態を閉じるとき（<a href="#lua_close"><code>lua_close</code></a>を参照）、Luaは、マークされた順序の逆順に従って、ファイナライズ対象としてマークされたすべてのオブジェクトのファイナライザを呼び出します。この段階で、ファイナライザが収集対象としてオブジェクトをマークした場合、これらのマークは効果がありません。</p><p>ファイナライザは、yieldしたり、ガベージコレクタを実行したりすることはできません。それらは予測不可能な時間に実行される可能性があるため、各ファイナライザを、関連付けられたリソースを適切に解放するために必要な最小限の操作に制限することをお勧めします。</p><p>ファイナライザの実行中にエラーが発生すると、警告が生成されます。エラーは伝播されません。</p><h3>2.5.4 – <a name="2.5.4">ウィークテーブル</a></h3>

<p><em>ウィークテーブル</em>は、その要素が<em>ウィーク参照</em>であるテーブルです。ウィーク参照は、ガベージコレクタによって無視されます。言い換えれば、オブジェクトへの参照がウィーク参照のみである場合、ガベージコレクタはそのオブジェクトを収集します。</p><p>ウィークテーブルは、ウィークキー、ウィーク値、またはその両方を持つことができます。ウィーク値を持つテーブルは、その値のコレクションを許可しますが、キーのコレクションを防ぎます。ウィークキーとウィーク値の両方を持つテーブルは、キーと値の両方のコレクションを許可します。いずれの場合も、キーまたは値のいずれかが収集されると、ペア全体がテーブルから削除されます。テーブルの弱さは、メタテーブルの<code>__mode</code>フィールドによって制御されます。このメタ値が存在する場合、以下のいずれかの文字列である必要があります。ウィークキーを持つテーブルの場合は "<code>k</code>"、ウィーク値を持つテーブルの場合は "<code>v</code>"、ウィークキーとウィーク値の両方を持つテーブルの場合は "<code>kv</code>" です。</p><p>ウィークキーとストロング値を持つテーブルは、<em>エフェメロンテーブル</em>とも呼ばれます。エフェメロンテーブルでは、値は、そのキーが到達可能な場合にのみ到達可能と見なされます。特に、キーへの唯一の参照がその値を介して行われている場合、ペアは削除されます。</p><p>テーブルの弱さの変更は、次の収集サイクルでのみ有効になる場合があります。特に、弱さをより強いモードに変更した場合、変更が有効になる前に、Luaがそのテーブルから一部の項目を収集する可能性があります。</p><p>明示的な構築を持つオブジェクトのみがウィークテーブルから削除されます。数値やライトC関数などの値は、ガベージコレクションの対象ではないため、ウィークテーブルから削除されません（関連付けられた値が収集されない限り）。文字列はガベージコレクションの対象ですが、明示的な構築がなく、その等価性は値によって行われるため、オブジェクトよりも値のように動作します。したがって、それらはウィークテーブルから削除されません。</p><p>復活したオブジェクト（つまり、ファイナライズ中のオブジェクト、およびファイナライズ中のオブジェクトを通してのみアクセス可能なオブジェクト）は、ウィークテーブルで特別な動作をします。それらはファイナライザを実行する前にウィーク値から削除されますが、ウィークキーからは、それらのオブジェクトが実際に解放される、ファイナライザの実行後の次のコレクションでのみ削除されます。この動作により、ファイナライザはウィークテーブルを介してオブジェクトに関連付けられたプロパティにアクセスできます。</p><p>ウィークテーブルがコレクションサイクルで復活したオブジェクトに含まれている場合、次のサイクルまで適切にクリアされない可能性があります。</p><h2>2.6 – <a name="2.6">コルーチン</a></h2>

<p>Luaは、<em>協調的マルチスレッディング</em>とも呼ばれるコルーチンをサポートしています。Luaにおけるコルーチンは、独立した実行スレッドを表します。ただし、マルチスレッドシステムのスレッドとは異なり、コルーチンは明示的にyield関数を呼び出すことによってのみ実行を中断します。</p><p><a href="#pdf-coroutine.create"><code>coroutine.create</code></a>を呼び出すことによってコルーチンを作成します。唯一の引数は、コルーチンのメイン関数である関数です。<code>create</code>関数は新しいコルーチンを作成し、そのハンドル（<em>thread</em>型のオブジェクト）を返すだけで、コルーチンを開始しません。</p><p><a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>を呼び出すことによってコルーチンを実行します。<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>を最初に呼び出す際に、<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>によって返されたスレッドを最初の引数として渡すと、コルーチンはそのメイン関数を呼び出すことによって実行を開始します。<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>に渡された追加の引数は、その関数への引数として渡されます。コルーチンの実行が開始されると、コルーチンは終了するか、<em>yield</em>するまで実行を続けます。</p><p>コルーチンは、次の2つの方法で実行を終了できます。1つは、メイン関数が（最後の命令の後、明示的または暗黙的に）戻るときに正常に終了する方法と、もう1つは、保護されていないエラーが発生した場合に異常終了する方法です。正常終了の場合、<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>は<b>true</b>と、コルーチンのメイン関数から返された値を返します。エラーの場合、<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>は<b>false</b>とエラーオブジェクトを返します。この場合、コルーチンはスタックを巻き戻さないため、デバッグAPIを使用してエラー後にスタックを検査できます。</p><p>コルーチンは、<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>を呼び出すことによってyieldします。コルーチンがyieldすると、対応する<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>は、yieldがネストされた関数呼び出し内（つまり、メイン関数ではなく、メイン関数によって直接的または間接的に呼び出された関数内）で発生した場合でも、直ちに返ります。yieldの場合、<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>は<b>true</b>と、<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>に渡された値を返します。次回同じコルーチンを再開すると、<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>への呼び出しが、<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>に渡された追加の引数を返すことで、yieldした場所から実行を継続します。</p><p><a href="#pdf-coroutine.create"><code>coroutine.create</code></a>と同様に、<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>関数もコルーチンを作成しますが、コルーチン自体を返す代わりに、呼び出されるとコルーチンを再開する関数を返します。この関数に渡された引数は、<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>への追加の引数として渡されます。<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>は、<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>によって返されたすべての値を、最初の値（ブールエラーコード）を除いて返します。<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>とは異なり、<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>によって作成された関数は、エラーを呼び出し元に伝播します。この場合、関数はコルーチンも閉じます（<a href="#pdf-coroutine.close"><code>coroutine.close</code></a>を参照）。</p><p>コルーチンの動作例として、次のコードを考えてみましょう</p><pre>     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>これを実行すると、次の出力が生成されます</p><pre>     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>C APIを介してコルーチンを作成および操作することもできます。関数<a href="#lua_newthread"><code>lua_newthread</code></a>、<a href="#lua_resume"><code>lua_resume</code></a>、および<a href="#lua_yield"><code>lua_yield</code></a>を参照してください。</p><h1>3 – <a name="3">言語</a></h1>



<p>このセクションでは、Luaの語彙、構文、および意味について説明します。言い換えれば、このセクションでは、どのトークンが有効か、それらをどのように組み合わせることができるか、およびそれらの組み合わせが何を意味するかについて説明します。</p><p>言語構成は、通常の拡張BNF表記を使用して説明されます。{<em>a</em>}は0個以上の<em>a</em>を意味し、[<em>a</em>]はオプションの<em>a</em>を意味します。非終端記号は非終端記号のように表示され、キーワードは<b>kword</b>のように表示され、その他の終端記号は「<b>=</b>」のように表示されます。Luaの完全な構文は、このマニュアルの最後に<a href="#9">§9</a>にあります。</p><h2>3.1 – <a name="3.1">字句規則</a></h2>

<p>Luaは自由形式の言語です。2つのトークン間の区切り文字として以外は、字句要素（トークン）間のスペースとコメントを無視します。ソースコードでは、Luaは標準ASCII空白文字（スペース、改ページ、改行、復帰、水平タブ、垂直タブ）をスペースとして認識します。</p><p>
Luaの<em>名前</em>（<em>識別子</em>とも呼ばれる）は、ラテン文字、アラビア数字、およびアンダースコアで構成される任意の文字列で、数字で始まらず、予約語でないものであれば使用できます。識別子は、変数、テーブルフィールド、およびラベルに名前を付けるために使用されます。</p><p>次の<em>キーワード</em>は予約されており、名前として使用することはできません。</p><pre>     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>Luaは大文字と小文字を区別する言語です。<code>and</code>は予約語ですが、<code>And</code>と<code>AND</code>は2つの異なる有効な名前です。慣例として、プログラムはアンダースコアと1つ以上の大文字（<a href="#pdf-_VERSION"><code>_VERSION</code></a>など）で始まる名前の作成を避ける必要があります。</p><p>次の文字列は、他のトークンを示します</p><pre>     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p><em>短いリテラル文字列</em>は、一致する単一引用符または二重引用符で区切ることができ、次のCのようなエスケープシーケンスを含めることができます。 '<code>\a</code>' (ベル)、'<code>\b</code>' (バックスペース)、'<code>\f</code>' (改ページ)、'<code>\n</code>' (改行)、'<code>\r</code>' (復帰)、'<code>\t</code>' (水平タブ)、'<code>\v</code>' (垂直タブ)、'<code>\\</code>' (バックスラッシュ)、'<code>\"</code>' (引用符 [二重引用符])、および '<code>\'</code>' (アポストロフィ [単一引用符])。バックスラッシュの後に改行が続くと、文字列内の改行になります。エスケープシーケンス '<code>\z</code>' は、改行を含む後続の空白文字スパンをスキップします。これは、文字列の内容に改行やスペースを追加せずに、長いリテラル文字列を複数行に分割してインデントするのに特に役立ちます。短いリテラル文字列には、エスケープされていない改行や、有効なエスケープシーケンスを形成しないエスケープを含めることはできません。</p><p>埋め込まれたゼロを含む、短いリテラル文字列内の任意のバイトを、その数値で指定できます。これは、エスケープシーケンス <code>\x<em>XX</em></code>（<em>XX</em>は2つの16進数）またはエスケープシーケンス <code>\<em>ddd</em></code>（<em>ddd</em>は最大3つの10進数）を使用して行うことができます。（10進数のエスケープシーケンスの後に数字が続く場合は、正確に3桁で表現する必要があることに注意してください。）</p><p>Unicode文字のUTF-8エンコードは、エスケープシーケンス<code>\u{<em>XXX</em>}</code>（必須の括弧で囲む）を使用してリテラル文字列に挿入できます。ここで、<em>XXX</em>は文字コードポイントを表す1つ以上の16進数です。このコードポイントは、<em>2<sup>31</sup></em>未満の値にすることができます。（Luaはここで元のUTF-8仕様を使用しており、有効なUnicodeコードポイントに限定されません。）</p><p>リテラル文字列は、<em>長い括弧</em>で囲まれた長い形式を使用して定義することもできます。レベル<em>n</em>の<em>開始長い括弧</em>を、左角括弧の後に<em>n</em>個の等号が続き、その後に別の左角括弧が続くものとして定義します。したがって、レベル0の開始長い括弧は<code>[[</code>と記述され、レベル1の開始長い括弧は<code>[=[</code>と記述されます。<em>終了長い括弧</em>も同様に定義されます。たとえば、レベル4の終了長い括弧は<code>]====]</code>と記述されます。<em>長いリテラル</em>は、任意のレベルの開始長い括弧で始まり、同じレベルの最初の終了長い括弧で終わります。同じレベルの終了括弧を除く任意のテキストを含めることができます。この括弧形式のリテラルは、複数行にまたがることができ、エスケープシーケンスを解釈せず、他のレベルの長い括弧を無視します。あらゆる種類の行末シーケンス（復帰、改行、復帰に続く改行、または改行に続く復帰）は、単純な改行に変換されます。開始長い括弧の直後に改行が続く場合、その改行は文字列に含まれません。</p><p>例として、ASCIIを使用するシステム（ '<code>a</code>' が97、改行が10、 '<code>1</code>' が49としてコード化されている）では、以下の5つのリテラル文字列は同じ文字列を表します</p><pre>     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>前の規則によって明示的に影響を受けないリテラル文字列内の任意のバイトは、それ自身を表します。ただし、Luaは解析のためにテキストモードでファイルを開き、システムのファイル関数は一部の制御文字で問題が発生する可能性があります。したがって、バイナリデータは、テキスト以外の文字に対して明示的なエスケープシーケンスを使用する引用符付きリテラルとして表現する方が安全です。</p><p><em>数値定数</em>（または<em>数詞</em>）は、オプションの小数部と、文字 '<code>e</code>' または '<code>E</code>' でマークされたオプションの10進指数で記述できます。Luaは、<code>0x</code>または<code>0X</code>で始まる16進定数も受け入れます。16進定数は、オプションの小数部と、文字 '<code>p</code>' または '<code>P</code>' でマークされ、10進数で記述されたオプションのバイナリ指数も受け入れます。（たとえば、<code>0x1.fp10</code>は1984を示し、これは<em>0x1f / 16</em>に<em>2<sup>10</sup></em>を乗じたものです。）</p><p>基数点または指数を持つ数値定数は浮動小数点数を表します。それ以外の場合、その値が整数に適合するか、16進定数である場合は、整数を表します。それ以外の場合（つまり、オーバーフローする10進数の整数）、浮動小数点数を表します。基数点も指数もない16進数は常に整数値を表します。値がオーバーフローすると、有効な整数に収まるように<em>ラップアラウンド</em>します。</p><p>有効な整数定数の例を次に示します</p><pre>     3   345   0xff   0xBEBADA
</pre><p>有効な浮動小数点定数の例を次に示します</p><pre>     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p><em>コメント</em>は、文字列の外側の任意の場所で二重ハイフン（<code>--</code>）で始まります。<code>--</code>の直後のテキストが開始長い括弧でない場合、コメントは<em>短いコメント</em>であり、行末まで実行されます。それ以外の場合、<em>長いコメント</em>であり、対応する終了長い括弧まで実行されます。</p><h2>3.2 – <a name="3.2">変数</a></h2>

<p>変数は値を格納する場所です。Luaには、グローバル変数、ローカル変数、およびテーブルフィールドの3種類の変数があります。</p><p>単一の名前は、グローバル変数またはローカル変数（または、ローカル変数の特定の種類の関数の仮パラメータ）を表すことができます。</p><pre>	var ::= Name
</pre><p>名前は識別子を示します（<a href="#3.1">§3.1</a>を参照）。</p><p>明示的にローカルとして宣言されない限り、すべての変数名はグローバルであるとみなされます（<a href="#3.3.7">§3.3.7</a>参照）。ローカル変数は<em>レキシカルスコープ</em>を持ちます。ローカル変数は、そのスコープ内で定義された関数から自由にアクセスできます（<a href="#3.5">§3.5</a>参照）。</p><p>変数への最初の代入が行われる前、その値は<b>nil</b>です。</p><p>角括弧は、テーブルのインデックス付けに使用されます。</p><pre>	var ::= prefixexp ‘<b>[</b>’ exp ‘<b>]</b>’
</pre><p>テーブルフィールドへのアクセスは、メタテーブルを介して意味を変更できます（<a href="#2.4">§2.4</a>参照）。</p><p>構文<code>var.Name</code>は、<code>var["Name"]</code>のシンタックスシュガーです。</p><pre>	var ::= prefixexp ‘<b>.</b>’ Name
</pre>

<p>グローバル変数<code>x</code>へのアクセスは、<code>_ENV.x</code>と同等です。チャンクのコンパイル方法により、変数<code>_ENV</code>自体は決してグローバルではありません（<a href="#2.2">§2.2</a>参照）。</p><h2>3.3 – <a name="3.3">ステートメント</a></h2>



<p>Luaは、他の一般的な言語と同様の、ほぼ従来のステートメントセットをサポートしています。このセットには、ブロック、代入、制御構造、関数呼び出し、変数宣言が含まれます。</p><h3>3.3.1 – <a name="3.3.1">ブロック</a></h3>

<p>ブロックはステートメントのリストであり、順次実行されます。</p><pre>	block ::= {stat}
</pre><p>Luaには、ステートメントをセミコロンで区切ったり、セミコロンでブロックを開始したり、セミコロンを2つ続けて記述したりできる、<em>空のステートメント</em>があります。</p><pre>	stat ::= ‘<b>;</b>’
</pre>

<p>関数呼び出しと代入の両方が、開き括弧で始まることができます。この可能性は、Luaの文法にあいまいさを生じさせます。次のフラグメントを考えてみましょう。</p><pre>     a = b + c
     (print or io.write)('done')
</pre><p>文法は、このフラグメントを2つの方法で見ることができます。</p><pre>     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>現在のパーサーは、常にこのような構造を最初の方法で見て、開き括弧を呼び出しの引数の開始として解釈します。このあいまいさを避けるために、括弧で始まるステートメントの前には常にセミコロンを付けるのが良い習慣です。</p><pre>     ;(print or io.write)('done')
</pre>

<p>ブロックを明示的に区切って、単一のステートメントを作成できます。</p><pre>	stat ::= <b>do</b> block <b>end</b>
</pre><p>明示的なブロックは、変数宣言のスコープを制御するのに役立ちます。明示的なブロックは、別のブロックの途中に<b>return</b>ステートメントを追加するためにも使用されることがあります（<a href="#3.3.4">§3.3.4</a>参照）。</p><h3>3.3.2 – <a name="3.3.2">チャンク</a></h3>

<p>Luaのコンパイル単位は、<em>チャンク</em>と呼ばれます。構文的には、チャンクは単なるブロックです。</p><pre>	chunk ::= block
</pre>

<p>Luaは、チャンクを可変数の引数を持つ匿名関数の本体として扱います（<a href="#3.4.11">§3.4.11</a>参照）。そのため、チャンクはローカル変数を定義したり、引数を受け取ったり、値を返したりできます。さらに、そのような匿名関数は、<code>_ENV</code>と呼ばれる外部ローカル変数のスコープ内でコンパイルされます（<a href="#2.2">§2.2</a>参照）。結果の関数は、その変数を使用しなくても、常に<code>_ENV</code>を唯一の外部変数として持ちます。</p><p>チャンクは、ファイルまたはホストプログラム内の文字列に格納できます。チャンクを実行するために、Luaはまずチャンクを<em>ロード</em>し、チャンクのコードを仮想マシンの命令にプリコンパイルします。次に、Luaは仮想マシンのインタープリターを使用して、コンパイルされたコードを実行します。</p><p>チャンクはバイナリ形式にプリコンパイルすることもできます。詳細については、プログラム<code>luac</code>および関数<a href="#pdf-string.dump"><code>string.dump</code></a>を参照してください。ソース形式とコンパイル形式のプログラムは交換可能です。Luaはファイルタイプを自動的に検出して、それに応じて動作します（<a href="#pdf-load"><code>load</code></a>を参照）。</p><h3>3.3.3 – <a name="3.3.3">代入</a></h3>

<p>Luaでは、複数の代入が可能です。したがって、代入の構文では、左側に変数のリスト、右側に式のリストを定義します。両方のリストの要素は、カンマで区切られます。</p><pre>	stat ::= varlist ‘<b>=</b>’ explist
	varlist ::= var {‘<b>,</b>’ var}
	explist ::= exp {‘<b>,</b>’ exp}
</pre><p>式については、<a href="#3.4">§3.4</a>で説明します。</p><p>代入の前に、値のリストは変数のリストの長さに<em>調整</em>されます（<a href="#3.4.12">§3.4.12</a>参照）。</p><p>複数の代入の中で変数が代入と読み取りの両方を行っている場合、Luaはすべての読み取りが代入前の変数の値を取得するようにします。したがって、次のコード</p><pre>     i = 3
     i, a[i] = i+1, 20
</pre><p>は、<code>a[i]</code>の<code>i</code>が（4が代入される前に）3と評価されるため、<code>a[3]</code>を20に設定し、<code>a[4]</code>には影響を与えません。同様に、次の行</p><pre>     x, y = y, x
</pre><p>は、<code>x</code>と<code>y</code>の値を交換し、</p><pre>     x, y, z = y, z, x
</pre><p>は、<code>x</code>、<code>y</code>、および<code>z</code>の値を循環的に並べ替えます。</p><p>この保証は、代入ステートメントの構文内のアクセスのみを対象としていることに注意してください。代入中に呼び出された関数またはメタメソッドが変数の値を変更した場合、Luaはそのアクセスの順序について保証しません。</p><p>グローバル名<code>x = val</code>への代入は、代入<code>_ENV.x = val</code>と同等です（<a href="#2.2">§2.2</a>参照）。</p><p>テーブルフィールドとグローバル変数（実際にはテーブルフィールドでもあります）への代入の意味は、メタテーブルを介して変更できます（<a href="#2.4">§2.4</a>参照）。</p><h3>3.3.4 – <a name="3.3.4">制御構造</a></h3><p>制御構造<b>if</b>、<b>while</b>、および<b>repeat</b>は、通常の意味と使い慣れた構文を持ちます。</p><pre>	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>Luaには、2つの形式の<b>for</b>ステートメントもあります（<a href="#3.3.5">§3.3.5</a>参照）。</p><p>制御構造の条件式は、任意の値 を返すことができます。<b>false</b>と<b>nil</b>の両方がfalseとして評価されます。<b>nil</b>と<b>false</b>以外のすべての値はtrueとして評価されます。特に、数値の0と空の文字列もtrueとして評価されます。</p><p><b>repeat</b>-<b>until</b>ループでは、内部ブロックは<b>until</b>キーワードでは終了せず、条件の後でのみ終了します。したがって、条件はループブロック内で宣言されたローカル変数を参照できます。</p><p><b>goto</b>ステートメントは、プログラム制御をラベルに転送します。構文上の理由から、Luaのラベルもステートメントと見なされます。</p><pre>	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= ‘<b>::</b>’ Name ‘<b>::</b>’
</pre>

<p>ラベルは、ネストされた関数内を除き、定義されているブロック全体で可視になります。gotoは、ローカル変数のスコープに入らない限り、任意の可視ラベルにジャンプできます。ラベルは、同じ名前のラベルが可視になっている場合は、たとえこの他のラベルが外側のブロックで宣言されている場合でも、宣言しないでください。</p><p><b>break</b>ステートメントは、<b>while</b>、<b>repeat</b>、または<b>for</b>ループの実行を終了し、ループ後の次のステートメントにスキップします。</p><pre>	stat ::= <b>break</b>
</pre><p><b>break</b>は、最も内側の囲みループを終了します。</p><p><b>return</b>ステートメントは、関数またはチャンク（匿名関数として扱われます）から値を返すために使用されます。関数は複数の値を返すことができるため、<b>return</b>ステートメントの構文は次のようになります。</p><pre>	stat ::= <b>return</b> [explist] [‘<b>;</b>’]
</pre>

<p><b>return</b>ステートメントは、ブロックの最後のステートメントとしてのみ記述できます。ブロックの途中で<b>return</b>する必要がある場合は、慣用句<code>do return end</code>のように、明示的な内部ブロックを使用できます。これは、<b>return</b>が（内部）ブロックの最後のステートメントになるためです。</p><h3>3.3.5 – <a name="3.3.5">Forステートメント</a></h3>

<p><b>for</b>ステートメントには、数値形式とジェネリック形式の2つの形式があります。</p><h4>数値<b>for</b>ループ</h4>

<p>数値<b>for</b>ループは、制御変数が算術進行をたどる間、コードブロックを繰り返します。次の構文があります。</p><pre>	stat ::= <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b>
</pre><p>指定された識別子（Name）は、ループ本体（<em>ブロック</em>）のローカルである新しい制御変数を定義します。</p><p>ループは、3つの制御式を1回評価することから始まります。それらの値は、それぞれ<em>初期値</em>、<em>制限値</em>、<em>ステップ</em>と呼ばれます。ステップがない場合、デフォルトは1です。</p><p>初期値とステップの両方が整数の場合、ループは整数で実行されます。制限値は整数でない場合があることに注意してください。それ以外の場合、3つの値は浮動小数点数に変換され、ループは浮動小数点数で実行されます。この場合、浮動小数点数の精度に注意してください。</p><p>その初期化の後、ループ本体は、ステップで指定された共通差で、初期値から始まる算術進行をたどる制御変数の値で繰り返されます。負のステップは減少シーケンスを作成します。ゼロに等しいステップはエラーを発生させます。ループは、値が制限値以下（負のステップの場合は制限値以上）である間、続行します。初期値がすでに制限値よりも大きい（または、ステップが負の場合は小さい）場合、本体は実行されません。</p><p>整数ループの場合、制御変数がラップアラウンドすることはありません。代わりに、オーバーフローの場合にループが終了します。</p><p>ループ中に制御変数の値を変更しないでください。ループ後にその値が必要な場合は、ループを終了する前に別の変数に割り当ててください。</p><h4>ジェネリック<b>for</b>ループ</h4>

<p>ジェネリック<b>for</b>ステートメントは、<em>イテレーター</em>と呼ばれる関数を対象として動作します。反復ごとに、イテレーター関数が新しい値を生成するために呼び出され、この新しい値が<b>nil</b>になると停止します。ジェネリック<b>for</b>ループには、次の構文があります。</p><pre>	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {‘<b>,</b>’ Name}
</pre><p>次のような<b>for</b>ステートメント</p><pre>     for <em>var_1</em>, ···, <em>var_n</em> in <em>explist</em> do <em>body</em> end
</pre><p>は、次のように機能します。</p><p>名前<em>var_i</em>は、ループ本体のローカルなループ変数を宣言します。これらの変数の最初の変数が<em>制御変数</em>です。</p><p>ループは、<em>explist</em>を評価して、4つの値を生成することから始まります。<em>イテレーター関数</em>、<em>状態</em>、制御変数の初期値、および<em>終了値</em>です。</p><p>次に、各反復で、Luaはイテレーター関数を2つの引数（状態と制御変数）とともに呼び出します。この呼び出しの結果は、複数の代入の規則に従ってループ変数に割り当てられます（<a href="#3.3.3">§3.3.3</a>参照）。制御変数が<b>nil</b>になると、ループが終了します。それ以外の場合、本体が実行され、ループは次の反復に進みます。</p><p>終了値は、ループが終了したときにリソースを解放するために使用できる、クローズされる変数（<a href="#3.3.8">§3.3.8</a>参照）のように動作します。それ以外の場合は、ループを妨げません。</p><p>ループ中に制御変数の値を変更しないでください。</p><h3>3.3.6 – <a name="3.3.6">ステートメントとしての関数呼び出し</a></h3><p>副作用の可能性を許可するために、関数呼び出しをステートメントとして実行できます。</p><pre>	stat ::= functioncall
</pre><p>この場合、返されたすべての値は破棄されます。関数呼び出しについては、<a href="#3.4.10">§3.4.10</a>で説明します。</p><h3>3.3.7 – <a name="3.3.7">ローカル宣言</a></h3><p>ローカル変数は、ブロック内の任意の場所で宣言できます。宣言には初期化を含めることができます。</p><pre>	stat ::= <b>local</b> attnamelist [‘<b>=</b>’ explist]
	attnamelist ::=  Name attrib {‘<b>,</b>’ Name attrib}
</pre><p>存在する場合、初期代入は複数代入と同じセマンティクスを持ちます（<a href="#3.3.3">§3.3.3</a>参照）。それ以外の場合、すべての変数は<b>nil</b>で初期化されます。</p><p>各変数名の後に属性（山かっこで囲まれた名前）を付けることができます。</p><pre>	attrib ::= [‘<b>&lt;</b>’ Name ‘<b>&gt;</b>’]
</pre><p>可能な属性は2つあります。<code>const</code>は、定数変数、つまり初期化後に代入できない変数を宣言します。<code>close</code>は、クローズされる変数を宣言します（<a href="#3.3.8">§3.3.8</a>参照）。変数のリストには、最大で1つのクローズされる変数を含めることができます。</p><p>チャンクもブロックであるため（<a href="#3.3.2">§3.3.2</a>参照）、ローカル変数を明示的なブロックの外部のチャンクで宣言できます。</p><p>ローカル変数の可視性規則については、<a href="#3.5">§3.5</a>で説明します。</p><h3>3.3.8 – <a name="3.3.8">クローズされる変数</a></h3>

<p>クローズされる変数は、定数ローカル変数のように動作しますが、変数がスコープ外になったときに、通常ブロックの終了、<b>break</b>/<b>goto</b>/<b>return</b>によるブロックの終了、またはエラーによる終了を含め、その値が<em>クローズ</em>される点が異なります。</p><p>ここで、値を<em>クローズする</em>とは、その<code>__close</code>メタメソッドを呼び出すことを意味します。メタメソッドを呼び出すとき、値自体が最初の引数として渡され、終了を引き起こしたエラーオブジェクト（存在する場合）が2番目の引数として渡されます。エラーがない場合は、2番目の引数は<b>nil</b>です。</p><p>クローズされる変数に割り当てられる値は、<code>__close</code>メタメソッドを持つか、false値である必要があります。（<b>nil</b>と<b>false</b>は、クローズされる値として無視されます。）</p><p>同じイベントで複数のクローズされる変数がスコープ外になった場合、それらは宣言された逆の順序でクローズされます。</p><p>クロージングメソッドの実行中にエラーが発生した場合、そのエラーは、変数が定義された通常のコードでのエラーと同様に処理されます。エラーが発生した後も、他の保留中のクロージングメソッドは引き続き呼び出されます。</p><p>コルーチンが yield し、再開されない場合、一部の変数はスコープから外れない可能性があり、そのためクローズされることはありません。（これらの変数は、コルーチン内で作成され、コルーチンが yield した時点でスコープ内にあるものです。）同様に、コルーチンがエラーで終了した場合、スタックを巻き戻さないため、変数をクローズしません。どちらの場合も、ファイナライザーを使用するか、<a href="#pdf-coroutine.close"><code>coroutine.close</code></a>を呼び出して変数をクローズできます。ただし、コルーチンが<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>を介して作成された場合、対応する関数はエラーが発生した場合にコルーチンをクローズします。</p><h2>3.4 – <a name="3.4">式</a></h2>



<p>Lua の基本的な式は次のとおりです。</p><pre>	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= ‘<b>...</b>’
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’
</pre>

<p>数値とリテラル文字列については<a href="#3.1">§3.1</a>で、変数については<a href="#3.2">§3.2</a>で、関数定義については<a href="#3.4.11">§3.4.11</a>で、関数呼び出しについては<a href="#3.4.10">§3.4.10</a>で、テーブルコンストラクターについては<a href="#3.4.9">§3.4.9</a>で説明されています。3つのドット('<code>...</code>')で示される可変長引数式は、可変長引数関数の内部でのみ直接使用できます。これについては<a href="#3.4.11">§3.4.11</a>で説明されています。</p><p>二項演算子には、算術演算子（<a href="#3.4.1">§3.4.1</a>を参照）、ビット演算子（<a href="#3.4.2">§3.4.2</a>を参照）、関係演算子（<a href="#3.4.4">§3.4.4</a>を参照）、論理演算子（<a href="#3.4.5">§3.4.5</a>を参照）、および連結演算子（<a href="#3.4.6">§3.4.6</a>を参照）が含まれます。単項演算子には、単項マイナス（<a href="#3.4.1">§3.4.1</a>を参照）、単項ビット単位 NOT（<a href="#3.4.2">§3.4.2</a>を参照）、単項論理 <b>not</b>（<a href="#3.4.5">§3.4.5</a>を参照）、および単項<em>長さ演算子</em>（<a href="#3.4.7">§3.4.7</a>を参照）が含まれます。</p><h3>3.4.1 – <a name="3.4.1">算術演算子</a></h3><p>Lua は次の算術演算子をサポートしています。</p><ul>
<li><b><code>+</code>: </b>加算</li>
<li><b><code>-</code>: </b>減算</li>
<li><b><code>*</code>: </b>乗算</li>
<li><b><code>/</code>: </b>浮動小数点除算</li>
<li><b><code>//</code>: </b>床関数除算</li>
<li><b><code>%</code>: </b>剰余</li>
<li><b><code>^</code>: </b>べき乗</li>
<li><b><code>-</code>: </b>単項マイナス</li>
</ul>

<p>べき乗と浮動小数点除算を除いて、算術演算子は次のように動作します。両方のオペランドが整数の場合、演算は整数に対して実行され、結果は整数になります。それ以外の場合、両方のオペランドが数値の場合、それらは浮動小数点数に変換され、浮動小数点演算のマシンルール（通常は IEEE 754 標準）に従って演算が実行され、結果は浮動小数点数になります。（文字列ライブラリは算術演算で文字列を数値に強制変換します。詳細については<a href="#3.4.3">§3.4.3</a>を参照してください。）</p><p>べき乗と浮動小数点除算（<code>/</code>）は、常にオペランドを浮動小数点数に変換し、結果は常に浮動小数点数になります。べき乗は ISO&nbsp;C 関数 <code>pow</code> を使用するため、整数以外の指数にも対応できます。</p><p>床関数除算（<code>//</code>）は、商を負の無限大方向に丸める除算であり、オペランドの除算の床を返します。</p><p>剰余は、商を負の無限大方向（床関数除算）に丸める除算の余りとして定義されます。</p><p>整数演算でオーバーフローが発生した場合、すべての演算は<em>ラップアラウンド</em>します。</p><h3>3.4.2 – <a name="3.4.2">ビット演算子</a></h3><p>Lua は次のビット演算子をサポートしています。</p><ul>
<li><b><code>&amp;</code>: </b>ビット単位 AND</li>
<li><b><code>|</code>: </b>ビット単位 OR</li>
<li><b><code>~</code>: </b>ビット単位排他的 OR</li>
<li><b><code>&gt;&gt;</code>: </b>右シフト</li>
<li><b><code>&lt;&lt;</code>: </b>左シフト</li>
<li><b><code>~</code>: </b>単項ビット単位 NOT</li>
</ul>

<p>すべてのビット単位演算は、オペランドを整数に変換し（<a href="#3.4.3">§3.4.3</a>を参照）、それらの整数のすべてのビットで演算を行い、整数を返します。</p><p>右シフトと左シフトの両方で、空いているビットはゼロで埋められます。負の変位は反対方向にシフトします。整数のビット数以上の絶対値を持つ変位は、ゼロになります（すべてのビットがシフトアウトされるため）。</p><h3>3.4.3 – <a name="3.4.3">強制型変換と変換</a></h3><p>Lua は、実行時にいくつかの型と表現の間で自動変換を行います。ビット単位演算子は、常に浮動小数点オペランドを整数に変換します。べき乗と浮動小数点除算は、常に整数オペランドを浮動小数点数に変換します。混合数値（整数と浮動小数点数）に適用される他のすべての算術演算は、整数オペランドを浮動小数点数に変換します。C API は、必要に応じて整数を浮動小数点数に、浮動小数点数を整数に変換します。さらに、文字列連結は、文字列に加えて数値を引数として受け入れます。</p><p>整数から浮動小数点数への変換では、整数値が浮動小数点数として正確に表現できる場合、それが結果となります。それ以外の場合、変換は、最も近い大きい値または最も近い小さい表現可能な値を取得します。この種の変換は決して失敗しません。</p><p>浮動小数点数から整数への変換では、浮動小数点数が整数として正確に表現できるかどうか（つまり、浮動小数点数が整数値を持ち、整数の表現範囲内にあるかどうか）をチェックします。そうである場合、その表現が結果になります。それ以外の場合、変換は失敗します。</p><p>Lua のいくつかの場所では、必要に応じて文字列を数値に強制変換します。特に、文字列ライブラリは、すべての算術演算で文字列を数値に強制変換しようとするメタメソッドを設定します。変換が失敗した場合、ライブラリは他のオペランドのメタメソッド（存在する場合）を呼び出すか、エラーを発生させます。ビット単位演算子は、この強制変換を行わないことに注意してください。</p><p>文字列から数値への暗黙的な強制変換に依存しないことは常に良い習慣です。これらは常に適用されるわけではないためです。特に、<code>"1"==1</code> は false であり、<code>"1"&lt;1</code> はエラーを発生させます（<a href="#3.4.4">§3.4.4</a>を参照）。これらの強制変換は主に互換性のために存在し、将来のバージョンの言語で削除される可能性があります。</p><p>文字列は、その構文と Lua レクサーのルールに従って、整数または浮動小数点数に変換されます。文字列には、先頭と末尾の空白と符号が含まれる場合もあります。文字列から数値へのすべての変換は、基数文字としてドットと現在のロケールマークの両方を受け入れます。（ただし、Lua レクサーはドットのみを受け入れます。）文字列が有効な数値でない場合、変換は失敗します。必要に応じて、この最初のステップの結果は、浮動小数点数と整数間の変換に関する前のルールに従って、特定の数値サブタイプに変換されます。</p><p>数値から文字列への変換では、指定されていない人間が読める形式を使用します。数値を特定の方法で文字列に変換するには、関数<a href="#pdf-string.format"><code>string.format</code></a>を使用してください。</p><h3>3.4.4 – <a name="3.4.4">関係演算子</a></h3><p>Lua は次の関係演算子をサポートしています。</p><ul>
<li><b><code>==</code>: </b>等しい</li>
<li><b><code>~=</code>: </b>等しくない</li>
<li><b><code>&lt;</code>: </b>より小さい</li>
<li><b><code>&gt;</code>: </b>より大きい</li>
<li><b><code>&lt;=</code>: </b>以下</li>
<li><b><code>&gt;=</code>: </b>以上</li>
</ul><p>これらの演算子は常に <b>false</b> または <b>true</b> を返します。</p><p>等価性（<code>==</code>）は、最初にオペランドの型を比較します。型が異なる場合、結果は <b>false</b> です。それ以外の場合、オペランドの値が比較されます。文字列は、バイト内容が同じ場合に等しくなります。数値は、数学的に同じ値を表す場合に等しくなります。</p><p>テーブル、ユーザーデータ、およびスレッドは参照によって比較されます。2つのオブジェクトが等しいと見なされるのは、同じオブジェクトである場合のみです。新しいオブジェクト（テーブル、ユーザーデータ、またはスレッド）を作成するたびに、この新しいオブジェクトは、以前に存在したオブジェクトとは異なります。関数は常にそれ自身と等しくなります。検出可能な違い（動作の違い、定義の違い）を持つ関数は常に異なります。異なる時点で作成されたが、検出可能な違いがない関数は、等しいと分類される場合とされない場合があります（内部キャッシュの詳細によって異なります）。</p><p><code>__eq</code>メタメソッドを使用すると、Lua がテーブルとユーザーデータを比較する方法を変更できます（<a href="#2.4">§2.4</a>を参照）。</p><p>等価性比較では、文字列を数値に、またはその逆に変換しません。したがって、<code>"0"==0</code>は<b>false</b>と評価され、<code>t[0]</code>と<code>t["0"]</code>はテーブル内の異なるエントリを表します。</p><p>演算子<code>~=</code>は、等価性（<code>==</code>）の否定です。</p><p>順序演算子は次のように動作します。両方の引数が数値の場合、それらはサブタイプに関係なく、数学的な値に従って比較されます。それ以外の場合、両方の引数が文字列である場合、それらの値は現在のロケールに従って比較されます。それ以外の場合、Lua は <code>__lt</code> または <code>__le</code> メタメソッドを呼び出そうとします（<a href="#2.4">§2.4</a>を参照）。比較 <code>a &gt; b</code> は <code>b &lt; a</code> に変換され、<code>a &gt;= b</code> は <code>b &lt;= a</code> に変換されます。</p><p>IEEE 754 標準に従い、特殊値 NaN は、それ自身を含め、どの値よりも小さい、等しい、または大きいとは見なされません。</p><h3>3.4.5 – <a name="3.4.5">論理演算子</a></h3><p>Lua の論理演算子は、<b>and</b>、<b>or</b>、および <b>not</b> です。制御構造（<a href="#3.3.4">§3.3.4</a>を参照）と同様に、すべての論理演算子は、<b>false</b> と <b>nil</b> の両方を false とみなし、その他を true とみなします。</p><p>否定演算子 <b>not</b> は、常に <b>false</b> または <b>true</b> を返します。論理積演算子 <b>and</b> は、この値が <b>false</b> または <b>nil</b> である場合は最初の引数を返し、それ以外の場合は <b>and</b> は2番目の引数を返します。論理和演算子 <b>or</b> は、この値が <b>nil</b> および <b>false</b> と異なる場合は最初の引数を返し、それ以外の場合は <b>or</b> は2番目の引数を返します。<b>and</b> と <b>or</b> の両方で短絡評価が使用されます。つまり、2番目のオペランドは必要な場合にのみ評価されます。以下にいくつかの例を示します。</p><pre>     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre>




<h3>3.4.6 – <a name="3.4.6">連結</a></h3><p>Lua の文字列連結演算子は、2つのドット('<code>..</code>')で示されます。両方のオペランドが文字列または数値の場合、数値は指定されていない形式で文字列に変換されます（<a href="#3.4.3">§3.4.3</a>を参照）。それ以外の場合、<code>__concat</code>メタメソッドが呼び出されます（<a href="#2.4">§2.4</a>を参照）。</p><h3>3.4.7 – <a name="3.4.7">長さ演算子</a></h3>

<p>長さ演算子は、単項プレフィックス演算子 <code>#</code> で示されます。</p><p>文字列の長さは、そのバイト数です。（つまり、各文字が1バイトの場合の文字列長の通常の意味です。）</p><p>テーブルに適用された長さ演算子は、そのテーブルの境界を返します。テーブル <code>t</code> の<em>境界</em>は、次の条件を満たす任意の非負の整数です。</p><pre>     (border == 0 or t[border] ~= nil) and
     (t[border + 1] == nil or border == math.maxinteger)
</pre><p>言葉で言えば、境界とは、テーブル内に存在する正の整数インデックスであり、それに続いて存在しないインデックスが続く場合と、2つの制限ケースがあります。インデックス 1 が存在しない場合はゼロ、そのインデックスが存在する場合は整数の最大値です。正の整数ではないキーは、境界に干渉しないことに注意してください。</p><p>境界が1つしかないテーブルは、<em>シーケンス</em>と呼ばれます。たとえば、テーブル <code>{10, 20, 30, 40, 50}</code> は境界（5）が1つしかないため、シーケンスです。テーブル <code>{10, 20, 30, nil, 50}</code> には2つの境界（3と5）があるため、シーケンスではありません。（インデックス 4 の <b>nil</b> は<em>穴</em>と呼ばれます。）テーブル <code>{nil, 20, 30, nil, nil, 60, nil}</code> には3つの境界（0、3、および 6）があるため、これもシーケンスではありません。テーブル <code>{}</code> は境界 0 のシーケンスです。</p><p><code>t</code> がシーケンスの場合、<code>#t</code> はその唯一の境界を返し、これはシーケンスの長さという直感的な概念に対応します。<code>t</code> がシーケンスでない場合、<code>#t</code> はその境界のいずれかを返す可能性があります。（どの境界が返されるかは、テーブルの内部表現の詳細に依存し、テーブルがどのようにデータが格納されたか、および数値ではないキーのメモリアドレスに依存します。）</p><p>テーブルの長さの計算は、最悪の場合でも <em>O(log n)</em> の時間が保証されています。ここで、<em>n</em> はテーブル内の最大の整数キーです。</p><p>プログラムは、<code>__len</code> メタメソッド（<a href="#2.4">§2.4</a> を参照）を使用して、文字列以外の任意の値に対する長さ演算子の動作を変更できます。</p><h3>3.4.8 – <a name="3.4.8">優先順位</a></h3><p>Lua における演算子の優先順位は、以下の表に従い、低いものから高いものの順に示します。</p><pre>     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>通常どおり、式での優先順位を変更するために括弧を使用できます。連結演算子 (<code>..</code>) とべき乗演算子 (<code>^</code>) は右結合です。その他のすべての二項演算子は左結合です。</p><h3>3.4.9 – <a name="3.4.9">テーブルコンストラクタ</a></h3><p>テーブルコンストラクタは、テーブルを作成する式です。コンストラクタが評価されるたびに、新しいテーブルが作成されます。コンストラクタは、空のテーブルを作成したり、テーブルを作成してそのフィールドの一部を初期化したりするために使用できます。コンストラクタの一般的な構文は次のとおりです。</p><pre>	tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp
	fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’
</pre>

<p><code>[exp1] = exp2</code> の形式の各フィールドは、キーが <code>exp1</code> で値が <code>exp2</code> のエントリを新しいテーブルに追加します。<code>name = exp</code> の形式のフィールドは、<code>["name"] = exp</code> と同等です。<code>exp</code> の形式のフィールドは、<code>[i] = exp</code> と同等です。ここで、<code>i</code> は 1 から始まる連続した整数です。その他の形式のフィールドは、このカウントに影響しません。たとえば、</p><pre>     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>は、次のものと同等です。</p><pre>     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>コンストラクタ内での代入の順序は未定義です。（この順序は、キーが繰り返されている場合にのみ重要になります。）</p><p>リスト内の最後のフィールドが <code>exp</code> の形式であり、その式が複数結果の式である場合、この式によって返されるすべての値がリストに連続して入力されます（<a href="#3.4.12">§3.4.12</a> を参照）。</p><p>フィールドリストには、機械生成されたコードの便宜のために、オプションの末尾の区切り記号を含めることができます。</p><h3>3.4.10 – <a name="3.4.10">関数呼び出し</a></h3><p>Lua での関数呼び出しの構文は次のとおりです。</p><pre>	functioncall ::= prefixexp args
</pre><p>関数呼び出しでは、最初に prefixexp と args が評価されます。prefixexp の値の型が <em>function</em> である場合、この関数は指定された引数で呼び出されます。それ以外の場合、prefixexp の <code>__call</code> メタメソッドが存在すればそれが呼び出されます。その最初の引数は prefixexp の値であり、その後に元の呼び出し引数が続きます（<a href="#2.4">§2.4</a> を参照）。</p><p>次の形式</p><pre>	functioncall ::= prefixexp ‘<b>:</b>’ Name args
</pre><p>は、メソッドをエミュレートするために使用できます。<code>v:name(<em>args</em>)</code> の呼び出しは、<code>v.name(v,<em>args</em>)</code> のシンタックスシュガーです。ただし、<code>v</code> は一度だけ評価されます。</p><p>引数の構文は次のとおりです。</p><pre>	args ::= ‘<b>(</b>’ [explist] ‘<b>)</b>’
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>すべての引数式は、呼び出し前に評価されます。<code>f{<em>fields</em>}</code> の形式の呼び出しは、<code>f({<em>fields</em>})</code> のシンタックスシュガーです。つまり、引数リストは単一の新しいテーブルです。<code>f'<em>string</em>'</code> (または <code>f"<em>string</em>"</code> または <code>f[[<em>string</em>]]</code>) の形式の呼び出しは、<code>f('<em>string</em>')</code> のシンタックスシュガーです。つまり、引数リストは単一のリテラル文字列です。</p><p>閉じられる変数のスコープ内にない <code>return <em>functioncall</em></code> の形式の呼び出しは、<em>末尾呼び出し</em>と呼ばれます。Lua は、<em>適切な末尾呼び出し</em>（または<em>適切な末尾再帰</em>）を実装しています。末尾呼び出しでは、呼び出される関数は呼び出し元の関数のスタックエントリを再利用します。したがって、プログラムが実行できるネストされた末尾呼び出しの数に制限はありません。ただし、末尾呼び出しは、呼び出し元の関数に関するデバッグ情報を消去します。末尾呼び出しは、<b>return</b> が引数として単一の関数呼び出しを持ち、閉じられる変数のスコープ外にある特定の構文でのみ発生することに注意してください。この構文により、呼び出し元の関数は、介入アクションなしに、呼び出された関数の戻り値を正確に返します。したがって、次の例はどれも末尾呼び出しではありません。</p><pre>     return (f(x))        -- results adjusted to 1
     return 2 * f(x)      -- result multiplied by 2
     return x, f(x)       -- additional results
     f(x); return         -- results discarded
     return x or f(x)     -- results adjusted to 1
</pre>




<h3>3.4.11 – <a name="3.4.11">関数定義</a></h3>

<p>関数定義の構文は次のとおりです。</p><pre>	functiondef ::= <b>function</b> funcbody
	funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b>
</pre>

<p>次のシンタックスシュガーは、関数定義を簡略化します。</p><pre>	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]
</pre><p>文</p><pre>     function f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     f = function () <em>body</em> end
</pre><p>文</p><pre>     function t.a.b.c.f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     t.a.b.c.f = function () <em>body</em> end
</pre><p>文</p><pre>     local function f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     local f; f = function () <em>body</em> end
</pre><p>ではなく、</p><pre>     local f = function () <em>body</em> end
</pre><p>（これは、関数の本体に <code>f</code> への参照が含まれている場合にのみ違いが生じます。）</p><p>関数定義は、型が <em>function</em> の実行可能な式です。Lua がチャンクをプリコンパイルするとき、その関数本体はすべてプリコンパイルされますが、まだ作成されていません。その後、Lua が関数定義を実行するたびに、関数は<em>インスタンス化</em>（または<em>クローズ</em>）されます。この関数インスタンス、または<em>クロージャ</em>は、式の最終的な値です。</p><p>パラメータは、引数値で初期化されるローカル変数として機能します。</p><pre>	parlist ::= namelist [‘<b>,</b>’ ‘<b>...</b>’] | ‘<b>...</b>’
</pre><p>Lua 関数が呼び出されると、関数が<em>可変長引数関数</em>でない限り、引数リストをパラメータリストの長さに調整します（<a href="#3.4.12">§3.4.12</a> を参照）。可変長引数関数は、パラメータリストの最後に3つのドット（<code>...</code>）で示されます。可変長引数関数は、引数リストを調整しません。代わりに、すべての追加引数を収集し、3つのドットとしても記述される<em>可変長引数式</em>を介して関数に提供します。この式の値は、複数結果を持つ関数と同様に、すべての実際の追加引数のリストです（<a href="#3.4.12">§3.4.12</a> を参照）。</p><p>例として、次の定義を検討してください。</p><pre>     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>次に、引数からパラメータと可変長引数式への次のマッピングがあります。</p><pre>     CALL             PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>結果は、<b>return</b> ステートメント（<a href="#3.3.4">§3.3.4</a> を参照）を使用して返されます。制御が <b>return</b> ステートメントに遭遇せずに関数の終わりに到達した場合、関数は結果なしで返されます。</p><p>関数が返すことができる値の数には、システムに依存する制限があります。この制限は、1000 より大きいことが保証されています。</p><p><em>コロン</em>構文は、関数に暗黙的な追加のパラメータ <code>self</code> を追加することで、<em>メソッド</em>をエミュレートするために使用されます。したがって、文</p><pre>     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>は、次のシンタックスシュガーです。</p><pre>     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>




<h3>3.4.12 – <a name="3.4.12">式のリスト、複数の結果、および調整</a></h3>

<p>関数呼び出しと可変長引数式の両方が、複数の値を返す可能性があります。これらの式は、<em>複数結果の式</em>と呼ばれます。</p><p>複数結果の式が式のリストの最後の要素として使用される場合、式からのすべての結果が式のリストによって生成された値のリストに追加されます。式のリストを予期する場所に単一の式がある場合、その（シングルトン）リストの最後の式になることに注意してください。</p><p>これらは、Lua が式のリストを予期する場所です。</p><ul>

<li><b>return</b> ステートメント。たとえば、<code>return e1, e2, e3</code> （<a href="#3.3.4">§3.3.4</a> を参照）。</li>

<li>テーブルコンストラクタ。たとえば、<code>{e1, e2, e3}</code> （<a href="#3.4.9">§3.4.9</a> を参照）。</li>

<li>関数呼び出しの引数。たとえば、<code>foo(e1, e2, e3)</code> （<a href="#3.4.10">§3.4.10</a> を参照）。</li>

<li>複数代入。たとえば、<code>a , b, c = e1, e2, e3</code> （<a href="#3.3.3">§3.3.3</a> を参照）。</li>

<li>ローカル宣言。たとえば、<code>local a , b, c = e1, e2, e3</code> （<a href="#3.3.7">§3.3.7</a> を参照）。</li>

<li>汎用 <b>for</b> ループでの初期値。たとえば、<code>for k in e1, e2, e3 do ... end</code> （<a href="#3.3.5">§3.3.5</a> を参照）。</li>

</ul><p>最後の4つのケースでは、式のリストからの値のリストを特定の長さに<em>調整</em>する必要があります。つまり、可変長引数関数ではない関数への呼び出しのパラメータ数（<a href="#3.4.11">§3.4.11</a> を参照）、複数代入またはローカル宣言の変数の数、および汎用 <b>for</b> ループの場合は正確に4つの値です。<em>調整</em>は、次の規則に従います。必要な値よりも多くの値がある場合、余分な値は破棄されます。必要な値よりも少ない値がある場合、リストは <b>nil</b> で拡張されます。式のリストが複数結果の式で終わる場合、調整の前に、その式からのすべての結果が値のリストに入力されます。</p><p>複数結果の式が、最後の要素ではない式のリストで使用されている場合、または構文が単一の式を予期する場所で使用されている場合、Lua はその式の結果リストを1つの要素に調整します。特定の場合として、構文は括弧で囲まれた式の中に単一の式があることを予期します。したがって、複数結果の式の周囲に括弧を追加すると、正確に1つの結果が生成されます。</p><p>構文が単一の式を予期する場所で可変長引数式を使用する必要はほとんどありません。（通常、可変長引数部分の前に通常のパラメータを追加して、そのパラメータを使用する方が簡単です。）そのような必要がある場合は、可変長引数式を単一の変数に割り当てて、その変数を代わりに使用することをお勧めします。</p><p>複数結果の式の使用例を次に示します。すべての場合において、構成が「n番目の結果」を必要とし、そのような結果がない場合は、<b>nil</b> が使用されます。</p><pre>     print(x, f())      -- prints x and all results from f().
     print(x, (f()))    -- prints x and the first result from f().
     print(f(), x)      -- prints the first result from f() and x.
     print(1 + f())     -- prints 1 added to the first result from f().
     local x = ...      -- x gets the first vararg argument.
     x,y = ...          -- x gets the first vararg argument,
                        -- y gets the second vararg argument.
     x,y,z = w, f()     -- x gets w, y gets the first result from f(),
                        -- z gets the second result from f().
     x,y,z = f()        -- x gets the first result from f(),
                        -- y gets the second result from f(),
                        -- z gets the third result from f().
     x,y,z = f(), g()   -- x gets the first result from f(),
                        -- y gets the first result from g(),
                        -- z gets the second result from g().
     x,y,z = (f())      -- x gets the first result from f(), y and z get nil.
     return f()         -- returns all results from f().
     return x, ...      -- returns x and all received vararg arguments.
     return x,y,f()     -- returns x, y, and all results from f().
     {f()}              -- creates a list with all results from f().
     {...}              -- creates a list with all vararg arguments.
     {f(), 5}           -- creates a list with the first result from f() and 5.
</pre>






<h2>3.5 – <a name="3.5">可視性ルール</a></h2>

<p>Lua は、レキシカルスコープの言語です。ローカル変数のスコープは、宣言の後の最初のステートメントで始まり、宣言を含む最も内側のブロックの最後の非voidステートメントまで続きます。（<em>Voidステートメント</em>は、ラベルと空のステートメントです。）次の例を検討してください。</p><pre>     x = 10                -- global variable
     do                    -- new block
       local x = x         -- new 'x', with value 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- another block
         local x = x+1     -- another 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (the global one)
</pre>

<p><code>local x = x</code> のような宣言では、宣言されている新しい <code>x</code> はまだスコープ内ではないため、2番目の <code>x</code> は外部変数を参照することに注意してください。</p><p>レキシカルスコープルールのため、ローカル変数は、そのスコープ内で定義された関数によって自由にアクセスできます。内側の関数で使用されるローカル変数は、内側の関数内で<em>アップ値</em>（または<em>外部ローカル変数</em>、または単に<em>外部変数</em>）と呼ばれます。</p><p><b>local</b> ステートメントを実行するたびに、新しいローカル変数が定義されることに注意してください。次の例を検討してください。</p><pre>     a = {}
     local x = 20
     for i = 1, 10 do
       local y = 0
       a[i] = function () y = y + 1; return x + y end
     end
</pre><p>ループは、10個のクロージャ（つまり、匿名関数の10個のインスタンス）を作成します。これらの各クロージャは異なる <code>y</code> 変数を使用しますが、すべて同じ <code>x</code> を共有します。</p><h1>4 – <a name="4">アプリケーションプログラミングインターフェイス</a></h1>



<p>このセクションでは、Lua の C API、つまり、Lua と通信するためにホストプログラムで使用できる C 関数のセットについて説明します。すべての API 関数および関連する型と定数は、ヘッダーファイル <a name="pdf-lua.h"><code>lua.h</code></a> で宣言されています。</p><p>「関数」という用語を使用する場合でも、API の任意の機能は、代わりにマクロとして提供される場合があります。特に明記されていない限り、そのようなすべてのマクロは、引数を正確に一度だけ使用します（常に Lua ステートである最初の引数を除く）。したがって、隠れた副作用は生成されません。</p><p>ほとんどの C ライブラリと同様に、Lua API 関数は、引数の有効性または一貫性をチェックしません。ただし、マクロ <a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a> を定義して Lua をコンパイルすることにより、この動作を変更できます。</p><p>Lua ライブラリは完全にリエントラントです。つまり、グローバル変数はありません。必要なすべての情報を、<em>Lua ステート</em>と呼ばれる動的な構造に保持します。</p><p>各 Lua ステートには、独立した協調的な実行ラインに対応する1つ以上のスレッドがあります。型 <a href="#lua_State"><code>lua_State</code></a> は（その名前にもかかわらず）スレッドを参照します。（間接的に、スレッドを介して、スレッドに関連付けられている Lua ステートも参照します。）</p><p>スレッドへのポインタは、ライブラリ内のすべての関数への最初の引数として渡す必要があります。ただし、<a href="#lua_newstate"><code>lua_newstate</code></a> は例外です。これは、Lua ステートを最初から作成し、新しいステートの<em>メインスレッド</em>へのポインタを返します。</p><h2>4.1 – <a name="4.1">スタック</a></h2>



<p>Lua は、値を C との間で受け渡すために、<em>仮想スタック</em>を使用します。このスタック内の各要素は、Lua 値（<b>nil</b>、数値、文字列など）を表します。API 内の関数は、受け取る Lua ステートパラメータを介してこのスタックにアクセスできます。</p><p>LuaがCを呼び出すたびに、呼び出された関数は新しいスタックを取得します。このスタックは、以前のスタックや、まだアクティブなC関数のスタックとは独立しています。このスタックには、最初にC関数への引数が含まれており、C関数は一時的なLua値を保存し、呼び出し元に返される結果をプッシュする必要があります（<a href="#lua_CFunction"><code>lua_CFunction</code></a>を参照）。</p><p>便宜上、APIのほとんどのクエリ操作は厳密なスタック規律に従いません。代わりに、<em>インデックス</em>を使用してスタック内の任意の要素を参照できます。正のインデックスは絶対スタック位置を表し、スタックの底を1として始まります。負のインデックスは、スタックの最上部を基準としたオフセットを表します。より具体的には、スタックに<em>n</em>個の要素がある場合、インデックス1は最初の要素（つまり、最初にスタックにプッシュされた要素）を表し、インデックス<em>n</em>は最後の要素を表します。インデックス-1も最後の要素（つまり、最上部の要素）を表し、インデックス-<em>n</em>は最初の要素を表します。</p><h3>4.1.1 – <a name="4.1.1">スタックサイズ</a></h3>

<p>Lua APIを操作するときは、一貫性を確保する責任があります。特に、<em>スタックオーバーフローを制御する責任があります</em>。API関数を呼び出すときは、スタックに結果を格納するのに十分な空き容量があることを確認する必要があります。</p><p>上記ルールには1つの例外があります。結果の数が固定されていないLua関数を呼び出す場合（<a href="#lua_call"><code>lua_call</code></a>を参照）、Luaはスタックにすべての結果を格納するのに十分なスペースがあることを保証します。ただし、追加のスペースは保証しません。したがって、このような呼び出しの後にスタックに何かをプッシュする前に、<a href="#lua_checkstack"><code>lua_checkstack</code></a>を使用する必要があります。</p><p>LuaがCを呼び出すたびに、スタックに少なくとも<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>個の追加要素のためのスペースがあることを保証します。つまり、最大で<code>LUA_MINSTACK</code>個の値を安全にプッシュできます。<code>LUA_MINSTACK</code>は20として定義されているため、コードが要素をスタックにプッシュするループがない限り、通常はスタック領域を気にする必要はありません。必要に応じて、関数<a href="#lua_checkstack"><code>lua_checkstack</code></a>を使用して、スタックに新しい要素をプッシュするための十分なスペースがあることを確認できます。</p><h3>4.1.2 – <a name="4.1.2">有効なインデックスと許容可能なインデックス</a></h3>

<p>スタックインデックスを受け取るAPIの関数は、<em>有効なインデックス</em>または<em>許容可能なインデックス</em>でのみ機能します。</p><p><em>有効なインデックス</em>とは、変更可能なLua値を格納する位置を参照するインデックスです。これは、1からスタックの最上部（<code>1 ≤ abs(index) ≤ top</code>）までのスタックインデックスと、Cコードからアクセスできるがスタックにはないいくつかの位置を表す<em>擬似インデックス</em>で構成されます。擬似インデックスは、レジストリ（<a href="#4.3">§4.3</a>を参照）とC関数のアップバリュー（<a href="#4.2">§4.2</a>を参照）にアクセスするために使用されます。</p><p>特定の変更可能な位置を必要とせず、値のみを必要とする関数（クエリ関数など）は、許容可能なインデックスで呼び出すことができます。<em>許容可能なインデックス</em>は、有効なインデックスのいずれかですが、スタック用に割り当てられた領域内のスタックの最上部より後の任意の正のインデックス、つまりスタックサイズまでのインデックスにすることもできます。（0は許容可能なインデックスではないことに注意してください。）現在のC関数の実際のアップバリュー数よりも大きいアップバリュー（<a href="#4.2">§4.2</a>を参照）へのインデックスも許容されます（ただし、無効です）。特に記載がない限り、APIの関数は許容可能なインデックスで動作します。</p><p>許容可能なインデックスは、スタックをクエリするときにスタックの最上部に対する追加のテストを回避するのに役立ちます。たとえば、C関数は、3番目の引数があるかどうかを確認する必要なく、つまり3が有効なインデックスであるかどうかを確認する必要なく、3番目の引数をクエリできます。</p><p>許容可能なインデックスで呼び出すことができる関数の場合、無効なインデックスは、仮想型<a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>の値を含むかのように扱われ、これはnil値のように動作します。</p><h3>4.1.3 – <a name="4.1.3">文字列へのポインタ</a></h3>

<p>APIのいくつかの関数は、スタック内のLua文字列へのポインタ（<code>const char*</code>）を返します。（<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>、<a href="#lua_pushlstring"><code>lua_pushlstring</code></a>、<a href="#lua_pushstring"><code>lua_pushstring</code></a>、<a href="#lua_tolstring"><code>lua_tolstring</code></a>を参照。また、補助ライブラリの<a href="#luaL_checklstring"><code>luaL_checklstring</code></a>、<a href="#luaL_checkstring"><code>luaL_checkstring</code></a>、<a href="#luaL_tolstring"><code>luaL_tolstring</code></a>も参照）。</p><p>一般に、Luaのガベージコレクションは内部メモリを解放または移動し、内部文字列へのポインタを無効にする可能性があります。これらのポインタを安全に使用できるように、APIは、スタックインデックスの文字列へのポインタは、そのインデックスの文字列値がスタックから削除されない限り有効であることを保証します。（ただし、別のインデックスに移動することはできます。）インデックスが（アップバリューを参照する）擬似インデックスである場合、ポインタは、対応する呼び出しがアクティブであり、対応するアップバリューが変更されない限り有効です。</p><p>デバッグインターフェースの一部の関数も、<a href="#lua_getlocal"><code>lua_getlocal</code></a>、<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>、<a href="#lua_setlocal"><code>lua_setlocal</code></a>、<a href="#lua_setupvalue"><code>lua_setupvalue</code></a>など、文字列へのポインタを返します。これらの関数では、呼び出し元の関数がアクティブであり、指定されたクロージャ（指定されている場合）がスタック内にある限り、ポインタが有効であることが保証されます。</p><p>これらの保証を除いて、ガベージコレクタは内部文字列へのポインタを自由に無効にすることができます。</p><h2>4.2 – <a name="4.2">Cクロージャ</a></h2>

<p>C関数が作成されるとき、いくつかの値をそれに関連付けて、<em>Cクロージャ</em>を作成できます（<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>を参照）。これらの値は<em>アップバリュー</em>と呼ばれ、呼び出されるたびに関数からアクセスできます。</p><p>C関数が呼び出されるたびに、そのアップバリューは特定の擬似インデックスに配置されます。これらの擬似インデックスは、マクロ<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>によって生成されます。関数に関連付けられた最初のアップバリューは、インデックス<code>lua_upvalueindex(1)</code>にあり、以下同様です。<code>lua_upvalueindex(<em>n</em>)</code>へのアクセスは、<em>n</em>が現在の関数のアップバリューの数よりも大きい場合（ただし、クロージャ内のアップバリューの最大数に1を加えた256以下の場合）は、許容可能だが無効なインデックスを生成します。</p><p>Cクロージャは、対応するアップバリューの値を変更することもできます。</p><h2>4.3 – <a name="4.3">レジストリ</a></h2>

<p>Luaは、任意のCコードがLua値を格納するために使用できる、事前定義されたテーブルである<em>レジストリ</em>を提供します。レジストリテーブルは、常に擬似インデックス<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>でアクセスできます。任意のCライブラリは、このテーブルにデータを格納できますが、他のライブラリが使用するキーとは異なるキーを選択して、競合を回避する必要があります。通常、キーとしてライブラリ名を含む文字列、またはコード内のCオブジェクトのアドレスを持つライトuserdata、またはコードによって作成された任意のLuaオブジェクトを使用する必要があります。変数名と同様に、アンダースコアで始まり、大文字が続く文字列キーはLua用に予約されています。</p><p>レジストリの整数キーは、参照メカニズム（<a href="#luaL_ref"><code>luaL_ref</code></a>を参照）およびいくつかの事前定義された値によって使用されます。したがって、レジストリの整数キーを他の目的で使用しないでください。</p><p>新しいLua状態を作成すると、そのレジストリにはいくつかの事前定義された値が付属します。これらの事前定義された値には、<code>lua.h</code>の定数として定義された整数キーでインデックスが付けられています。次の定数が定義されています</p><ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b> このインデックスでは、レジストリは状態のメインスレッドを持ちます。（メインスレッドは、状態とともに作成されたものです。）</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b> このインデックスでは、レジストリはグローバル環境を持ちます。</li>
</ul>




<h2>4.4 – <a name="4.4">Cでのエラー処理</a></h2>



<p>内部的に、LuaはCの<code>longjmp</code>機能を使用してエラーを処理します。（Luaは、C++としてコンパイルした場合、例外を使用します。詳細については、ソースコードで<code>LUAI_THROW</code>を検索してください。）Luaは、メモリ割り当てエラーや型エラーなどのエラーに直面すると、エラーを<em>発生</em>させます。つまり、long jumpを実行します。<em>保護された環境</em>は<code>setjmp</code>を使用してリカバリポイントを設定します。エラーは、最も最近のアクティブなリカバリポイントにジャンプします。</p><p>C関数内では、<a href="#lua_error"><code>lua_error</code></a>を呼び出すことで、エラーを明示的に発生させることができます。</p><p>APIのほとんどの関数は、たとえばメモリ割り当てエラーが原因でエラーを発生させる可能性があります。各関数のドキュメントには、エラーを発生させる可能性があるかどうかが示されています。</p><p>保護された環境の外でエラーが発生した場合、Luaは<em>パニック関数</em>（<a href="#lua_atpanic"><code>lua_atpanic</code></a>を参照）を呼び出し、次に<code>abort</code>を呼び出して、ホストアプリケーションを終了します。パニック関数は、（たとえば、Luaの外の独自のリカバリポイントにlong jumpを実行して）戻らないことで、この終了を回避できます。</p><p>パニック関数は、名前が示すように、最後の手段のメカニズムです。プログラムはそれを避ける必要があります。原則として、C関数がLua状態を持つLuaによって呼び出される場合、すでに保護されているため、そのLua状態に対して必要なことを実行できます。ただし、Cコードが他のLua状態（たとえば、関数へのLua状態引数、レジストリに格納されているLua状態、または<a href="#lua_newthread"><code>lua_newthread</code></a>の結果）を操作する場合、エラーを発生させないAPI呼び出しでのみそれらを使用する必要があります。</p><p>パニック関数は、メッセージハンドラのように実行されます（<a href="#2.3">§2.3</a>を参照）。特に、エラーオブジェクトはスタックの最上部にあります。ただし、スタック領域については保証はありません。スタックに何かをプッシュするには、パニック関数は最初に利用可能なスペースを確認する必要があります（<a href="#4.1.1">§4.1.1</a>を参照）。</p><h3>4.4.1 – <a name="4.4.1">ステータスコード</a></h3>

<p>APIでエラーを報告するいくつかの関数は、さまざまな種類のエラーまたはその他の状態を示すために、次のステータスコードを使用します</p><ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b> エラーなし。</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b> ランタイムエラー。</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b> メモリ割り当てエラー。このようなエラーの場合、Luaはメッセージハンドラを呼び出しません。</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b> メッセージハンドラの実行中にエラーが発生しました。</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b> 事前コンパイル中の構文エラー。</li>

<li><b><a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a>: </b> スレッド（コルーチン）が中断されました。</li>

<li><b><a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>: </b> ファイル関連のエラー。たとえば、ファイルを開いたり読み取ったりできません。</li>

</ul><p>これらの定数は、ヘッダーファイル<code>lua.h</code>で定義されています。</p><h2>4.5 – <a name="4.5">Cでの中断の処理</a></h2>

<p>内部的には、LuaはコルーチンをyieldするためにCの<code>longjmp</code>機能を使用します。そのため、C関数<code>foo</code>がAPI関数を呼び出し、このAPI関数が（直接的またはyieldする別の関数を呼び出すことによって間接的に）yieldする場合、<code>longjmp</code>によってCスタックからフレームが削除されるため、Luaはもはや<code>foo</code>に戻ることができません。</p><p>この種の問題を回避するために、LuaはAPI呼び出しをまたいでyieldしようとするたびにエラーを発生させます。ただし、<a href="#lua_yieldk"><code>lua_yieldk</code></a>、<a href="#lua_callk"><code>lua_callk</code></a>、および<a href="#lua_pcallk"><code>lua_pcallk</code></a>の3つの関数は例外です。これらの関数はすべて、yield後に実行を継続するための<em>継続関数</em>（<code>k</code>という名前のパラメータとして）を受け取ります。</p><p>継続を説明するために、いくつかの用語を設定する必要があります。Luaから呼び出されたC関数を、<em>元の関数</em>と呼びます。この元の関数は、C APIのこれら3つの関数のいずれかを呼び出し、これを<em>呼び出し先関数</em>と呼びます。そして、呼び出し先関数が現在のスレッドをyieldします。これは、呼び出し先関数が<a href="#lua_yieldk"><code>lua_yieldk</code></a>である場合、または呼び出し先関数が<a href="#lua_callk"><code>lua_callk</code></a>または<a href="#lua_pcallk"><code>lua_pcallk</code></a>のいずれかであり、それらによって呼び出された関数がyieldする場合に発生します。</p><p>呼び出し先関数の実行中に実行中のスレッドがyieldすると仮定します。スレッドが再開した後、最終的に呼び出し先関数の実行が完了します。ただし、Cスタック内のフレームはyieldによって破棄されているため、呼び出し先関数は元の関数に戻ることができません。代わりに、Luaは<em>継続関数</em>を呼び出します。この継続関数は、呼び出し先関数の引数として渡されたものです。名前が示すように、継続関数は元の関数のタスクを継続する必要があります。</p><p>例として、次の関数を考えてみましょう。</p><pre>     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* calls Lua */
       ...     /* code 2 */
     }
</pre><p>ここで、<a href="#lua_pcall"><code>lua_pcall</code></a>によって実行されるLuaコードがyieldできるようにしたいとします。まず、ここで示すように関数を書き直すことができます。</p><pre>     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>上記のコードでは、新しい関数<code>k</code>は<em>継続関数</em>（<a href="#lua_KFunction"><code>lua_KFunction</code></a>型）であり、<a href="#lua_pcall"><code>lua_pcall</code></a>を呼び出した後に元の関数が行っていたすべての作業を行う必要があります。次に、<a href="#lua_pcall"><code>lua_pcall</code></a>によって実行されているLuaコードが何らかの方法（エラーまたはyield）で中断された場合に<code>k</code>を呼び出す必要があることをLuaに通知する必要があります。そのため、<a href="#lua_pcall"><code>lua_pcall</code></a>を<a href="#lua_pcallk"><code>lua_pcallk</code></a>に置き換えて、コードをここで示すように書き換えます。</p><pre>     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>継続への外部からの明示的な呼び出しに注意してください。Luaは、エラーが発生した場合やyield後に再開する場合など、必要な場合にのみ継続を呼び出します。呼び出された関数がyieldせずに正常に返った場合、<a href="#lua_pcallk"><code>lua_pcallk</code></a>（および<a href="#lua_callk"><code>lua_callk</code></a>）も正常に返ります。（もちろん、その場合に継続を呼び出す代わりに、元の関数内で同等の作業を直接行うことができます。）</p><p>Luaの状態に加えて、継続関数には他の2つのパラメータがあります。それは呼び出しの最終ステータスと、最初に<a href="#lua_pcallk"><code>lua_pcallk</code></a>に渡されたコンテキスト値（<code>ctx</code>）です。Luaはこのコンテキスト値を使用しません。元の関数から継続関数にこの値を渡すだけです。<a href="#lua_pcallk"><code>lua_pcallk</code></a>の場合、ステータスは<a href="#lua_pcallk"><code>lua_pcallk</code></a>によって返される値と同じですが、yield後に実行されている場合は（<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>ではなく）<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>になります。<a href="#lua_yieldk"><code>lua_yieldk</code></a>および<a href="#lua_callk"><code>lua_callk</code></a>の場合、Luaが継続を呼び出すときのステータスは常に<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>です。（これらの2つの関数では、エラーが発生した場合に継続を呼び出すことはありません。エラーを処理しないためです。）同様に、<a href="#lua_callk"><code>lua_callk</code></a>を使用する場合は、ステータスとして<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>を指定して継続関数を呼び出す必要があります。（<a href="#lua_yieldk"><code>lua_yieldk</code></a>の場合、通常<a href="#lua_yieldk"><code>lua_yieldk</code></a>は返さないため、継続関数を直接呼び出すことにあまり意味はありません。）</p><p>Luaは、継続関数を元の関数であるかのように扱います。継続関数は、元の関数と同じLuaスタックを、呼び出し先関数が返された場合と同じ状態で受け取ります。（たとえば、<a href="#lua_callk"><code>lua_callk</code></a>の後、関数とその引数はスタックから削除され、呼び出しの結果に置き換えられます。）また、同じアップ値も持ちます。それが返すものはすべて、元の関数の戻り値としてLuaによって処理されます。</p><h2>4.6 – <a name="4.6">関数と型</a></h2>

<p>ここでは、C&nbsp;APIのすべての関数と型をアルファベット順にリストします。各関数には、次のようなインジケータがあります: <span class="apii">[-o, +p, <em>x</em>]</span></p><p>最初のフィールド<code>o</code>は、関数がスタックからポップする要素の数です。2番目のフィールド<code>p</code>は、関数がスタックにプッシュする要素の数です。（すべての関数は常に、引数をポップした後で結果をプッシュします。）<code>x|y</code>形式のフィールドは、関数が状況に応じて<code>x</code>または<code>y</code>要素をプッシュ（またはポップ）できることを意味します。疑問符'<code>?</code>'は、引数だけを見て関数がポップ/プッシュする要素の数を知ることができないことを意味します。（たとえば、スタックの内容に依存する場合があります。）3番目のフィールド<code>x</code>は、関数がエラーを発生させる可能性があるかどうかを示します。 '<code>-</code>'は関数がエラーを発生させないことを意味します。 '<code>m</code>'は関数がメモリ不足エラーのみを発生させる可能性があることを意味します。 '<code>v</code>'は、テキストで説明されているエラーを関数が発生させる可能性があることを意味します。 '<code>e</code>'は関数が直接またはメタメソッドを通じて任意のLuaコードを実行できるため、任意のエラーが発生する可能性があることを意味します。</p><hr /><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>許容可能なインデックス<code>idx</code>を、同等の絶対インデックス（つまり、スタックサイズに依存しないインデックス）に変換します。</p><hr /><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>Luaの状態によって使用されるメモリアロケーション関数の型。アロケータ関数は、<code>realloc</code>に似た機能を提供する必要がありますが、まったく同じではありません。その引数は、<a href="#lua_newstate"><code>lua_newstate</code></a>に渡される不透明なポインタである<code>ud</code>、割り当て/再割り当て/解放されるブロックへのポインタである<code>ptr</code>、ブロックの元のサイズまたは割り当てられているものに関するコードである<code>osize</code>、およびブロックの新しいサイズである<code>nsize</code>です。</p><p><code>ptr</code>が<code>NULL</code>でない場合、<code>osize</code>は<code>ptr</code>によって指されるブロックのサイズ、つまり、割り当てまたは再割り当て時に指定されたサイズです。</p><p><code>ptr</code>が<code>NULL</code>の場合、<code>osize</code>はLuaが割り当てているオブジェクトの種類をエンコードします。<code>osize</code>は、Luaがその型の新しいオブジェクトを作成している場合（およびその場合にのみ）、<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>、<a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>、<a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>、<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>、または<a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>のいずれかになります。<code>osize</code>が他の値である場合、Luaは他の何かに対してメモリを割り当てています。</p><p>Luaは、アロケータ関数から次の動作を想定します。</p><p><code>nsize</code>がゼロの場合、アロケータは<code>free</code>のように動作し、<code>NULL</code>を返す必要があります。</p><p><code>nsize</code>がゼロでない場合、アロケータは<code>realloc</code>のように動作する必要があります。特に、アロケータはリクエストを完了できない場合にのみ<code>NULL</code>を返します。</p><p>アロケータ関数の簡単な実装を次に示します。これは、補助ライブラリで<a href="#luaL_newstate"><code>luaL_newstate</code></a>によって使用されます。</p><pre>     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>ISO&nbsp;Cでは、<code>free(NULL)</code>には効果がなく、<code>realloc(NULL,size)</code>は<code>malloc(size)</code>と同等であることが保証されていることに注意してください。</p><hr /><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
</p><pre>void lua_arith (lua_State *L, int op);</pre>

<p>スタックの先頭にある2つの値（または否定の場合には1つ）に対して算術演算またはビット演算を実行します。スタックの先頭の値が2番目のオペランドになります。これらの値をポップし、演算の結果をプッシュします。この関数は、対応するLua演算子のセマンティクスに従います（つまり、メタメソッドを呼び出す場合があります）。</p><p><code>op</code>の値は、次の定数のいずれかである必要があります。</p><ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 加算（<code>+</code>）を実行</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 減算（<code>-</code>）を実行</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 乗算（<code>*</code>）を実行</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 浮動小数点除算（<code>/</code>）を実行</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> 床除算（<code>//</code>）を実行</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> モジュロ（<code>%</code>）を実行</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 指数演算（<code>^</code>）を実行</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 数学的な否定（単項<code>-</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> ビット単位のNOT（<code>~</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> ビット単位のAND（<code>&amp;</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> ビット単位のOR（<code>|</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> ビット単位の排他的OR（<code>~</code>）を実行</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> 左シフト（<code>&lt;&lt;</code>）を実行</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> 右シフト（<code>&gt;&gt;</code>）を実行</li>

</ul>




<hr /><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>新しいパニック関数を設定し、古い関数を返します（<a href="#4.4">§4.4</a>を参照）。</p><hr /><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
</p><pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>関数を呼び出します。通常のLua呼び出しと同様に、<code>lua_call</code>は<code>__call</code>メタメソッドを尊重します。したがって、ここで「関数」という言葉は、呼び出し可能な値を意味します。</p><p>呼び出しを行うには、次のプロトコルを使用する必要があります。最初に、呼び出す関数をスタックにプッシュします。次に、呼び出しの引数を直接の順序でプッシュします。つまり、最初の引数が最初にプッシュされます。最後に<a href="#lua_call"><code>lua_call</code></a>を呼び出します。<code>nargs</code>はスタックにプッシュした引数の数です。関数が戻ると、すべての引数と関数値がポップされ、呼び出し結果がスタックにプッシュされます。結果の数は<code>nresults</code>に調整されます。ただし、<code>nresults</code>が<a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>の場合を除きます。この場合、関数からのすべての結果がプッシュされます。Luaは、返された値がスタックスペースに収まるようにしますが、スタック内の追加のスペースを保証しません。関数の結果は直接の順序で（最初の結果が最初にプッシュされる）スタックにプッシュされるため、呼び出し後、最後の結果がスタックの先頭になります。</p><p>関数の呼び出しおよび実行中のエラーはすべて、上位に（<code>longjmp</code>を使用して）伝播されます。</p><p>次の例は、ホストプログラムがこのLuaコードと同等の処理をどのように実行できるかを示しています。</p><pre>     a = f("how", t.x, 14)
</pre><p>以下はCでの記述です。</p><pre>     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
</pre><p>上記のコードは<em>バランスが取れている</em>ことに注意してください。最後に、スタックは元の構成に戻ります。これは、優れたプログラミングの習慣と見なされます。</p><hr /><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
</p><pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>この関数は、<a href="#lua_call"><code>lua_call</code></a>とまったく同じように動作しますが、呼び出された関数がyieldできるようにします（<a href="#4.5">§4.5</a>を参照）。</p><hr /><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>C&nbsp;関数の型。</p><p>Luaと正しく通信するために、C関数は次のプロトコルに従う必要があります。このプロトコルは、パラメータと結果がどのように渡されるかを定義します。C関数は、Luaから引数をスタックに直接順に受け取ります（最初の引数が最初にプッシュされます）。したがって、関数が開始すると、<code>lua_gettop(L)</code>は関数が受け取った引数の数を返します。最初の引数（存在する場合）はインデックス1にあり、最後の引数はインデックス<code>lua_gettop(L)</code>にあります。Luaに値を返すには、C関数はそれらをスタックに直接順にプッシュし（最初の結果が最初にプッシュされます）、Cで結果の数を返します。結果の下のスタックにある他の値は、Luaによって適切に破棄されます。Lua関数と同様に、Luaによって呼び出されるC関数も多くの結果を返すことができます。</p><p>例として、次の関数は可変数の数値引数を受け取り、それらの平均と合計を返します。</p><pre>     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* number of arguments */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }
</pre>




<hr /><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>スタックに少なくとも<code>n</code>個の追加要素のためのスペースがあること、つまり、最大<code>n</code>個の値を安全にプッシュできることを保証します。スタックが固定の最大サイズ（通常、数千個以上の要素）を超える場合、または追加のスペース用のメモリを割り当てることができないために、要求を満たすことができない場合は、falseを返します。この関数はスタックを縮小することはありません。スタックにすでに余分な要素のためのスペースがある場合、変更されずに残ります。</p><hr /><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_close (lua_State *L);</pre>

<p>メインスレッドでアクティブなすべてのクローズ対象変数を閉じ、指定されたLua状態のすべてのオブジェクトを解放し（対応するガベージコレクションメタメソッド（存在する場合）を呼び出し）、この状態によって使用されるすべての動的メモリを解放します。</p><p>一部のプラットフォームでは、ホストプログラムが終了するとすべてのリソースが自然に解放されるため、この関数を呼び出す必要がない場合があります。一方、デーモンやWebサーバーなど、複数の状態を作成する長時間実行されるプログラムは、不要になった状態をできるだけ早く閉じる必要があるでしょう。</p><hr /><h3><a name="lua_closeslot"><code>lua_closeslot</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void lua_closeslot (lua_State *L, int index);</pre>

<p>指定されたインデックスにあるクローズ対象のスロットを閉じ、その値を<b>nil</b>に設定します。インデックスは、まだアクティブ（つまり、まだ閉じられていない）である、以前にクローズ対象としてマークされた最後のインデックス（<a href="#lua_toclose"><code>lua_toclose</code></a>を参照）である必要があります。</p><p>この関数を介して呼び出された場合、<code>__close</code>メタメソッドはyieldできません。</p><p>（この関数はリリース5.4.3で導入されました。）</p><hr /><h3><a name="lua_closethread"><code>lua_closethread</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int lua_closethread (lua_State *L, lua_State *from);</pre>

<p>スレッドをリセットし、そのコールスタックをクリーンアップし、保留中のすべてのクローズ対象変数を閉じます。ステータスコードを返します。スレッドにエラーがない場合は<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>（スレッドを停止させた元のエラー、またはクローズメソッドのエラー）、それ以外の場合はエラー状態です。エラーの場合、スタックのトップにエラーオブジェクトを残します。</p><p>パラメータ<code>from</code>は、<code>L</code>をリセットしているコルーチンを表します。そのようなコルーチンがない場合、このパラメータは<code>NULL</code>にすることができます。</p><p>（この関数はリリース5.4.6で導入されました。）</p><hr /><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>2つのLua値を比較します。インデックス<code>index1</code>の値が、対応するLua演算子のセマンティクスに従って（つまり、メタメソッドを呼び出す可能性がある）、インデックス<code>index2</code>の値と比較した場合に<code>op</code>を満たす場合は1を返します。それ以外の場合は0を返します。また、いずれかのインデックスが無効な場合も0を返します。</p><p><code>op</code>の値は、次の定数のいずれかである必要があります。</p><ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b>等価性（<code>==</code>）を比較します</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b>より小さい（<code>&lt;</code>）を比較します</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b>以下（<code>&lt;=</code>）を比較します</li>

</ul>




<hr /><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
</p><pre>void lua_concat (lua_State *L, int n);</pre>

<p>スタックのトップにある<code>n</code>個の値を連結し、それらをポップし、結果をトップに残します。<code>n</code>が1の場合、結果はスタック上の単一の値です（つまり、関数は何もしません）。<code>n</code>が0の場合、結果は空の文字列です。連結はLuaの通常のセマンティクスに従って実行されます（<a href="#3.4.6">§3.4.6</a>を参照）。</p><hr /><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>インデックス<code>fromidx</code>にある要素を有効なインデックス<code>toidx</code>にコピーし、その位置の値を置き換えます。他の位置の値は影響を受けません。</p><hr /><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>新しい空のテーブルを作成し、スタックにプッシュします。パラメータ<code>narr</code>は、テーブルがシーケンスとして持つ要素数のヒントです。パラメータ<code>nrec</code>は、テーブルが持つ他の要素数のヒントです。Luaは、これらのヒントを使用して、新しいテーブルのメモリを事前に割り当てることができます。この事前割り当ては、テーブルにいくつの要素があるかを事前に知っている場合にパフォーマンスを向上させるのに役立つ場合があります。それ以外の場合は、関数<a href="#lua_newtable"><code>lua_newtable</code></a>を使用できます。</p><hr /><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>関数をバイナリチャンクとしてダンプします。スタックのトップにあるLua関数を受け取り、再度ロードした場合、ダンプされたものと同等の関数になるバイナリチャンクを生成します。チャンクの一部を生成するときに、<a href="#lua_dump"><code>lua_dump</code></a>は、指定された<code>data</code>を使用してそれらを書き込むために関数<code>writer</code>（<a href="#lua_Writer"><code>lua_Writer</code></a>を参照）を呼び出します。</p><p><code>strip</code>がtrueの場合、バイナリ表現には、スペースを節約するために関数のすべてのデバッグ情報が含まれない場合があります。</p><p>返される値は、ライターへの最後の呼び出しによって返されるエラーコードです。0はエラーがないことを意味します。</p><p>この関数はスタックからLua関数をポップしません。</p><hr /><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
</p><pre>int lua_error (lua_State *L);</pre>

<p>スタックのトップにある値をエラーオブジェクトとして使用して、Luaエラーを発生させます。この関数はロングジャンプを実行するため、決して戻りません（<a href="#luaL_error"><code>luaL_error</code></a>を参照）。</p><hr /><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gc (lua_State *L, int what, ...);</pre>

<p>ガベージコレクタを制御します。</p><p>この関数は、パラメータ<code>what</code>の値に応じて、いくつかのタスクを実行します。追加の引数を必要とするオプションの場合、オプションの後にそれらがリストされます。</p><ul>

<li><b><code>LUA_GCCOLLECT</code>: </b>完全なガベージコレクションサイクルを実行します。</li>

<li><b><code>LUA_GCSTOP</code>: </b>ガベージコレクタを停止します。</li>

<li><b><code>LUA_GCRESTART</code>: </b>ガベージコレクタを再起動します。</li>

<li><b><code>LUA_GCCOUNT</code>: </b>Luaで使用されている現在のメモリ量（Kバイト単位）を返します。</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>Luaで使用されている現在のメモリ量（バイト単位）を1024で割った余りを返します。</li>

<li><b><code>LUA_GCSTEP</code> <code>(int stepsize)</code>: </b><code>stepsize</code> Kバイトの割り当てに対応する、ガベージコレクションの増分ステップを実行します。</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>コレクターが実行中かどうか（つまり、停止していない）を示すブール値を返します。</li>

<li><b><code>LUA_GCINC</code> (int pause, int stepmul, stepsize): </b>指定されたパラメータを使用して、コレクターを増分モードに変更します（<a href="#2.5.1">§2.5.1</a>を参照）。以前のモード（<code>LUA_GCGEN</code>または<code>LUA_GCINC</code>）を返します。</li>

<li><b><code>LUA_GCGEN</code> (int minormul, int majormul): </b>指定されたパラメータを使用して、コレクターを世代モードに変更します（<a href="#2.5.2">§2.5.2</a>を参照）。以前のモード（<code>LUA_GCGEN</code>または<code>LUA_GCINC</code>）を返します。</li>

</ul><p>これらのオプションの詳細については、<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>を参照してください。</p><p>この関数はファイナライザーによって呼び出されるべきではありません。</p><hr /><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>指定された状態のメモリ割り当て関数を返します。<code>ud</code>が<code>NULL</code>でない場合、Luaはメモリ割り当て関数が設定されたときに与えられた不透明なポインタを<code>*ud</code>に格納します。</p><hr /><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>スタックに値<code>t[k]</code>をプッシュします。ここで、<code>t</code>は指定されたインデックスにある値です。Luaと同様に、この関数は「index」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a>を参照）。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_getextraspace (lua_State *L);</pre>

<p>指定されたLua状態に関連付けられた生のメモリ領域へのポインタを返します。アプリケーションはこの領域を任意の目的で使用できます。Luaはそれを使用しません。</p><p>各新しいスレッドには、メインスレッドの領域のコピーで初期化されたこの領域があります。</p><p>デフォルトでは、この領域はvoidへのポインタのサイズですが、この領域の異なるサイズでLuaを再コンパイルできます。（<code>luaconf.h</code>の<code>LUA_EXTRASPACE</code>を参照）。</p><hr /><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>グローバル<code>name</code>の値をスタックにプッシュします。その値の型を返します。</p><hr /><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>スタックに値<code>t[i]</code>をプッシュします。ここで、<code>t</code>は指定されたインデックスにある値です。Luaと同様に、この関数は「index」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a>を参照）。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>指定されたインデックスの値にメタテーブルがある場合、関数はそのメタテーブルをスタックにプッシュし、1を返します。それ以外の場合、関数は0を返し、スタックには何もプッシュしません。</p><hr /><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
</p><pre>int lua_gettable (lua_State *L, int index);</pre>

<p>スタックに値<code>t[k]</code>をプッシュします。ここで、<code>t</code>は指定されたインデックスにある値であり、<code>k</code>はスタックのトップにある値です。</p><p>この関数は、スタックからキーをポップし、その場所に結果の値をプッシュします。Luaと同様に、この関数は「index」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a>を参照）。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gettop (lua_State *L);</pre>

<p>スタックのトップ要素のインデックスを返します。インデックスは1から始まるため、この結果はスタック内の要素数と同じです。特に、0は空のスタックを意味します。</p><hr /><h3><a name="lua_getiuservalue"><code>lua_getiuservalue</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_getiuservalue (lua_State *L, int index, int n);</pre>

<p>スタックに、指定されたインデックスにあるフルユーザーデータに関連付けられた<code>n</code>番目のユーザー値をプッシュし、プッシュされた値の型を返します。</p><p>ユーザーデータにその値がない場合、<b>nil</b>をプッシュし、<a href="#pdf-LUA_TNONE"><code>LUA_TNONE</code></a>を返します。</p><hr /><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, –]</span>
</p><pre>void lua_insert (lua_State *L, int index);</pre>

<p>トップ要素を指定された有効なインデックスに移動し、このインデックスの上にある要素を上にシフトしてスペースを開きます。擬似インデックスは実際のスタック位置ではないため、この関数を擬似インデックスで呼び出すことはできません。</p><hr /><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>Luaの整数の型。</p><p>デフォルトでは、この型は<code>long long</code>（通常は64ビットの2の補数整数）ですが、<code>long</code>または<code>int</code>（通常は32ビットの2の補数整数）に変更できます。（<code>luaconf.h</code>の<code>LUA_INT_TYPE</code>を参照）。</p><p>Luaは、この型に収まる最小値と最大値を使用して、定数<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a>と<a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>も定義します。</p><hr /><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がブール値の場合は1を返し、それ以外の場合は0を返します。</p><hr /><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がC関数の場合は1を返し、それ以外の場合は0を返します。</p><hr /><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が関数（CまたはLua）の場合は1を返し、それ以外の場合は0を返します。</p><hr /><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が整数（つまり、値が数値であり、整数として表現されている）であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がライトユーザーデータであれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnil (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が <b>nil</b> であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnone (lua_State *L, int index);</pre>

<p>指定されたインデックスが無効であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>指定されたインデックスが無効であるか、そのインデックスの値が <b>nil</b> であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が数値または数値に変換可能な文字列であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isstring (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が文字列または数値（常に文字列に変換可能）であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_istable (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がテーブルであれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isthread (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がスレッドであれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がユーザーデータ（フルまたはライト）であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isyieldable (lua_State *L);</pre>

<p>指定されたコルーチンが yield できる場合は 1 を返し、それ以外の場合は 0 を返します。</p><hr /><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>継続関数コンテキストの型。数値型でなければなりません。この型は、<code>intptr_t</code> が利用可能な場合は <code>intptr_t</code> として定義され、ポインタも格納できるようにします。それ以外の場合は、<code>ptrdiff_t</code> として定義されます。</p><hr /><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>継続関数の型（<a href="#4.5">§4.5</a> を参照）。</p><hr /><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>void lua_len (lua_State *L, int index);</pre>

<p>指定されたインデックスの値の長さを返します。Lua の '<code>#</code>' 演算子（<a href="#3.4.7">§3.4.7</a> を参照）と同等であり、「length」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a> を参照）。結果はスタックにプッシュされます。</p><hr /><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>Lua のチャンクを実行せずにロードします。エラーがない場合、<code>lua_load</code> はコンパイルされたチャンクを Lua 関数としてスタックの一番上にプッシュします。それ以外の場合は、エラーメッセージをプッシュします。</p><p><code>lua_load</code> 関数は、チャンクを読み込むためにユーザーが提供する <code>reader</code> 関数を使用します（<a href="#lua_Reader"><code>lua_Reader</code></a> を参照）。<code>data</code> 引数は、reader 関数に渡される不透明な値です。</p><p><code>chunkname</code> 引数は、エラーメッセージやデバッグ情報で使用されるチャンクの名前を指定します（<a href="#4.7">§4.7</a> を参照）。</p><p>
<code>lua_load</code> は、チャンクがテキスト形式かバイナリ形式かを自動的に検出し、それに応じてロードします（プログラム <code>luac</code> を参照）。文字列 <code>mode</code> は、関数 <a href="#pdf-load"><code>load</code></a> と同様に動作しますが、<code>NULL</code> 値は文字列 "<code>bt</code>" と同等であるという追加があります。</p><p>
<code>lua_load</code> は内部でスタックを使用するため、reader 関数は常に、戻る際にスタックを変更しないようにする必要があります。</p><p>
<code>lua_load</code> は <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、<a href="#pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>、または <a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a> を返すことができます。この関数は、読み取り関数によって発生したエラーに対応する他の値を返す場合もあります（<a href="#4.4.1">§4.4.1</a> を参照）。</p><p>結果の関数にアップバリューがある場合、その最初のアップバリューは、レジストリのインデックス <code>LUA_RIDX_GLOBALS</code> に格納されているグローバル環境の値に設定されます（<a href="#4.3">§4.3</a> を参照）。メインチャンクをロードする場合、このアップバリューは <code>_ENV</code> 変数になります（<a href="#2.2">§2.2</a> を参照）。他のアップバリューは <b>nil</b> で初期化されます。</p><hr /><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>新しい独立した状態を作成し、そのメスレッドを返します。状態を作成できない場合（メモリ不足が原因）は <code>NULL</code> を返します。引数 <code>f</code> はアロケーター関数です。Lua は、この状態のすべてのメモリ割り当てをこの関数を介して行います（<a href="#lua_Alloc"><code>lua_Alloc</code></a> を参照）。2 番目の引数 <code>ud</code> は、Lua がすべての呼び出しでアロケーターに渡す不透明なポインタです。</p><hr /><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void lua_newtable (lua_State *L);</pre>

<p>新しい空のテーブルを作成し、それをスタックにプッシュします。これは <code>lua_createtable(L, 0, 0)</code> と同等です。</p><hr /><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>新しいスレッドを作成し、スタックにプッシュし、この新しいスレッドを表す <a href="#lua_State"><code>lua_State</code></a> へのポインタを返します。この関数によって返される新しいスレッドは、元のスレッドとグローバル環境を共有しますが、独立した実行スタックを持ちます。</p><p>スレッドは、他の Lua オブジェクトと同様に、ガベージコレクションの対象となります。</p><hr /><h3><a name="lua_newuserdatauv"><code>lua_newuserdatauv</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue);</pre>

<p>この関数は、新しいフルユーザーデータをスタックに作成してプッシュします。このユーザーデータには、<code>nuvalue</code> 個の関連する Lua 値（<code>ユーザー値</code> と呼ばれます）と、<code>size</code> バイトの関連する生のメモリブロックがあります。（ユーザー値は、関数 <a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a> および <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a> で設定および読み取ることができます。）</p><p>この関数は、メモリブロックのアドレスを返します。Lua は、対応するユーザーデータが存続している限り、このアドレスが有効であることを保証します（<a href="#2.5">§2.5</a> を参照）。さらに、ユーザーデータがファイナライズのためにマークされている場合（<a href="#2.5.3">§2.5.3</a> を参照）、そのアドレスは少なくともファイナライザーの呼び出しまで有効です。</p><hr /><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>v</em>]</span>
</p><pre>int lua_next (lua_State *L, int index);</pre>

<p>スタックからキーをポップし、指定されたインデックスのテーブルからキーと値のペア（指定されたキーの「次の」ペア）をプッシュします。テーブルに要素がなくなると、<a href="#lua_next"><code>lua_next</code></a> は 0 を返し、何もプッシュしません。</p><p>一般的なテーブルトラバーサルは次のようになります。</p><pre>     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }
</pre>

<p>テーブルのトラバーサル中は、キーが実際に文字列であることがわかっている場合を除き、キーに対して直接 <a href="#lua_tolstring"><code>lua_tolstring</code></a> を呼び出すことは避けてください。<a href="#lua_tolstring"><code>lua_tolstring</code></a> は指定されたインデックスの値を変更する可能性があることに注意してください。これは、<a href="#lua_next"><code>lua_next</code></a> の次の呼び出しを混乱させます。</p><p>指定されたキーが <b>nil</b> でもない場合、テーブルに存在しない場合は、この関数がエラーを発生させる可能性があります。テーブルのトラバーサル中にテーブルを変更する場合の注意点については、関数 <a href="#pdf-next"><code>next</code></a> を参照してください。</p><hr /><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>Lua の浮動小数点数の型。</p><p>デフォルトでは、この型は double ですが、単精度 float または long double に変更できます。（<code>luaconf.h</code> の <code>LUA_FLOAT_TYPE</code> を参照。）</p><hr /><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>Lua の浮動小数点数を Lua の整数に変換しようとします。浮動小数点数 <code>n</code> は整数値でなければなりません。その値が Lua の整数の範囲内にある場合は、整数に変換され、<code>*p</code> に代入されます。このマクロは、変換が成功したかどうかを示すブール値を返します。（この範囲テストは、このマクロがないと正しく行うのが難しい場合があることに注意してください。）</p><p>このマクロは、引数を複数回評価する場合があります。</p><hr /><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>関数（または呼び出し可能なオブジェクト）を保護モードで呼び出します。</p><p><code>nargs</code> と <code>nresults</code> の両方とも、<a href="#lua_call"><code>lua_call</code></a> と同じ意味を持ちます。呼び出し中にエラーがない場合、<a href="#lua_pcall"><code>lua_pcall</code></a> は <a href="#lua_call"><code>lua_call</code></a> とまったく同じように動作します。ただし、エラーが発生した場合、<a href="#lua_pcall"><code>lua_pcall</code></a> はそれをキャッチし、単一の値をスタックにプッシュし（エラーオブジェクト）、エラーコードを返します。<a href="#lua_call"><code>lua_call</code></a> と同様に、<a href="#lua_pcall"><code>lua_pcall</code></a> は常にスタックから関数とその引数を削除します。</p><p><code>msgh</code> が 0 の場合、スタックに返されるエラーオブジェクトは元のエラーオブジェクトとまったく同じです。それ以外の場合、<code>msgh</code> は<em>メッセージハンドラー</em>のスタックインデックスです。（このインデックスは疑似インデックスにすることはできません。）ランタイムエラーが発生した場合、このハンドラーはエラーオブジェクトとともに呼び出され、その戻り値は <a href="#lua_pcall"><code>lua_pcall</code></a> によってスタックに返されるオブジェクトになります。</p><p>通常、メッセージハンドラーは、スタックトレースバックなど、エラーオブジェクトに詳細なデバッグ情報を追加するために使用されます。このような情報は、<a href="#lua_pcall"><code>lua_pcall</code></a> の戻り後には収集できません。スタックが巻き戻されているためです。</p><p><a href="#lua_pcall"><code>lua_pcall</code></a> 関数は、次のステータスコードのいずれかを返します。<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、<a href="#pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>、<a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>、または <a href="#pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>。</p><hr /><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>この関数は、呼び出された関数が yield できることを除いて（<a href="#4.5">§4.5</a> を参照）、<a href="#lua_pcall"><code>lua_pcall</code></a> とまったく同じように動作します。</p><hr /><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>e</em>]</span>
</p><pre>void lua_pop (lua_State *L, int n);</pre>

<p>スタックから <code>n</code> 個の要素をポップします。これは、<a href="#lua_settop"><code>lua_settop</code></a> に対するマクロとして実装されています。</p><hr /><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>値 <code>b</code> を持つブール値をスタックにプッシュします。</p><hr /><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
</p><pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>新しい C&nbsp;クロージャをスタックにプッシュします。この関数は C&nbsp;関数へのポインタを受け取り、対応する C&nbsp;関数を呼び出す、呼び出し時に <code>function</code> 型の Lua 値をスタックにプッシュします。パラメーター <code>n</code> は、この関数が持つアップバリューの数を指定します（<a href="#4.2">§4.2</a> を参照）。</p><p>Lua から呼び出し可能なすべての関数は、パラメーターを受け取り、結果を返すための正しいプロトコルに従う必要があります（<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照）。</p><p>C&nbsp;関数が作成されるとき、アップバリューと呼ばれるいくつかの値をそれに関連付けることができます。これらのアップバリューは、関数が呼び出されるたびにアクセスできます。この関連付けは C&nbsp;クロージャと呼ばれます（<a href="#4.2">§4.2</a> を参照）。C&nbsp;クロージャを作成するには、最初にアップバリューの初期値をスタックにプッシュする必要があります。（複数のアップバリューがある場合、最初の値が最初にプッシュされます。）次に、<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> を呼び出して、C&nbsp;関数をスタックに作成してプッシュします。引数 <code>n</code> は、関数に関連付けられる値の数を指定します。<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> は、これらの値もスタックからポップします。</p><p><code>n</code> の最大値は 255 です。</p><p><code>n</code> が 0 の場合、この関数は<em>ライト C&nbsp;関数</em>を作成します。これは C&nbsp;関数へのポインタにすぎません。その場合、メモリエラーが発生することはありません。</p><hr /><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>C&nbsp;関数をスタックにプッシュします。この関数は、アップバリューがない <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> と同等です。</p><hr /><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>書式設定された文字列をスタックにプッシュし、この文字列へのポインタを返します（<a href="#4.1.3">§4.1.3</a> を参照）。これは ISO&nbsp;C 関数 <code>sprintf</code> に似ていますが、2 つの重要な違いがあります。まず、結果のスペースを割り当てる必要はありません。結果は Lua 文字列であり、Lua がメモリ割り当て（およびガベージコレクションによる割り当て解除）を処理します。2 番目に、変換指定子はかなり制限されています。フラグ、幅、または精度はありません。変換指定子は '<code>%%</code>' (文字 '<code>%</code>' を挿入)、'<code>%s</code>' (ヌル終端文字列を挿入、サイズ制限なし)、'<code>%f</code>' (<a href="#lua_Number"><code>lua_Number</code></a> を挿入)、'<code>%I</code>' (<a href="#lua_Integer"><code>lua_Integer</code></a> を挿入)、'<code>%p</code>' (ポインタを挿入)、'<code>%d</code>' (<code>int</code> を挿入)、'<code>%c</code>' (1 バイト文字として <code>int</code> を挿入)、および '<code>%U</code>' (UTF-8 バイトシーケンスとして <code>long int</code> を挿入) のみです。</p><p>この関数は、メモリオーバーフローまたは無効な変換指定子によるエラーを発生させる場合があります。</p><hr /><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>グローバル環境をスタックにプッシュします。</p><hr /><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>値 <code>n</code> を持つ整数をスタックにプッシュします。</p><hr /><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>ライトユーザーデータをスタックにプッシュします。</p><p>ユーザーデータは Lua で C&nbsp;値を表します。<em>ライトユーザーデータ</em>はポインタ（<code>void*</code>）を表します。これは値（数値のような）であり、作成されず、個別のメタテーブルを持たず、収集されません（作成されなかったため）。ライトユーザーデータは、同じ C&nbsp;アドレスを持つ「任意」のライトユーザーデータと等しくなります。</p><hr /><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>このマクロは <a href="#lua_pushstring"><code>lua_pushstring</code></a> と同等ですが、<code>s</code> がリテラル文字列の場合にのみ使用する必要があります。（Lua はこのケースを最適化する場合があります。）</p><hr /><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>サイズ <code>len</code> の <code>s</code> が指す文字列をスタックにプッシュします。Lua は指定された文字列の内部コピーを作成または再利用するため、関数が戻った直後に <code>s</code> のメモリを解放または再利用できます。文字列には、埋め込みゼロを含む任意のバイナリデータを含めることができます。</p><p>文字列の内部コピーへのポインタを返します（<a href="#4.1.3">§4.1.3</a> を参照）。</p><hr /><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnil (lua_State *L);</pre>

<p>スタックにnil値をプッシュします。</p><hr /><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>スタックに値が<code>n</code>であるfloat値をプッシュします。</p><hr /><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p><code>s</code>が指すゼロ終端文字列をスタックにプッシュします。Luaは与えられた文字列の内部コピーを作成または再利用するため、関数が戻った直後に<code>s</code>のメモリを解放または再利用できます。</p><p>文字列の内部コピーへのポインタを返します（<a href="#4.1.3">§4.1.3</a> を参照）。</p><p><code>s</code>が<code>NULL</code>の場合、<b>nil</b>をプッシュして<code>NULL</code>を返します。</p><hr /><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_pushthread (lua_State *L);</pre>

<p><code>L</code>で表されるスレッドをスタックにプッシュします。このスレッドがそのステートのメインスレッドである場合は1を返します。</p><hr /><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>与えられたインデックスにある要素のコピーをスタックにプッシュします。</p><hr /><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p><a href="#lua_pushfstring"><code>lua_pushfstring</code></a>と同等ですが、可変個数の引数の代わりに<code>va_list</code>を受け取ります。</p><hr /><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>インデックス<code>index1</code>と<code>index2</code>にある2つの値がプリミティブに等しい（つまり、<code>__eq</code>メタメソッドを呼び出さずに等しい）場合は1を返します。それ以外の場合は0を返します。いずれかのインデックスが無効な場合も0を返します。</p><hr /><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, –]</span>
</p><pre>int lua_rawget (lua_State *L, int index);</pre>

<p><a href="#lua_gettable"><code>lua_gettable</code></a>に似ていますが、生のアクセス（つまり、メタメソッドなし）を行います。<code>index</code>の値はテーブルでなければなりません。</p><hr /><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>スタックに値<code>t[n]</code>をプッシュします。ここで、<code>t</code>は与えられたインデックスにあるテーブルです。アクセスは生であり、<code>__index</code>メタ値を使用しません。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>スタックに値<code>t[k]</code>をプッシュします。ここで、<code>t</code>は与えられたインデックスにあるテーブルであり、<code>k</code>はライトユーザーデータとして表現されたポインタ<code>p</code>です。アクセスは生であり、つまり<code>__index</code>メタ値を使用しません。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Unsigned lua_rawlen (lua_State *L, int index);</pre>

<p>与えられたインデックスの値の生の「長さ」を返します。文字列の場合は文字列の長さ、テーブルの場合はメタメソッドなしの長さ演算子（'<code>#</code>'）の結果、ユーザーデータの場合はユーザーデータに割り当てられたメモリブロックのサイズです。その他の値の場合、この呼び出しは0を返します。</p><hr /><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
</p><pre>void lua_rawset (lua_State *L, int index);</pre>

<p><a href="#lua_settable"><code>lua_settable</code></a>に似ていますが、生の代入（つまり、メタメソッドなし）を行います。<code>index</code>の値はテーブルでなければなりません。</p><hr /><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p><code>t[i] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスにあるテーブルであり、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。代入は生であり、つまり<code>__newindex</code>メタ値を使用しません。</p><hr /><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p><code>t[p] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスにあるテーブル、<code>p</code>はライトユーザーデータとしてエンコードされ、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。代入は生であり、つまり<code>__newindex</code>メタ値を使用しません。</p><hr /><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p><a href="#lua_load"><code>lua_load</code></a>で使用されるリーダ関数。 <a href="#lua_load"><code>lua_load</code></a>がチャンクの別の部分を必要とするたびに、リーダを呼び出し、その<code>data</code>パラメータを渡します。リーダは、チャンクの新しい部分を持つメモリブロックへのポインタを返し、<code>size</code>をブロックサイズに設定する必要があります。ブロックは、リーダ関数が再度呼び出されるまで存在する必要があります。チャンクの終わりを知らせるために、リーダは<code>NULL</code>を返すか、<code>size</code>をゼロに設定する必要があります。リーダ関数は、ゼロより大きい任意のサイズのピースを返すことができます。</p><hr /><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>グローバル変数<code>name</code>の新しい値としてC関数<code>f</code>を設定します。これはマクロとして定義されています</p><pre>     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr /><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_remove (lua_State *L, int index);</pre>

<p>指定された有効なインデックスにある要素を削除し、このインデックスより上の要素を下に移動してギャップを埋めます。疑似インデックスは実際のスタック位置ではないため、この関数を疑似インデックスで呼び出すことはできません。</p><hr /><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_replace (lua_State *L, int index);</pre>

<p>スタックの一番上の要素を与えられた有効なインデックスに移動し、他の要素をシフトすることなく（したがって、指定されたインデックスの値を置き換え）、一番上の要素をポップします。</p><hr /><h3><a name="lua_resetthread"><code>lua_resetthread</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int lua_resetthread (lua_State *L);</pre>

<p>この関数は非推奨です。<code>from</code>が<code>NULL</code>である<a href="#lua_closethread"><code>lua_closethread</code></a>と同等です。</p><hr /><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>int lua_resume (lua_State *L, lua_State *from, int nargs,
                          int *nresults);</pre>

<p>与えられたスレッド<code>L</code>でコルーチンを開始および再開します。</p><p>コルーチンを開始するには、メイン関数と任意の引数をスレッドの空のスタックにプッシュします。次に、<a href="#lua_resume"><code>lua_resume</code></a>を呼び出し、<code>nargs</code>を引数の数とします。この呼び出しは、コルーチンが中断するか実行を終了したときに戻ります。戻ると、<code>*nresults</code>が更新され、スタックの一番上には<a href="#lua_yield"><code>lua_yield</code></a>に渡された値、または本体関数によって返された値である<code>*nresults</code>値が含まれています。コルーチンが中断した場合、<a href="#lua_resume"><code>lua_resume</code></a>は<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>を返します。コルーチンがエラーなしで実行を終了した場合は<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>を返し、エラーの場合はエラーコードを返します（<a href="#4.4.1">§4.4.1</a>を参照）。エラーの場合、エラーオブジェクトはスタックの一番上にあります。</p><p>コルーチンを再開するには、スタックから<code>*nresults</code>のyieldされた値を削除し、<code>yield</code>の結果として渡される値をプッシュしてから、<a href="#lua_resume"><code>lua_resume</code></a>を呼び出します。</p><p>パラメータ<code>from</code>は<code>L</code>を再開するコルーチンを表します。そのようなコルーチンがない場合、このパラメータは<code>NULL</code>にすることができます。</p><hr /><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>有効なインデックス<code>idx</code>とスタックの一番上の要素の間でスタック要素を回転させます。要素は、正の<code>n</code>の場合は一番上の方向に<code>n</code>の位置だけ、または負の<code>n</code>の場合は一番下の方向に<code>-n</code>の位置だけ回転します。<code>n</code>の絶対値は、回転されるスライスのサイズを超えてはなりません。疑似インデックスは実際のスタック位置ではないため、この関数を疑似インデックスで呼び出すことはできません。</p><hr /><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>与えられたステートのアロケータ関数を、ユーザーデータ<code>ud</code>を使用して<code>f</code>に変更します。</p><hr /><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p><code>t[k] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスの値であり、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。 Luaの場合と同様に、この関数は「newindex」イベントのメタメソッドをトリガーする可能性があります（<a href="#2.4">§2.4</a>を参照）。</p><hr /><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>スタックから値をポップし、グローバル変数<code>name</code>の新しい値として設定します。</p><hr /><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p><code>t[n] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスの値であり、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。 Luaの場合と同様に、この関数は「newindex」イベントのメタメソッドをトリガーする可能性があります（<a href="#2.4">§2.4</a>を参照）。</p><hr /><h3><a name="lua_setiuservalue"><code>lua_setiuservalue</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setiuservalue (lua_State *L, int index, int n);</pre>

<p>スタックから値をポップし、与えられたインデックスにあるフルユーザーデータに関連付けられた新しい<code>n</code>番目のユーザー値として設定します。ユーザーデータにその値がない場合は0を返します。</p><hr /><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>スタックからテーブルまたは<b>nil</b>をポップし、その値を、指定されたインデックスの値の新しいメタテーブルとして設定します（<b>nil</b>はメタテーブルがないことを意味します）。</p><p>（歴史的な理由から、この関数は<code>int</code>を返しますが、現在は常に1です。）</p><hr /><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
</p><pre>void lua_settable (lua_State *L, int index);</pre>

<p><code>t[k] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスの値、<code>v</code>はスタックの一番上の値、<code>k</code>は一番上の値のすぐ下の値です。</p><p>この関数は、キーと値の両方をスタックからポップします。 Luaの場合と同様に、この関数は「newindex」イベントのメタメソッドをトリガーする可能性があります（<a href="#2.4">§2.4</a>を参照）。</p><hr /><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
</p><pre>void lua_settop (lua_State *L, int index);</pre>

<p>任意のインデックス、または0を受け入れ、スタックの一番上をこのインデックスに設定します。新しい一番上が古いものよりも大きい場合、新しい要素は<b>nil</b>で埋められます。<code>index</code>が0の場合、すべてのスタック要素が削除されます。</p><p>この関数は、スタックから閉じられるとマークされたインデックスを削除するときに、任意のコードを実行できます。</p><hr /><h3><a name="lua_setwarnf"><code>lua_setwarnf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);</pre>

<p>Luaが警告を発行するために使用する警告関数を設定します（<a href="#lua_WarnFunction"><code>lua_WarnFunction</code></a>を参照）。<code>ud</code>パラメータは、警告関数に渡される値<code>ud</code>を設定します。</p><hr /><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>スレッド、および（スレッドを介して間接的に）Luaインタープリターの全体の状態を指す不透明な構造体。 Luaライブラリは完全に再入可能です。グローバル変数はありません。ステートに関するすべての情報は、この構造体を介してアクセスできます。</p><p>この構造体へのポインタは、Luaステートを最初から作成する<a href="#lua_newstate"><code>lua_newstate</code></a>を除く、ライブラリ内のすべての関数への最初の引数として渡す必要があります。</p><hr /><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_status (lua_State *L);</pre>

<p>スレッド<code>L</code>のステータスを返します。</p><p>ステータスは、通常のスレッドの場合は<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、スレッドがエラーで<a href="#lua_resume"><code>lua_resume</code></a>の実行を終了した場合はエラーコード、スレッドが中断されている場合は<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>になります。</p><p><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>ステータスのスレッドでのみ関数を呼び出すことができます。<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>（新しいコルーチンを開始する）または<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>（コルーチンを再開する）ステータスのスレッドを再開できます。</p><hr /><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>ゼロ終端文字列<code>s</code>を数値に変換し、その数値をスタックにプッシュし、文字列の合計サイズ、つまりその長さ+1を返します。変換は、Luaの字句規則に従って、整数または浮動小数点数になる場合があります（<a href="#3.1">§3.1</a>を参照）。文字列には、先頭と末尾の空白と符号が含まれている場合があります。文字列が有効な数値でない場合は、0を返し、何もプッシュしません（結果はブール値として使用でき、変換が成功した場合はtrueになります）。</p><hr /><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>与えられたインデックスにあるLua値をCのブール値（0または1）に変換します。 Luaのすべてのテストと同様に、<a href="#lua_toboolean"><code>lua_toboolean</code></a>は、<b>false</b>および<b>nil</b>とは異なるLua値に対してtrueを返し、それ以外の場合はfalseを返します。（実際のブール値のみを受け入れる場合は、<a href="#lua_isboolean"><code>lua_isboolean</code></a>を使用して値の型をテストします。）</p><hr /><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>与えられたインデックスの値C関数に変換します。その値はC関数である必要があります。それ以外の場合は、<code>NULL</code>を返します。</p><hr /><h3><a name="lua_toclose"><code>lua_toclose</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>void lua_toclose (lua_State *L, int index);</pre>

<p>スタックの指定されたインデックスを、閉じられるスロットとしてマークします（<a href="#3.3.8">§3.3.8</a>を参照）。 Luaの閉じられる変数と同様に、スタックのそのスロットの値は、スコープ外になると閉じられます。ここで、C関数のコンテキストでは、スコープ外になるとは、実行中の関数がLuaに戻るか、エラーが発生するか、<a href="#lua_settop"><code>lua_settop</code></a>または<a href="#lua_pop"><code>lua_pop</code></a>を使用してスロットがスタックから削除されるか、<a href="#lua_closeslot"><code>lua_closeslot</code></a>が呼び出されることを意味します。閉じられるとマークされたスロットは、<a href="#lua_closeslot"><code>lua_closeslot</code></a>によって事前に非アクティブ化されない限り、<a href="#lua_settop"><code>lua_settop</code></a>または<a href="#lua_pop"><code>lua_pop</code></a>以外のAPIの他の関数によってスタックから削除しないでください。</p><p>この関数は、アクティブな閉じられるスロットと同じか下にあるインデックスに対して呼び出さないでください。</p><p>エラーの場合も通常の戻りの場合も、<code>__close</code>メタメソッドが実行されるまでに、Cスタックはすでに巻き戻されているため、呼び出し関数で宣言された自動C変数（例：バッファ）はスコープ外になることに注意してください。</p><hr /><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p><code>isnum</code>が<code>NULL</code>に等しい<a href="#lua_tointegerx"><code>lua_tointegerx</code></a>と同等です。</p><hr /><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>指定されたインデックスにある Lua の値を、符号付き整数型 <a href="#lua_Integer"><code>lua_Integer</code></a> に変換します。Lua の値は整数であるか、整数に変換可能な数値または文字列である必要があります（<a href="#3.4.3">§3.4.3</a>を参照）。それ以外の場合、<code>lua_tointegerx</code> は 0 を返します。</p><p><code>isnum</code> が <code>NULL</code> でない場合、操作が成功したかどうかを示すブール値が、その参照先に代入されます。</p><hr /><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>指定されたインデックスにある Lua の値を C 文字列に変換します。<code>len</code> が <code>NULL</code> でない場合、<code>*len</code> に文字列の長さが設定されます。Lua の値は文字列または数値である必要があります。それ以外の場合、関数は <code>NULL</code> を返します。値が数値の場合、<code>lua_tolstring</code> は<em>スタック内の実際の値も文字列に変更します</em>。（この変更は、テーブルトラバース中に <code>lua_tolstring</code> がキーに適用されると、<a href="#lua_next"><code>lua_next</code></a> を混乱させます。）</p><p>
<code>lua_tolstring</code> は Lua の状態内の文字列へのポインタを返します（<a href="#4.1.3">§4.1.3</a>を参照）。この文字列は常に最後の文字の後にゼロ ('<code>\0</code>') がありますが（C のように）、本体には他のゼロを含めることができます。</p><hr /><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p><code>isnum</code> が <code>NULL</code> である <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> と同等です。</p><hr /><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>指定されたインデックスにある Lua の値を C 型 <a href="#lua_Number"><code>lua_Number</code></a> に変換します（<a href="#lua_Number"><code>lua_Number</code></a>を参照）。Lua の値は数値であるか、数値に変換可能な文字列である必要があります（<a href="#3.4.3">§3.4.3</a>を参照）。それ以外の場合、<a href="#lua_tonumberx"><code>lua_tonumberx</code></a> は 0 を返します。</p><p><code>isnum</code> が <code>NULL</code> でない場合、操作が成功したかどうかを示すブール値が、その参照先に代入されます。</p><hr /><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>指定されたインデックスにある値を汎用 C ポインタ (<code>void*</code>) に変換します。値は userdata、テーブル、スレッド、文字列、または関数である可能性があります。それ以外の場合、<code>lua_topointer</code> は <code>NULL</code> を返します。異なるオブジェクトは異なるポインタを提供します。ポインタを元の値に戻す方法はありません。</p><p>通常、この関数はハッシュとデバッグ情報にのみ使用されます。</p><hr /><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p><code>len</code> が <code>NULL</code> である <a href="#lua_tolstring"><code>lua_tolstring</code></a> と同等です。</p><hr /><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>指定されたインデックスにある値を Lua スレッド (<code>lua_State*</code> として表現) に変換します。この値はスレッドである必要があります。それ以外の場合、関数は <code>NULL</code> を返します。</p><hr /><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が完全な userdata の場合、そのメモリーブロックアドレスを返します。値が light userdata の場合、その値 (ポインタ) を返します。それ以外の場合は、<code>NULL</code> を返します。</p><hr /><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_type (lua_State *L, int index);</pre>

<p>指定された有効なインデックスにある値の型を返します。または、無効ではあるが許容可能なインデックスの場合は <code>LUA_TNONE</code> を返します。<a href="#lua_type"><code>lua_type</code></a> によって返される型は、<code>lua.h</code> で定義された次の定数によってコード化されます。 <a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>, <a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>, <a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>, <a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>, <a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>, <a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>, <a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>, および <a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>。</p><hr /><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p><a href="#lua_type"><code>lua_type</code></a> によって返された値のいずれかである必要がある値 <code>tp</code> によってエンコードされた型の名前を返します。</p><hr /><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p><a href="#lua_Integer"><code>lua_Integer</code></a> の符号なしバージョン。</p><hr /><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_upvalueindex (int i);</pre>

<p>実行中の関数の <code>i</code> 番目のアップバリューを表す疑似インデックスを返します（<a href="#4.2">§4.2</a>を参照）。<code>i</code> は <em>[1,256]</em> の範囲内である必要があります。</p><hr /><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_version (lua_State *L);</pre>

<p>このコアのバージョン番号を返します。</p><hr /><h3><a name="lua_WarnFunction"><code>lua_WarnFunction</code></a></h3>
<pre>typedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);</pre>

<p>Lua によって警告を生成するために呼び出される警告関数の型です。最初のパラメータは、<a href="#lua_setwarnf"><code>lua_setwarnf</code></a> によって設定された不透明なポインタです。2番目のパラメータは警告メッセージです。3番目のパラメータは、メッセージを次の呼び出しのメッセージで継続する必要があるかどうかを示すブール値です。</p><p>警告の詳細については、<a href="#pdf-warn"><code>warn</code></a> を参照してください。</p><hr /><h3><a name="lua_warning"><code>lua_warning</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_warning (lua_State *L, const char *msg, int tocont);</pre>

<p>指定されたメッセージで警告を発行します。<code>tocont</code> が true の呼び出しでのメッセージは、この関数の別の呼び出しで継続する必要があります。</p><p>警告の詳細については、<a href="#pdf-warn"><code>warn</code></a> を参照してください。</p><hr /><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p><a href="#lua_dump"><code>lua_dump</code></a> によって使用されるライター関数の型です。<a href="#lua_dump"><code>lua_dump</code></a> がチャンクの別の部分を生成するたびに、ライターを呼び出し、書き込まれるバッファ (<code>p</code>)、そのサイズ (<code>sz</code>)、および <a href="#lua_dump"><code>lua_dump</code></a> に提供された <code>ud</code> パラメータを渡します。</p><p>ライターはエラーコードを返します。0 はエラーがないことを意味します。それ以外の値はエラーを意味し、<a href="#lua_dump"><code>lua_dump</code></a> がライターを再度呼び出すのを停止します。</p><hr /><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>同じ状態の異なるスレッド間で値を交換します。</p><p>この関数は、スタック <code>from</code> から <code>n</code> 個の値をポップし、スタック <code>to</code> にプッシュします。</p><hr /><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>この関数は <a href="#lua_yieldk"><code>lua_yieldk</code></a> と同等ですが、継続がありません (<a href="#4.5">§4.5</a> を参照)。したがって、スレッドが再開されると、<code>lua_yield</code> を呼び出す関数を呼び出した関数が続行されます。予期しない事態を避けるために、この関数は末尾呼び出しでのみ呼び出す必要があります。</p><hr /><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>コルーチン（スレッド）を譲ります。</p><p>C 関数が <a href="#lua_yieldk"><code>lua_yieldk</code></a> を呼び出すと、実行中のコルーチンはその実行を中断し、このコルーチンを開始した <a href="#lua_resume"><code>lua_resume</code></a> の呼び出しが戻ります。パラメータ <code>nresults</code> は、<a href="#lua_resume"><code>lua_resume</code></a> の結果として渡されるスタックからの値の数です。</p><p>コルーチンが再び再開されると、Lua は与えられた継続関数 <code>k</code> を呼び出して、譲った C 関数の実行を継続します (<a href="#4.5">§4.5</a> を参照)。この継続関数は、前の関数と同じスタックを、<code>n</code> 個の結果を削除し、<a href="#lua_resume"><code>lua_resume</code></a> に渡された引数に置き換えて受け取ります。さらに、継続関数は、<a href="#lua_yieldk"><code>lua_yieldk</code></a> に渡された値 <code>ctx</code> を受け取ります。</p><p>通常、この関数は戻りません。コルーチンが最終的に再開すると、継続関数の実行を続行します。ただし、1つの特別なケースがあります。それは、この関数がラインまたはカウントフックの中から呼び出された場合です（<a href="#4.7">§4.7</a> を参照）。その場合、<code>lua_yieldk</code> は継続なしで（おそらく <a href="#lua_yield"><code>lua_yield</code></a> の形式で）および結果なしで呼び出す必要があり、フックは呼び出し後すぐに戻る必要があります。Lua は譲り、コルーチンが再び再開すると、フックをトリガーした (Lua) 関数の通常の実行を続行します。</p><p>継続関数を持たない保留中の C 呼び出しがあるスレッド（<em>C 呼び出し境界</em>と呼ばれる）から呼び出された場合、または再開内で実行されていないスレッド（通常はメインスレッド）から呼び出された場合、この関数はエラーを発生させる可能性があります。</p><h2>4.7 – <a name="4.7">デバッグインターフェース</a></h2>

<p>Lua には組み込みのデバッグ機能はありません。代わりに、関数と<em>フック</em>による特別なインターフェースを提供します。このインターフェースを使用すると、さまざまな種類のデバッガ、プロファイラ、およびインタープリタからの「内部情報」を必要とするその他のツールを構築できます。</p><hr /><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  size_t srclen;              /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  unsigned short ftransfer;   /* (r) index of first value transferred */
  unsigned short ntransfer;   /* (r) number of transferred values */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>関数またはアクティベーションレコードに関するさまざまな情報を伝達するために使用される構造体。<a href="#lua_getstack"><code>lua_getstack</code></a> は、後で使用するために、この構造体のプライベート部分のみを埋めます。 <a href="#lua_Debug"><code>lua_Debug</code></a> の他のフィールドを有用な情報で埋めるには、適切なパラメータを使用して <a href="#lua_getinfo"><code>lua_getinfo</code></a> を呼び出す必要があります。（具体的には、フィールドを取得するには、フィールドのコメント内の括弧で囲まれた文字を <a href="#lua_getinfo"><code>lua_getinfo</code></a> のパラメータ <code>what</code> に追加する必要があります。）</p><p><a href="#lua_Debug"><code>lua_Debug</code></a> のフィールドには次の意味があります</p><ul>

<li><b><code>source</code>: </b> 関数を作成したチャンクのソース。<code>source</code> が '<code>@</code>' で始まる場合、関数がファイル内で定義されたことを意味し、ファイル名は '<code>@</code>' の後に続きます。<code>source</code> が '<code>=</code>' で始まる場合、そのコンテンツの残りはユーザーに依存する方法でソースを記述します。それ以外の場合、関数は文字列で定義され、<code>source</code> はその文字列です。</li>

<li><b><code>srclen</code>: </b> 文字列 <code>source</code> の長さ。</li>

<li><b><code>short_src</code>: </b> エラーメッセージで使用される <code>source</code> の「印刷可能な」バージョン。</li>

<li><b><code>linedefined</code>: </b> 関数の定義が始まる行番号。</li>

<li><b><code>lastlinedefined</code>: </b> 関数の定義が終わる行番号。</li>

<li><b><code>what</code>: </b> 関数が Lua 関数の場合は文字列 <code>"Lua"</code>、C 関数の場合は <code>"C"</code>、チャンクのメイン部分の場合は <code>"main"</code>。</li>

<li><b><code>currentline</code>: </b> 与えられた関数が実行されている現在の行。行情報がない場合、<code>currentline</code> は -1 に設定されます。</li>

<li><b><code>name</code>: </b> 与えられた関数の適切な名前。Lua の関数はファーストクラスの値であるため、固定された名前はありません。一部の関数は複数のグローバル変数の値になることがあり、他の関数はテーブルフィールドにのみ格納できます。 <code>lua_getinfo</code> 関数は、関数がどのように呼び出されたかを調べて適切な名前を見つけます。名前が見つからない場合、<code>name</code> は <code>NULL</code> に設定されます。</li>

<li><b><code>namewhat</code>: </b> <code>name</code> フィールドを説明します。 <code>namewhat</code> の値は、関数がどのように呼び出されたかに応じて、<code>"global"</code>、<code>"local"</code>、<code>"method"</code>、<code>"field"</code>、<code>"upvalue"</code>、または <code>""</code>（空文字列）のいずれかになります。（Lua は他のオプションが適用されないと思われる場合、空文字列を使用します。）</li>

<li><b><code>istailcall</code>: </b> この関数の呼び出しが末尾呼び出しによって呼び出された場合は true。この場合、このレベルの呼び出し元はスタックにありません。</li>

<li><b><code>nups</code>: </b> 関数のアップバリューの数。</li>

<li><b><code>nparams</code>: </b> 関数のパラメータの数 (C 関数の場合は常に 0)。</li>

<li><b><code>isvararg</code>: </b> 関数が可変長引数関数の場合 true (C 関数の場合は常に true)。</li>

<li><b><code>ftransfer</code>: </b> 「転送」される最初の値、つまり呼び出しのパラメータまたは戻り値のスタック内のインデックス。(他の値は連続したインデックスにあります。) このインデックスを使用すると、<a href="#lua_getlocal"><code>lua_getlocal</code></a> および <a href="#lua_setlocal"><code>lua_setlocal</code></a> を介してこれらの値にアクセスして変更できます。このフィールドは、呼び出しフック中に最初のパラメータを示す場合、または返される最初の値を示す戻りフック中にのみ意味があります。（呼び出しフックの場合、この値は常に 1 です。）</li>

<li><b><code>ntransfer</code>: </b> 転送される値の数 (前の項目を参照)。(Lua 関数の呼び出しの場合、この値は常に <code>nparams</code> と等しくなります。)</li>

</ul>




<hr /><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>現在のフック関数を返します。</p><hr /><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookcount (lua_State *L);</pre>

<p>現在のフックカウントを返します。</p><hr /><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookmask (lua_State *L);</pre>

<p>現在のフックマスクを返します。</p><hr /><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
</p><pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>特定の関数または関数の呼び出しに関する情報を取得します。</p><p>関数の呼び出しに関する情報を取得するには、パラメータ<code>ar</code>は、以前の<a href="#lua_getstack"><code>lua_getstack</code></a>の呼び出しによって入力されたか、フックへの引数として渡された有効なアクティベーションレコードでなければなりません（<a href="#lua_Hook"><code>lua_Hook</code></a>を参照）。</p><p>関数に関する情報を取得するには、その関数をスタックにプッシュし、<code>what</code>文字列を文字'<code>&gt;</code>'で開始します。（この場合、<code>lua_getinfo</code>はスタックのトップから関数をポップします。）たとえば、関数<code>f</code>が定義された行を知るには、次のコードを記述できます。</p><pre>     lua_Debug ar;
     lua_getglobal(L, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>文字列<code>what</code>の各文字は、構造体<code>ar</code>のいくつかのフィールドを埋めるか、スタックにプッシュする値を選択します。（これらの文字は、構造体<a href="#lua_Debug"><code>lua_Debug</code></a>の宣言でも、各フィールドに続くコメントの括弧内にドキュメント化されています。）</p><ul>

<li><b>'<code>f</code>'：</b> 指定されたレベルで実行中の関数をスタックにプッシュします。</li>

<li><b>'<code>l</code>'：</b> フィールド<code>currentline</code>を埋めます。</li>

<li><b>'<code>n</code>'：</b> フィールド<code>name</code>および<code>namewhat</code>を埋めます。</li>

<li><b>'<code>r</code>'：</b> フィールド<code>ftransfer</code>および<code>ntransfer</code>を埋めます。</li>

<li><b>'<code>S</code>'：</b> フィールド<code>source</code>、<code>short_src</code>、<code>linedefined</code>、<code>lastlinedefined</code>、および<code>what</code>を埋めます。</li>

<li><b>'<code>t</code>'：</b> フィールド<code>istailcall</code>を埋めます。</li>

<li><b>'<code>u</code>'：</b> フィールド<code>nups</code>、<code>nparams</code>、および<code>isvararg</code>を埋めます。</li>

<li><b>'<code>L</code>'：</b> インデックスが、関連付けられたコードを持つ関数の行、つまりブレークポイントを設定できる行であるテーブルをスタックにプッシュします。（コードのない行には、空行とコメントが含まれます。）このオプションをオプション'<code>f</code>'とともに指定すると、そのテーブルは関数の後にプッシュされます。これは、メモリエラーが発生する可能性のある唯一のオプションです。</li>

</ul>

<p>この関数は、<code>what</code>に無効なオプションがあることを示すために0を返します。それでも、有効なオプションは正しく処理されます。</p><hr /><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>指定されたアクティベーションレコードまたは指定された関数のローカル変数または一時的な値に関する情報を取得します。</p><p>最初の場合、パラメータ<code>ar</code>は、以前の<a href="#lua_getstack"><code>lua_getstack</code></a>の呼び出しによって入力されたか、フックへの引数として渡された有効なアクティベーションレコードでなければなりません（<a href="#lua_Hook"><code>lua_Hook</code></a>を参照）。インデックス<code>n</code>は、検査するローカル変数を指定します。変数インデックスと名前の詳細については、<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>を参照してください。</p><p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a>は、変数の値をスタックにプッシュし、その名前を返します。</p><p>2番目のケースでは、<code>ar</code>は<code>NULL</code>でなければならず、検査する関数はスタックの最上位になければなりません。この場合、Lua関数のパラメータのみが表示され（アクティブな変数の情報がないため）、スタックには値がプッシュされません。</p><p>インデックスがアクティブなローカル変数の数よりも大きい場合は、<code>NULL</code>を返します（何もプッシュしません）。</p><hr /><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>インタープリターのランタイムスタックに関する情報を取得します。</p><p>この関数は、指定されたレベルで実行中の関数の*アクティベーションレコード*の識別を使用して<a href="#lua_Debug"><code>lua_Debug</code></a>構造体の一部を埋めます。レベル0は現在実行中の関数であり、レベル*n+1*はレベル*n*を呼び出した関数です（スタックにカウントされない末尾呼び出しを除く）。スタックの深さよりも大きいレベルで呼び出されると、<a href="#lua_getstack"><code>lua_getstack</code></a>は0を返します。それ以外の場合は1を返します。</p><hr /><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>インデックス<code>funcindex</code>にあるクロージャの<code>n</code>番目のアップバリューに関する情報を取得します。アップバリューの値をスタックにプッシュし、その名前を返します。インデックス<code>n</code>がアップバリューの数よりも大きい場合は、<code>NULL</code>を返します（何もプッシュしません）。</p><p>アップバリューの詳細については、<a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a>を参照してください。</p><hr /><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>デバッグフック関数の型。</p><p>フックが呼び出されるたびに、その<code>ar</code>引数のフィールド<code>event</code>には、フックをトリガーした特定のイベントが設定されます。Luaは、これらのイベントを次の定数で識別します：<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>、<a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>、<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>、<a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>、および<a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>。さらに、行イベントの場合、フィールド<code>currentline</code>も設定されます。<code>ar</code>の他のフィールドの値を取得するには、フックは<a href="#lua_getinfo"><code>lua_getinfo</code></a>を呼び出す必要があります。</p><p>呼び出しイベントの場合、<code>event</code>は通常の値である<code>LUA_HOOKCALL</code>、または末尾呼び出しの場合は<code>LUA_HOOKTAILCALL</code>にすることができます。この場合、対応する戻りイベントはありません。</p><p>Luaがフックを実行している間、フックへの他の呼び出しは無効になります。したがって、フックがLuaを呼び出して関数またはチャンクを実行する場合、この実行はフックへの呼び出しなしで発生します。</p><p>フック関数は継続を持つことができません。つまり、nullでない<code>k</code>で<a href="#lua_yieldk"><code>lua_yieldk</code></a>、<a href="#lua_pcallk"><code>lua_pcallk</code></a>、または<a href="#lua_callk"><code>lua_callk</code></a>を呼び出すことはできません。</p><p>フック関数は、次の条件でyieldできます。カウントイベントと行イベントのみがyieldできます。yieldするには、フック関数は、<code>nresults</code>がゼロ（つまり、値がない）である<a href="#lua_yield"><code>lua_yield</code></a>を呼び出して実行を終了する必要があります。</p><hr /><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>デバッグフック関数を設定します。</p><p>引数<code>f</code>はフック関数です。<code>mask</code>は、フックが呼び出されるイベントを指定します。これは、定数<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>、<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>、<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>、および<a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>のビットごとのORで形成されます。<code>count</code>引数は、マスクに<code>LUA_MASKCOUNT</code>が含まれている場合にのみ意味があります。各イベントについて、フックは以下で説明するように呼び出されます。</p><ul>

<li><b>呼び出しフック：</b> インタープリターが関数を呼び出すときに呼び出されます。フックは、Luaが新しい関数に入った直後に呼び出されます。</li>

<li><b>戻りフック：</b> インタープリターが関数から戻るときに呼び出されます。フックは、Luaが関数を離れる直前に呼び出されます。</li>

<li><b>行フック：</b> インタープリターが新しいコード行の実行を開始しようとしているとき、またはコード内で（同じ行にでも）戻るときに呼び出されます。このイベントは、LuaがLua関数を実行している間のみ発生します。</li>

<li><b>カウントフック：</b> インタープリターが<code>count</code>命令を実行するたびに呼び出されます。このイベントは、LuaがLua関数を実行している間のみ発生します。</li>

</ul>

<p>フックは、<code>mask</code>をゼロに設定することで無効になります。</p><hr /><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>指定されたアクティベーションレコードのローカル変数の値を設定します。スタックの最上位の値を変数に割り当て、その名前を返します。また、スタックから値をポップします。</p><p>インデックスがアクティブなローカル変数の数よりも大きい場合は、<code>NULL</code>を返します（何もポップしません）。</p><p>パラメータ<code>ar</code>および<code>n</code>は、関数<a href="#lua_getlocal"><code>lua_getlocal</code></a>と同じです。</p><hr /><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>クロージャのアップバリューの値を設定します。スタックの最上位の値をアップバリューに割り当て、その名前を返します。また、スタックから値をポップします。</p><p>インデックス<code>n</code>がアップバリューの数よりも大きい場合は、<code>NULL</code>を返します（何もポップしません）。</p><p>パラメータ<code>funcindex</code>および<code>n</code>は、関数<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>と同じです。</p><hr /><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>インデックス<code>funcindex</code>にあるクロージャの<code>n</code>番目のアップバリューの一意の識別子を返します。</p><p>これらの固有の識別子により、プログラムは異なるクロージャがアップバリューを共有しているかどうかを確認できます。アップバリューを共有する（つまり、同じ外部ローカル変数にアクセスする）Luaクロージャは、それらのアップバリューインデックスに対して同一のIDを返します。</p><p>パラメータ<code>funcindex</code>および<code>n</code>は、関数<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>と同じですが、<code>n</code>はアップバリューの数よりも大きくすることはできません。</p><hr /><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>インデックス<code>funcindex1</code>にあるLuaクロージャの<code>n1</code>番目のアップバリューを、インデックス<code>funcindex2</code>にあるLuaクロージャの<code>n2</code>番目のアップバリューを参照するようにします。</p><h1>5 – <a name="5">補助ライブラリ</a></h1>



<p><em>補助ライブラリ</em>は、CとLuaをインターフェイスするための便利な関数をいくつか提供します。基本的なAPIは、CとLua間のすべての相互作用のためのプリミティブ関数を提供する一方、補助ライブラリはいくつかの一般的なタスクのためのより高レベルの関数を提供します。</p><p>補助ライブラリのすべての関数と型は、ヘッダーファイル<code>lauxlib.h</code>で定義され、接頭辞<code>luaL_</code>が付いています。</p><p>補助ライブラリのすべての関数は、基本的なAPIの上に構築されているため、そのAPIではできないことは何も提供しません。それにもかかわらず、補助ライブラリを使用すると、コードの一貫性が向上します。</p><p>補助ライブラリのいくつかの関数は、内部的にいくつかの追加のスタックスロットを使用します。補助ライブラリの関数が5つ未満のスロットを使用する場合、スタックサイズをチェックしません。十分なスロットがあると単純に想定します。</p><p>補助ライブラリのいくつかの関数は、C関数の引数をチェックするために使用されます。エラーメッセージは引数用にフォーマットされているため（例： "<code>bad argument #1</code>"）、これらの関数を他のスタック値に使用しないでください。</p><p><code>luaL_check*</code>と呼ばれる関数は、チェックが満たされない場合は常にエラーを発生させます。</p><h2>5.1 – <a name="5.1">関数と型</a></h2>

<p>ここでは、補助ライブラリのすべての関数と型をアルファベット順にリストします。</p><hr /><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>バイト<code>c</code>をバッファ<code>B</code>に追加します（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）。</p><hr /><h3><a name="luaL_addgsub"><code>luaL_addgsub</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>const void luaL_addgsub (luaL_Buffer *B, const char *s,
                         const char *p, const char *r);</pre>

<p>文字列<code>s</code>のコピーをバッファ<code>B</code>に追加します（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）。文字列<code>p</code>の出現箇所を文字列<code>r</code>で置き換えます。</p><hr /><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>長さ<code>l</code>の<code>s</code>が指す文字列をバッファ<code>B</code>に追加します（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）。文字列には埋め込まれたゼロを含めることができます。</p><hr /><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>以前にバッファ領域にコピーされた長さ<code>n</code>の文字列をバッファ<code>B</code>に追加します（<a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>を参照）。</p><hr /><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p><code>s</code>が指すゼロ終端文字列をバッファ<code>B</code>に追加します（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）。</p><hr /><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>スタックの最上位にある値をバッファ<code>B</code>（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）に追加します。値はポップされます。</p><p>これは文字列バッファに関する唯一の関数で、スタックに追加する値がスタックにある状態で呼び出すことができます（また、そうする必要があります）。</p><hr /><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p><code>cond</code>が真であるかどうかをチェックします。真でない場合、標準メッセージ（<a href="#luaL_argerror"><code>luaL_argerror</code></a>を参照）とともにエラーを発生させます。</p><hr /><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>C関数を呼び出した引数<code>arg</code>に関する問題を報告するエラーを発生させます。標準メッセージには、コメントとして<code>extramsg</code>が含まれます。</p><pre>     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>この関数は決して戻りません。</p><hr /><h3><a name="luaL_argexpected"><code>luaL_argexpected</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_argexpected (lua_State *L,
                       int cond,
                       int arg,
                       const char *tname);</pre>

<p><code>cond</code>が真であるかどうかをチェックします。真でない場合、標準メッセージ（<a href="#luaL_typeerror"><code>luaL_typeerror</code></a>を参照）とともに引数<code>arg</code>の型に関するエラーを発生させます。</p><hr /><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p><em>文字列バッファ</em>の型。</p><p>文字列バッファを使用すると、CコードでLua文字列を段階的に構築できます。その使用パターンは以下のとおりです。</p><ul>

<li>まず、<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>型の変数<code>b</code>を宣言します。</li>

<li>次に、<code>luaL_buffinit(L, &amp;b)</code>を呼び出して初期化します。</li>

<li>次に、<code>luaL_add*</code>関数を呼び出して、文字列の断片をバッファに追加します。</li>

<li>最後に、<code>luaL_pushresult(&amp;b)</code>を呼び出して完了します。この呼び出しは、最終的な文字列をスタックの最上位に残します。</li>

</ul>

<p>結果の文字列の最大サイズを事前に知っている場合は、次のようにバッファを使用できます。</p><ul>

<li>まず、<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>型の変数<code>b</code>を宣言します。</li>

<li>次に、<code>luaL_buffinitsize(L, &amp;b, sz)</code>を呼び出して初期化し、サイズ<code>sz</code>の領域を事前割り当てします。</li>

<li>次に、その領域に文字列を生成します。</li>

<li>最後に、<code>luaL_pushresultsize(&amp;b, sz)</code>を呼び出して完了します。<code>sz</code>は、その領域にコピーされた結果の文字列の合計サイズです（事前割り当てされたサイズ以下になる可能性があります）。</li>

</ul>

<p>通常の操作中、文字列バッファは可変数のスタックスロットを使用します。そのため、バッファを使用している間は、スタックの最上位がどこにあるかわからないことを前提とする必要があります。スタックは、その使用がバランスが取れている限り、バッファ操作への連続した呼び出しの間で使用できます。つまり、バッファ操作を呼び出すとき、スタックは前のバッファ操作直後と同じレベルにある必要があります。（この規則の唯一の例外は<a href="#luaL_addvalue"><code>luaL_addvalue</code></a>です。）<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>を呼び出した後、スタックはバッファが初期化されたときと同じレベルに戻り、さらにその最上位に最終的な文字列が追加されます。</p><hr /><h3><a name="luaL_buffaddr"><code>luaL_buffaddr</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>char *luaL_buffaddr (luaL_Buffer *B);</pre>

<p>バッファ<code>B</code>（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）の現在の内容のアドレスを返します。バッファへの追加は、このアドレスを無効にする可能性があることに注意してください。</p><hr /><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>バッファ<code>B</code>（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）を初期化します。この関数は領域を割り当てません。バッファは変数として宣言する必要があります。</p><hr /><h3><a name="luaL_bufflen"><code>luaL_bufflen</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>size_t luaL_bufflen (luaL_Buffer *B);</pre>

<p>バッファ<code>B</code>（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）の現在の内容の長さを返します。</p><hr /><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p><a href="#luaL_buffinit"><code>luaL_buffinit</code></a>, <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>のシーケンスと同等です。</p><hr /><h3><a name="luaL_buffsub"><code>luaL_buffsub</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void luaL_buffsub (luaL_Buffer *B, int n);</pre>

<p>バッファ<code>B</code>（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）から<code>n</code>バイトを削除します。バッファには少なくともそれだけのバイト数が必要です。</p><hr /><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
</p><pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>メタメソッドを呼び出します。</p><p>インデックス<code>obj</code>にあるオブジェクトがメタテーブルを持ち、このメタテーブルにフィールド<code>e</code>がある場合、この関数はこのフィールドを呼び出し、オブジェクトを唯一の引数として渡します。この場合、この関数はtrueを返し、呼び出しによって返された値をスタックにプッシュします。メタテーブルがない場合、またはメタメソッドがない場合、この関数は値をスタックにプッシュせずにfalseを返します。</p><hr /><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>関数が位置<code>arg</code>に任意の型（<b>nil</b>を含む）の引数を持っているかどうかをチェックします。</p><hr /><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>関数引数<code>arg</code>が整数である（または整数に変換できる）かどうかをチェックし、この整数を返します。</p><hr /><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>関数引数<code>arg</code>が文字列であるかどうかをチェックし、この文字列を返します。<code>l</code>が<code>NULL</code>でない場合は、その参照を文字列の長さで埋めます。</p><p>この関数は、結果を取得するために<a href="#lua_tolstring"><code>lua_tolstring</code></a>を使用するため、その関数のすべての変換と注意点がここで適用されます。</p><hr /><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>関数引数<code>arg</code>が数値であるかどうかをチェックし、この数値を<code>lua_Number</code>に変換して返します。</p><hr /><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>関数引数<code>arg</code>が文字列であるかどうかをチェックし、この文字列を配列<code>lst</code>（NULL終端である必要があります）で検索します。文字列が見つかった配列のインデックスを返します。引数が文字列でない場合、または文字列が見つからない場合は、エラーを発生させます。</p><p><code>def</code>が<code>NULL</code>でない場合、この関数は、引数<code>arg</code>がない場合、またはこの引数が<b>nil</b>の場合に、<code>def</code>をデフォルト値として使用します。</p><p>これは、文字列をC列挙型にマッピングするのに役立つ関数です。（Luaライブラリでの一般的な規約は、オプションを選択するために数値の代わりに文字列を使用することです。）</p><hr /><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>スタックサイズを<code>top + sz</code>要素まで増やします。スタックがそのサイズまで増やせない場合は、エラーを発生させます。<code>msg</code>は、エラーメッセージに追加するテキスト（追加のテキストがない場合は<code>NULL</code>）です。</p><hr /><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>関数引数<code>arg</code>が文字列であるかどうかをチェックし、この文字列を返します。</p><p>この関数は、結果を取得するために<a href="#lua_tolstring"><code>lua_tolstring</code></a>を使用するため、その関数のすべての変換と注意点がここで適用されます。</p><hr /><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>関数引数<code>arg</code>が型<code>t</code>を持っているかどうかをチェックします。<code>t</code>の型のエンコーディングについては<a href="#lua_type"><code>lua_type</code></a>を参照してください。</p><hr /><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>関数引数<code>arg</code>が型<code>tname</code>（<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>を参照）のuserdataであるかどうかをチェックし、userdataのメモリブロックアドレス（<a href="#lua_touserdata"><code>lua_touserdata</code></a>を参照）を返します。</p><hr /><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>void luaL_checkversion (lua_State *L);</pre>

<p>呼び出しを行うコードと呼び出されているLuaライブラリが、同じバージョンのLuaと、同じ数値型を使用しているかどうかをチェックします。</p><hr /><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
</p><pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>指定されたファイルをロードして実行します。これは、次のマクロとして定義されます。</p><pre>     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>エラーがない場合は0（<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>）を返し、エラーの場合は1を返します。</p><hr /><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>指定された文字列をロードして実行します。これは、次のマクロとして定義されます。</p><pre>     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>エラーがない場合は0（<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>）を返し、エラーの場合は1を返します。</p><hr /><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>エラーを発生させます。エラーメッセージの形式は、<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>と同じルールに従って、<code>fmt</code>と追加の引数によって指定されます。また、メッセージの先頭に、エラーが発生したファイル名と行番号を追加します（この情報が利用可能な場合）。</p><p>この関数は決して戻りませんが、C関数では<code>return luaL_error(<em>args</em>)</code>として使用するのが慣例です。</p><hr /><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>m</em>]</span>
</p><pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>この関数は、標準ライブラリ（<a href="#pdf-os.execute"><code>os.execute</code></a>および<a href="#pdf-io.close"><code>io.close</code></a>）のプロセス関連関数の戻り値を生成します。</p><hr /><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>m</em>]</span>
</p><pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>この関数は、標準ライブラリ（<a href="#pdf-io.open"><code>io.open</code></a>、<a href="#pdf-os.rename"><code>os.rename</code></a>、<a href="#pdf-file:seek"><code>file:seek</code></a>など）のファイル関連関数の戻り値を生成します。</p><hr /><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
</p><pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>インデックス<code>obj</code>にあるオブジェクトのメタテーブルからフィールド<code>e</code>をスタックにプッシュし、プッシュされた値の型を返します。オブジェクトにメタテーブルがない場合、またはメタテーブルにこのフィールドがない場合は、何もプッシュせずに<code>LUA_TNIL</code>を返します。</p><hr /><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>レジストリ内の名前<code>tname</code>に関連付けられたメタテーブル（<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>を参照）をスタックにプッシュします。その名前に関連付けられたメタテーブルがない場合は<b>nil</b>をプッシュします。プッシュされた値の型を返します。</p><hr /><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>インデックス<code>idx</code>にある値<code>t</code>において、<code>t[fname]</code>がテーブルであることを確認し、そのテーブルをスタックにプッシュします。そこに以前のテーブルがある場合はtrueを返し、新しいテーブルを作成した場合はfalseを返します。</p><hr /><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>文字列<code>s</code>のコピーを作成し、文字列<code>p</code>の出現箇所をすべて文字列<code>r</code>に置き換えます。結果の文字列をスタックにプッシュして返します。</p><hr /><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>指定されたインデックスにある値の「長さ」を数値として返します。これはLuaの '<code>#</code>' 演算子（<a href="#3.4.7">§3.4.7</a>を参照）と同等です。操作の結果が整数でない場合は、エラーを発生させます。（このケースは、メタメソッドを通じてのみ発生する可能性があります。）</p><hr /><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p><code>mode</code>が<code>NULL</code>である<a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a>と同等です。</p><hr /><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>バッファをLuaチャンクとしてロードします。この関数は、<a href="#lua_load"><code>lua_load</code></a>を使用して、サイズ<code>sz</code>の<code>buff</code>によって指されるバッファ内のチャンクをロードします。</p><p>この関数は、<a href="#lua_load"><code>lua_load</code></a>と同じ結果を返します。<code>name</code>は、デバッグ情報とエラーメッセージに使用されるチャンク名です。文字列<code>mode</code>は、関数<a href="#lua_load"><code>lua_load</code></a>の場合と同様に機能します。</p><hr /><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p><code>mode</code>が<code>NULL</code>である<a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a>と同等です。</p><hr /><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>ファイルをLuaチャンクとしてロードします。この関数は、<a href="#lua_load"><code>lua_load</code></a>を使用して、<code>filename</code>という名前のファイル内のチャンクをロードします。<code>filename</code>が<code>NULL</code>の場合、標準入力からロードします。ファイルの最初の行が<code>#</code>で始まる場合は無視されます。</p><p>文字列<code>mode</code>は、関数<a href="#lua_load"><code>lua_load</code></a>の場合と同様に機能します。</p><p>この関数は、<a href="#lua_load"><code>lua_load</code></a>と同じ結果を返します。ファイル関連のエラーの場合は、<a href="#pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>を返します。</p><p><a href="#lua_load"><code>lua_load</code></a>と同様に、この関数はチャンクをロードするだけで、実行はしません。</p><hr /><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>文字列をLuaチャンクとしてロードします。この関数は、<a href="#lua_load"><code>lua_load</code></a>を使用して、NULL終端文字列<code>s</code>内のチャンクをロードします。</p><p>この関数は、<a href="#lua_load"><code>lua_load</code></a>と同じ結果を返します。</p><p><a href="#lua_load"><code>lua_load</code></a>と同様に、この関数はチャンクをロードするだけで、実行はしません。</p><hr /><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>新しいテーブルを作成し、リスト<code>l</code>内の関数を登録します。</p><p>これは、次のマクロとして実装されます。</p><pre>     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>配列<code>l</code>は、実際の配列である必要があり、ポインタであってはなりません。</p><hr /><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>配列<code>l</code>内のすべてのエントリを格納するために最適化されたサイズで新しいテーブルを作成します（ただし、実際には格納しません）。これは、<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>（<a href="#luaL_newlib"><code>luaL_newlib</code></a>を参照）と組み合わせて使用​​することを目的としています。</p><p>これはマクロとして実装されます。配列<code>l</code>は、実際の配列である必要があり、ポインタであってはなりません。</p><hr /><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>レジストリにすでにキー<code>tname</code>がある場合は0を返します。そうでない場合は、userdataのメタテーブルとして使用する新しいテーブルを作成し、この新しいテーブルにペア<code>__name = tname</code>を追加し、レジストリにペア<code>[tname] = new table</code>を追加して1を返します。</p><p>どちらの場合も、この関数は、レジストリ内の<code>tname</code>に関連付けられた最終的な値をスタックにプッシュします。</p><hr /><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *luaL_newstate (void);</pre>

<p>新しいLuaステートを作成します。ISO&nbsp;Cのメモリ割り当て関数に基づくアロケータで<a href="#lua_newstate"><code>lua_newstate</code></a>を呼び出し、その後、標準エラー出力にメッセージを出力する警告関数とパニック関数（<a href="#4.4">§4.4</a>を参照）を設定します。</p><p>新しいステートを返します。メモリ割り当てエラーが発生した場合は<code>NULL</code>を返します。</p><hr /><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void luaL_openlibs (lua_State *L);</pre>

<p>与えられたステートにすべての標準Luaライブラリを開きます。</p><hr /><h3><a name="luaL_opt"><code>luaL_opt</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>T luaL_opt (L, func, arg, dflt);</pre>

<p>このマクロは次のように定義されます。</p><pre>     (lua_isnoneornil(L,(arg)) ? (dflt) : func(L,(arg)))
</pre><p>言葉で言うと、引数<code>arg</code>がnilまたは存在しない場合、マクロの結果はデフォルトの<code>dflt</code>になります。それ以外の場合は、ステート<code>L</code>と引数インデックス<code>arg</code>を引数として<code>func</code>を呼び出した結果になります。必要な場合にのみ式<code>dflt</code>が評価されることに注意してください。</p><hr /><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>関数引数<code>arg</code>が整数である（または整数に変換可能である）場合、この整数を返します。この引数が存在しないか、<b>nil</b>の場合は、<code>d</code>を返します。それ以外の場合は、エラーを発生させます。</p><hr /><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>関数引数<code>arg</code>が文字列である場合、この文字列を返します。この引数が存在しないか、<b>nil</b>の場合は、<code>d</code>を返します。それ以外の場合は、エラーを発生させます。</p><p><code>l</code>が<code>NULL</code>でない場合、その参照先を結果の長さで埋めます。結果が<code>NULL</code>（<code>d</code>を返し、<code>d == NULL</code>の場合のみ可能）の場合、その長さはゼロとみなされます。</p><p>この関数は、結果を取得するために<a href="#lua_tolstring"><code>lua_tolstring</code></a>を使用するため、その関数のすべての変換と注意点がここで適用されます。</p><hr /><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>関数引数<code>arg</code>が数値である場合、この数値を<code>lua_Number</code>として返します。この引数が存在しないか、<b>nil</b>の場合は、<code>d</code>を返します。それ以外の場合は、エラーを発生させます。</p><hr /><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>関数引数<code>arg</code>が文字列である場合、この文字列を返します。この引数が存在しないか、<b>nil</b>の場合は、<code>d</code>を返します。それ以外の場合は、エラーを発生させます。</p><hr /><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>定義済みのサイズ<a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>で<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>と同等です。</p><hr /><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
</p><pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>バッファ<code>B</code>（<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>を参照）に追加する文字列をコピーできるサイズ<code>sz</code>のスペースのアドレスを返します。このスペースに文字列をコピーした後、文字列のサイズで<a href="#luaL_addsize"><code>luaL_addsize</code></a>を呼び出して、実際にバッファに追加する必要があります。</p><hr /><h3><a name="luaL_pushfail"><code>luaL_pushfail</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void luaL_pushfail (lua_State *L);</pre>

<p>スタックに<b>fail</b>値をプッシュします（<a href="#6">§6</a>を参照）。</p><hr /><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
</p><pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>バッファ<code>B</code>の使用を終了し、最終的な文字列をスタックの最上部に残します。</p><hr /><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
</p><pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>シーケンス<a href="#luaL_addsize"><code>luaL_addsize</code></a>、<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>と同等です。</p><hr /><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>int luaL_ref (lua_State *L, int t);</pre>

<p>スタックの一番上にあるオブジェクトに対する<em>参照</em>を、インデックス<code>t</code>にあるテーブル内に作成して返します（そしてオブジェクトをポップします）。</p><p>参照は一意の整数キーです。テーブル<code>t</code>に整数キーを手動で追加しない限り、<a href="#luaL_ref"><code>luaL_ref</code></a>は返されるキーの一意性を保証します。参照<code>r</code>で参照されるオブジェクトを取得するには、<code>lua_rawgeti(L, t, r)</code>を呼び出します。関数<a href="#luaL_unref"><code>luaL_unref</code></a>は参照を解放します。</p><p>スタックの最上部にあるオブジェクトが<b>nil</b>の場合、<a href="#luaL_ref"><code>luaL_ref</code></a>は定数<a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>を返します。定数<a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a>は、<a href="#luaL_ref"><code>luaL_ref</code></a>によって返されるどの参照とも異なることが保証されています。</p><hr /><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p><a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>によって登録される関数の配列の型です。<code>name</code>は関数名であり、<code>func</code>は関数へのポインタです。<a href="#luaL_Reg"><code>luaL_Reg</code></a>の配列は、<code>name</code>と<code>func</code>の両方が<code>NULL</code>である番兵エントリで終わる必要があります。</p><hr /><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p><code>package.loaded[modname]</code>がtrueでない場合、文字列<code>modname</code>を引数として関数<code>openf</code>を呼び出し、<a href="#pdf-require"><code>require</code></a>を介して関数が呼び出されたかのように、呼び出し結果を<code>package.loaded[modname]</code>に設定します。</p><p><code>glb</code>がtrueの場合、モジュールをグローバル<code>modname</code>にも保存します。</p><p>スタックにモジュールのコピーを残します。</p><hr /><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>m</em>]</span>
</p><pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>配列<code>l</code>（<a href="#luaL_Reg"><code>luaL_Reg</code></a>を参照）内のすべての関数を、スタックの最上部にあるテーブル（オプションのアップバリューの下、次を参照）に登録します。</p><p><code>nup</code>がゼロでない場合、すべての関数は<code>nup</code>個のアップバリューで作成され、ライブラリテーブルの一番上にスタックにプッシュされた<code>nup</code>個の値のコピーで初期化されます。これらの値は、登録後にスタックからポップされます。</p><p><code>NULL</code>値を持つ関数は、<b>false</b>で埋められるプレースホルダを表します。</p><hr /><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>スタックの最上部にあるオブジェクトのメタテーブルを、レジストリ内の名前<code>tname</code>に関連付けられたメタテーブルとして設定します（<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>を参照）。</p><hr /><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>標準I/Oライブラリで使用されるファイルハンドルの標準表現です。</p><p>ファイルハンドルは、<code>LUA_FILEHANDLE</code>というメタテーブルを持つフルユーザーデータとして実装されます（<code>LUA_FILEHANDLE</code>は実際のメタテーブルの名前を持つマクロです）。メタテーブルはI/Oライブラリによって作成されます（<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>を参照）。</p><p>このユーザーデータは構造体<code>luaL_Stream</code>で始まる必要があり、この初期構造体の後に他のデータを含めることができます。フィールド<code>f</code>は対応するCストリームを指します（または、不完全に作成されたハンドルを示すために<code>NULL</code>にすることもできます）。フィールド<code>closef</code>は、ハンドルが閉じられたとき、または収集されたときにストリームを閉じるために呼び出されるLua関数を指します。この関数は、ファイルハンドルを唯一の引数として受け取り、成功の場合はtrue値、エラーの場合はfalse値とエラーメッセージを返す必要があります。Luaがこのフィールドを呼び出すと、ハンドルが閉じられたことを示すために、フィールド値を<code>NULL</code>に変更します。</p><hr /><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>この関数は、テストが失敗した場合にエラーを発生させる代わりに<code>NULL</code>を返すことを除いて、<a href="#luaL_checkudata"><code>luaL_checkudata</code></a>のように機能します。</p><hr /><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>指定されたインデックスにある任意のLua値を、妥当な形式のC文字列に変換します。結果の文字列はスタックにプッシュされ、関数からも返されます（<a href="#4.1.3">§4.1.3</a>を参照）。<code>len</code>が<code>NULL</code>でない場合、関数は<code>*len</code>に文字列の長さも設定します。</p><p>値に<code>__tostring</code>フィールドを持つメタテーブルがある場合、<code>luaL_tolstring</code>は値を引数として対応するメタメソッドを呼び出し、呼び出しの結果を結果として使用します。</p><hr /><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>スタック<code>L1</code>のトレースバックを作成してプッシュします。<code>msg</code>が<code>NULL</code>でない場合、トレースバックの先頭に追加されます。<code>level</code>パラメータは、トレースバックを開始するレベルを示します。</p><hr /><h3><a name="luaL_typeerror"><code>luaL_typeerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
</p><pre>int luaL_typeerror (lua_State *L, int arg, const char *tname);</pre>

<p>標準メッセージを使用して、それを呼び出したC関数の引数<code>arg</code>に対して型エラーを発生させます。<code>tname</code>は、予期される型の「名前」です。この関数は決して返りません。</p><hr /><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>指定されたインデックスにある値の型の名前を返します。</p><hr /><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>インデックス<code>t</code>にあるテーブルから参照<code>ref</code>を解放します（<a href="#luaL_ref"><code>luaL_ref</code></a>を参照）。エントリはテーブルから削除されるため、参照されているオブジェクトを収集できます。参照<code>ref</code>も再利用できるように解放されます。</p><p><code>ref</code>が<a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a>または<a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>の場合、<a href="#luaL_unref"><code>luaL_unref</code></a>は何もしません。</p><hr /><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>スタックに、コールスタック内のレベル<code>lvl</code>でのコントロールの現在の位置を識別する文字列をプッシュします。通常、この文字列は次の形式です。</p><pre>     <em>chunkname</em>:<em>currentline</em>:
</pre><p>レベル&nbsp;0は実行中の関数、レベル&nbsp;1は実行中の関数を呼び出した関数などです。</p><p>この関数は、エラーメッセージのプレフィックスを構築するために使用されます。</p><h1>6 – <a name="6">標準ライブラリ</a></h1>



<p>標準Luaライブラリは、C&nbsp;APIを介してCで実装された便利な関数を提供します。これらの関数の中には、言語に不可欠なサービスを提供するもの（例：<a href="#pdf-type"><code>type</code></a>と<a href="#pdf-getmetatable"><code>getmetatable</code></a>）があります。その他は、外部サービス（例：I/O）へのアクセスを提供します。また、Lua自体で実装できるものもありますが、さまざまな理由でCでの実装に値するものもあります（例：<a href="#pdf-table.sort"><code>table.sort</code></a>）。</p><p>すべてのライブラリは公式のC&nbsp;APIを介して実装され、個別のC&nbsp;モジュールとして提供されます。特に断りのない限り、これらのライブラリ関数は、その引数の数を予期されるパラメータに調整しません。たとえば、<code>foo(arg)</code>としてドキュメント化された関数は、引数なしで呼び出すべきではありません。</p><p><b>fail</b>という表記は、何らかの失敗を表すfalse値を意味します。（現在、<b>fail</b>は<b>nil</b>と等しいですが、将来のバージョンでは変更される可能性があります。推奨されるのは、<code>(status == nil)</code>の代わりに、常に<code>(not status)</code>でこれらの関数の成功をテストすることです。）</p><p>現在、Luaには次の標準ライブラリがあります。</p><ul>

<li>基本ライブラリ（<a href="#6.1">§6.1</a>）;</li>

<li>コルーチンライブラリ（<a href="#6.2">§6.2</a>）;</li>

<li>パッケージライブラリ（<a href="#6.3">§6.3</a>）;</li>

<li>文字列操作（<a href="#6.4">§6.4</a>）;</li>

<li>基本的なUTF-8サポート（<a href="#6.5">§6.5</a>）;</li>

<li>テーブル操作（<a href="#6.6">§6.6</a>）;</li>

<li>数学関数（<a href="#6.7">§6.7</a>）（sin、logなど）;</li>

<li>入出力（<a href="#6.8">§6.8</a>）;</li>

<li>オペレーティングシステム機能（<a href="#6.9">§6.9</a>）;</li>

<li>デバッグ機能（<a href="#6.10">§6.10</a>）。</li>

</ul><p>基本ライブラリとパッケージライブラリを除いて、各ライブラリは、そのすべての関数をグローバルテーブルのフィールドとして、またはそのオブジェクトのメソッドとして提供します。</p><p>これらのライブラリにアクセスするには、C&nbsp;ホストプログラムは、すべての標準ライブラリを開く<a href="#luaL_openlibs"><code>luaL_openlibs</code></a>関数を呼び出す必要があります。または、ホストプログラムは、<a name="pdf-luaopen_base"><code>luaopen_base</code></a>（基本ライブラリの場合）、<a name="pdf-luaopen_package"><code>luaopen_package</code></a>（パッケージライブラリの場合）、<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a>（コルーチンライブラリの場合）、<a name="pdf-luaopen_string"><code>luaopen_string</code></a>（文字列ライブラリの場合）、<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a>（UTF-8ライブラリの場合）、<a name="pdf-luaopen_table"><code>luaopen_table</code></a>（テーブルライブラリの場合）、<a name="pdf-luaopen_math"><code>luaopen_math</code></a>（数学ライブラリの場合）、<a name="pdf-luaopen_io"><code>luaopen_io</code></a>（I/Oライブラリの場合）、<a name="pdf-luaopen_os"><code>luaopen_os</code></a>（オペレーティングシステムライブラリの場合）、および<a name="pdf-luaopen_debug"><code>luaopen_debug</code></a>（デバッグライブラリの場合）を呼び出すために、<a href="#luaL_requiref"><code>luaL_requiref</code></a>を使用して個別に開くことができます。これらの関数は<a name="pdf-lualib.h"><code>lualib.h</code></a>で宣言されています。</p><h2>6.1 – <a name="6.1">基本関数</a></h2>

<p>基本ライブラリは、Luaへのコア関数を提供します。このライブラリをアプリケーションに含めない場合は、その機能の一部に実装を提供する必要があるかどうかを注意深く確認する必要があります。</p><p>
</p><hr /><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>引数<code>v</code>の値がfalse（つまり、<b>nil</b>または<b>false</b>）の場合、エラーを発生させます。それ以外の場合は、すべての引数を返します。エラーの場合、<code>message</code>はエラーオブジェクトです。存在しない場合は、デフォルトで"<code>assertion failed!</code>"になります。</p><p>
</p><hr /><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>この関数は、ガベージコレクタへの汎用インターフェイスです。最初の引数<code>opt</code>に従ってさまざまな関数を実行します。</p><ul>

<li><b>"<code>collect</code>": </b>完全なガベージコレクションサイクルを実行します。これはデフォルトのオプションです。</li>

<li><b>"<code>stop</code>": </b>ガベージコレクタの自動実行を停止します。コレクタは、明示的に呼び出された場合にのみ、再起動するまでの間実行されます。</li>

<li><b>"<code>restart</code>": </b>ガベージコレクタの自動実行を再開します。</li>

<li><b>"<code>count</code>": </b>Luaで使用されている総メモリをKbytes単位で返します。この値には小数部があり、1024を掛けると、Luaで使用されている正確なバイト数が得られます。</li>

<li><b>"<code>step</code>": </b>ガベージコレクションステップを実行します。ステップの「サイズ」は<code>arg</code>によって制御されます。ゼロ値の場合、コレクタは1つの基本的な（不可分な）ステップを実行します。ゼロ以外の値の場合、コレクタはLuaによってその量のメモリ（Kbytes単位）が割り当てられたかのように実行します。ステップがコレクションサイクルを終了した場合は<b>true</b>を返します。</li>

<li><b>"<code>isrunning</code>": </b>コレクタが実行中（つまり、停止していない）かどうかを示すブール値を返します。</li>

<li><b>"<code>incremental</code>": </b> コレクタモードをインクリメンタルに変更します。このオプションの後には3つの数字が続きます。ガベージコレクタの一時停止時間、ステップ乗数、ステップサイズです（<a href="#2.5.1">§2.5.1</a>を参照）。0 はその値を変更しないことを意味します。</li>

<li><b>"<code>generational</code>": </b> コレクタモードを世代別に変更します。このオプションの後には2つの数字が続きます。ガベージコレクタのマイナー乗数とメジャー乗数です（<a href="#2.5.2">§2.5.2</a>を参照）。0 はその値を変更しないことを意味します。</li>

</ul><p>ガベージコレクションとこれらのオプションの詳細については、<a href="#2.5">§2.5</a>を参照してください。</p><p>この関数はファイナライザーによって呼び出されるべきではありません。</p><p>
</p><hr /><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>指定されたファイルを開き、その内容を Lua のチャンクとして実行します。引数なしで呼び出された場合、<code>dofile</code> は標準入力 (<code>stdin</code>) の内容を実行します。チャンクから返されるすべての値を返します。エラーが発生した場合、<code>dofile</code> はそのエラーを呼び出し元に伝播します（つまり、<code>dofile</code> は保護モードでは実行されません）。<p>
</p><hr /><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3><code>message</code> をエラーオブジェクトとしてエラーを発生させます（<a href="#2.3">§2.3</a>を参照）。この関数は決して返りません。<p>通常、<code>error</code> は、メッセージが文字列の場合、メッセージの先頭にエラー位置に関する情報を追加します。<code>level</code> 引数は、エラー位置を取得する方法を指定します。level&nbsp;1（デフォルト）では、エラー位置は <code>error</code> 関数が呼び出された場所です。Level&nbsp;2 は、<code>error</code> を呼び出した関数が呼び出された場所をエラーとして示します。以降同様です。level&nbsp;0 を渡すと、メッセージへのエラー位置情報の追加を回避できます。</p><p>
</p><hr /><h3><a name="pdf-_G"><code>_G</code></a></h3>グローバル環境を保持するグローバル変数（関数ではありません）（<a href="#2.2">§2.2</a>を参照）。Lua 自体はこの変数を使用しません。その値を変更しても、どの環境にも影響しませんし、その逆も同様です。<p>
</p><hr /><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p><code>object</code> がメタテーブルを持っていない場合は、<b>nil</b> を返します。それ以外の場合で、オブジェクトのメタテーブルに <code>__metatable</code> フィールドがある場合は、関連付けられた値を返します。それ以外の場合は、指定されたオブジェクトのメタテーブルを返します。</p><p>
</p><hr /><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>3つの値（イテレータ関数、テーブル <code>t</code>、および 0）を返すため、次の構造</p><pre>     for i,v in ipairs(t) do <em>body</em> end
</pre><p>は、欠落した最初のインデックスまで、（<code>1,t[1]</code>）、（<code>2,t[2]</code>）などのキーと値のペアを反復処理します。</p><p>
</p><hr /><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>チャンクをロードします。</p><p><code>chunk</code> が文字列の場合、チャンクはこの文字列です。<code>chunk</code> が関数の場合、<code>load</code> はチャンクの断片を取得するために繰り返し呼び出します。<code>chunk</code> の各呼び出しは、以前の結果と連結する文字列を返す必要があります。空の文字列、<b>nil</b>、または値がない場合は、チャンクの終わりを示します。</p><p>構文エラーがない場合、<code>load</code> はコンパイルされたチャンクを関数として返します。それ以外の場合は、<b>fail</b> とエラーメッセージを返します。</p><p>メインチャンクをロードすると、結果の関数には常に1つのアップバリュー（<code>_ENV</code> 変数）があります（<a href="#2.2">§2.2</a>を参照）。ただし、関数から作成されたバイナリチャンクをロードした場合（<a href="#pdf-string.dump"><code>string.dump</code></a>を参照）、結果の関数は任意の数のアップバリューを持つ可能性があり、最初のアップバリューが <code>_ENV</code> 変数であるという保証はありません。（メインでない関数は <code>_ENV</code> アップバリューを持たない場合もあります。）</p><p>いずれの場合も、結果の関数にアップバリューがある場合、その最初のアップバリューは、パラメータが指定されている場合は <code>env</code> の値に設定され、それ以外の場合はグローバル環境の値に設定されます。その他のアップバリューは <b>nil</b> で初期化されます。すべてのアップバリューは新しく、他の関数とは共有されません。</p><p>
<code>chunkname</code> は、エラーメッセージおよびデバッグ情報用のチャンクの名前として使用されます（<a href="#4.7">§4.7</a>を参照）。省略した場合、<code>chunk</code> が文字列の場合は <code>chunk</code>、それ以外の場合は "<code>=(load)</code>" がデフォルトになります。</p><p>文字列 <code>mode</code> は、チャンクがテキストまたはバイナリ（つまり、プリコンパイルされたチャンク）のどちらにできるかを制御します。文字列 "<code>b</code>"（バイナリチャンクのみ）、"<code>t</code>"（テキストチャンクのみ）、または "<code>bt</code>"（バイナリとテキストの両方）にすることができます。デフォルトは "<code>bt</code>" です。</p><p>不正な形式のバイナリチャンクをロードしても安全です。<code>load</code> は適切なエラーを示します。ただし、Lua はバイナリチャンク内のコードの一貫性をチェックしません。悪意を持って作成されたバイトコードを実行すると、インタプリタがクラッシュする可能性があります。</p><p>
</p><hr /><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p><a href="#pdf-load"><code>load</code></a> と同様ですが、チャンクをファイル <code>filename</code> から、またはファイル名が指定されていない場合は標準入力から取得します。</p><p>
</p><hr /><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>プログラムがテーブルのすべてのフィールドを走査できるようにします。最初の引数はテーブルで、2番目の引数はこのテーブルのインデックスです。<code>next</code> を呼び出すと、テーブルの次のインデックスとその関連付けられた値が返されます。2番目の引数として <b>nil</b> を渡して呼び出すと、<code>next</code> は初期インデックスとその関連付けられた値を返します。最後のインデックス、または空のテーブルで <b>nil</b> を渡して呼び出すと、<code>next</code> は <b>nil</b> を返します。2番目の引数が省略された場合、<b>nil</b> として解釈されます。特に、<code>next(t)</code> を使用して、テーブルが空かどうかを確認できます。</p><p>インデックスが列挙される順序は、<em>数値インデックスであっても</em>指定されていません。（テーブルを数値順に走査するには、数値の <b>for</b> を使用します。）</p><p>走査中にテーブルの存在しないフィールドに値を代入しないでください。ただし、既存のフィールドは変更できます。特に、既存のフィールドを nil に設定できます。</p><p>
</p><hr /><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p><code>t</code> にメタメソッド <code>__pairs</code> がある場合、<code>t</code> を引数としてそれを呼び出し、呼び出しからの最初の 3 つの結果を返します。</p><p>それ以外の場合は、3 つの値を返します。 <a href="#pdf-next"><code>next</code></a> 関数、テーブル <code>t</code>、および <b>nil</b> を返すため、次の構造</p><pre>     for k,v in pairs(t) do <em>body</em> end
</pre><p>は、テーブル <code>t</code> のすべてのキーと値のペアを反復処理します。</p><p>テーブルを走査中に変更する場合の注意点については、<a href="#pdf-next"><code>next</code></a> 関数を参照してください。</p><p>
</p><hr /><h3><a name="pdf-pcall"><code>pcall (f [, arg1, ···])</code></a></h3>


<p><em>保護モード</em>で、指定された引数を使用して関数 <code>f</code> を呼び出します。これは、<code>f</code> 内のエラーが伝播されないことを意味します。代わりに、<code>pcall</code> はエラーをキャッチし、ステータスコードを返します。最初の結果はステータスコード（ブール値）であり、呼び出しがエラーなしで成功した場合は <b>true</b> です。その場合、<code>pcall</code> はこの最初の結果の後、呼び出しからのすべての結果も返します。エラーが発生した場合、<code>pcall</code> は <b>false</b> とエラーオブジェクトを返します。<code>pcall</code> によってキャッチされたエラーは、メッセージハンドラーを呼び出さないことに注意してください。</p><p>
</p><hr /><h3><a name="pdf-print"><code>print (···)</code></a></h3>任意の数の引数を受け取り、それらの値を <a href="#pdf-tostring"><code>tostring</code></a> と同じルールに従って各引数を文字列に変換し、<code>stdout</code> に出力します。<p><code>print</code> 関数は、フォーマットされた出力を目的としたものではなく、たとえばデバッグのために値をすばやく表示するためのものです。出力を完全に制御するには、<a href="#pdf-string.format"><code>string.format</code></a> と <a href="#pdf-io.write"><code>io.write</code></a> を使用してください。</p><p>
</p><hr /><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3><code>__eq</code> メタメソッドを呼び出さずに、<code>v1</code> が <code>v2</code> と等しいかどうかを確認します。ブール値を返します。<p>
</p><hr /><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3><code>__index</code> メタ値を使用せずに、<code>table[index]</code> の実際の値を取得します。<code>table</code> はテーブルである必要があります。<code>index</code> には任意の値を使用できます。<p>
</p><hr /><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3><code>__len</code> メタメソッドを呼び出さずに、テーブルまたは文字列である必要があるオブジェクト <code>v</code> の長さを返します。整数を返します。<p>
</p><hr /><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3><code>__newindex</code> メタ値を使用せずに、<code>table[index]</code> の実際の値を <code>value</code> に設定します。<code>table</code> はテーブルである必要があり、<code>index</code> は <b>nil</b> および NaN と異なる任意の値、<code>value</code> は任意の Lua 値である必要があります。<p>この関数は <code>table</code> を返します。</p><p>
</p><hr /><h3><a name="pdf-select"><code>select (index, ···)</code></a></h3>


<p><code>index</code> が数値の場合、引数番号 <code>index</code> 以降のすべての引数を返します。負の数は末尾からインデックス付けされます（-1 は最後の引数です）。それ以外の場合、<code>index</code> は文字列 <code>"#"</code> である必要があり、<code>select</code> は受信した余分な引数の合計数を返します。</p><p>
</p><hr /><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>指定されたテーブルのメタテーブルを設定します。<code>metatable</code> が <b>nil</b> の場合、指定されたテーブルのメタテーブルを削除します。元のメタテーブルに <code>__metatable</code> フィールドがある場合は、エラーが発生します。</p><p>この関数は <code>table</code> を返します。</p><p>Lua コードから他の型のメタテーブルを変更するには、デバッグライブラリを使用する必要があります（<a href="#6.10">§6.10</a>）。</p><p>
</p><hr /><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p><code>base</code> を指定せずに呼び出すと、<code>tonumber</code> は引数を数値に変換しようとします。引数がすでに数値であるか、数値に変換可能な文字列である場合、<code>tonumber</code> はこの数値を返します。それ以外の場合は、<b>fail</b> を返します。</p><p>文字列の変換は、Lua の字句規則に従って（<a href="#3.1">§3.1</a>を参照）、整数または浮動小数点数になる可能性があります。文字列には、先頭と末尾のスペースと符号を含めることができます。</p><p><code>base</code> を指定して呼び出すと、<code>e</code> はその基数で整数数値として解釈される文字列である必要があります。基数は、2〜36 の任意の整数にすることができます。10 を超える基数では、文字 '<code>A</code>'（大文字または小文字）は 10 を表し、'<code>B</code>' は 11 を表し、以下同様に '<code>Z</code>' は 35 を表します。文字列 <code>e</code> が指定された基数で有効な数値ではない場合、関数は <b>fail</b> を返します。</p><p>
</p><hr /><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>


<p>任意の型の値を受け取り、人間が読める形式の文字列に変換します。</p><p><code>v</code> のメタテーブルに <code>__tostring</code> フィールドがある場合、<code>tostring</code> は <code>v</code> を引数として対応する値を呼び出し、その呼び出しの結果を結果として使用します。それ以外の場合、<code>v</code> のメタテーブルに文字列値を持つ <code>__name</code> フィールドがある場合、<code>tostring</code> はその文字列を最終結果で使用する可能性があります。</p><p>数値がどのように変換されるかを完全に制御するには、<a href="#pdf-string.format"><code>string.format</code></a> を使用してください。</p><p>
</p><hr /><h3><a name="pdf-type"><code>type (v)</code></a></h3>


<p>唯一の引数の型を、文字列としてエンコードして返します。この関数の可能な結果は、"<code>nil</code>"（値 <b>nil</b> ではなく文字列）、"<code>number</code>"、"<code>string</code>"、"<code>boolean</code>"、"<code>table</code>"、"<code>function</code>"、"<code>thread</code>"、および "<code>userdata</code>" です。</p><p>
</p><hr /><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>


<p>実行中の Lua バージョンを含む文字列を保持するグローバル変数（関数ではありません）。この変数の現在の値は "<code>Lua 5.4</code>" です。</p><p>
</p><hr /><h3><a name="pdf-warn"><code>warn (msg1, ···)</code></a></h3>


<p>すべての引数（文字列である必要があります）の連結で構成されるメッセージを含む警告を発行します。</p><p>慣例により、'<code>@</code>' で始まる 1 つのメッセージは、警告システム自体へのメッセージである<em>制御メッセージ</em>であることを意図しています。特に、Lua の標準警告関数は、警告の出力を停止する "<code>@off</code>" と、出力を（再）開始する "<code>@on</code>" という制御メッセージを認識します。不明な制御メッセージは無視されます。</p><p>
</p><hr /><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, ···])</code></a></h3>


<p>この関数は、新しいメッセージハンドラ <code>msgh</code> を設定することを除いて、<a href="#pdf-pcall"><code>pcall</code></a> と似ています。</p><h2>6.2 – <a name="6.2">コルーチン操作</a></h2>

<p>このライブラリは、<a name="pdf-coroutine"><code>coroutine</code></a> テーブルに含まれるコルーチンを操作する操作で構成されています。コルーチンの概要については、<a href="#2.6">§2.6</a> を参照してください。</p><p>
</p><hr /><h3><a name="pdf-coroutine.close"><code>coroutine.close (co)</code></a></h3>


<p>コルーチン <code>co</code> を閉じます。つまり、保留中のクローズ対象のすべての変数を閉じ、コルーチンをデッド状態にします。指定されたコルーチンは、デッド状態または中断状態である必要があります。エラーが発生した場合（コルーチンを停止させた元のエラー、またはクローズメソッドでのエラー）、<b>false</b> とエラーオブジェクトを返します。それ以外の場合は、<b>true</b> を返します。</p><p>
</p><hr /><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>本体が <code>f</code> の新しいコルーチンを作成します。<code>f</code> は関数である必要があります。この新しいコルーチンを、タイプが <code>"thread"</code> のオブジェクトとして返します。</p><p>
</p><hr /><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ([co])</code></a></h3>


<p>コルーチン <code>co</code> が yield できる場合は <b>true</b> を返します。<code>co</code> のデフォルトは、実行中のコルーチンです。</p><p>コルーチンは、メインスレッドではなく、yield 不可能な C&nbsp;関数内にない場合に yield 可能です。</p><p>
</p><hr /><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, ···])</code></a></h3>


<p>コルーチン <code>co</code> の実行を開始または再開します。コルーチンを最初に再開すると、その本体の実行が開始されます。値 <code>val1</code>, ... は、本体関数の引数として渡されます。コルーチンが yield している場合、<code>resume</code> はそれを再起動します。値 <code>val1</code>, ... は、yield からの結果として渡されます。</p><p>コルーチンがエラーなく実行された場合、<code>resume</code> は <b>true</b> に加えて、<code>yield</code> に渡された任意の値（コルーチンが yield する場合）、または本体関数によって返された任意の値（コルーチンが終了する場合）を返します。エラーが発生した場合、<code>resume</code> は <b>false</b> とエラーメッセージを返します。</p><p>
</p><hr /><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>実行中のコルーチンとブール値を返します。実行中のコルーチンがメインのものである場合は <b>true</b> を返します。</p><p>
</p><hr /><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>コルーチン <code>co</code> のステータスを文字列として返します。コルーチンが実行中の場合（つまり、<code>status</code> を呼び出したもの）、<code>"running"</code>。コルーチンが <code>yield</code> の呼び出しで中断されている場合、またはまだ実行を開始していない場合は、<code>"suspended"</code>。コルーチンがアクティブだが実行されていない場合（つまり、別のコルーチンを再開している場合）、<code>"normal"</code>。コルーチンが本体関数を終了した場合、またはエラーで停止した場合は、<code>"dead"</code>。</p><p>
</p><hr /><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>本体が <code>f</code> の新しいコルーチンを作成します。<code>f</code> は関数である必要があります。呼び出されるたびにコルーチンを再開する関数を返します。この関数に渡された引数は、<code>resume</code> への追加引数として扱われます。この関数は、最初のブール値を除いて、<code>resume</code> によって返されるのと同じ値を返します。エラーが発生した場合、関数はコルーチンを閉じ、エラーを伝播します。</p><p>
</p><hr /><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (···)</code></a></h3>


<p>呼び出し元のコルーチンの実行を中断します。<code>yield</code> への引数は、<code>resume</code> への追加の結果として渡されます。</p><h2>6.3 – <a name="6.3">モジュール</a></h2>

<p>package ライブラリは、Lua でモジュールをロードするための基本的な機能を提供します。グローバル環境に 1 つの関数 <a href="#pdf-require"><code>require</code></a> を直接エクスポートします。他のすべては、<a name="pdf-package"><code>package</code></a> テーブルにエクスポートされます。</p><p>
</p><hr /><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>指定されたモジュールをロードします。この関数は、<a href="#pdf-package.loaded"><code>package.loaded</code></a> テーブルを調べて、<code>modname</code> がすでにロードされているかどうかを判断することから開始します。ロードされている場合、<code>require</code> は <code>package.loaded[modname]</code> に格納されている値を返します。（この場合、2 番目の結果がないことは、この呼び出しがモジュールをロードする必要がなかったことを示します。）それ以外の場合は、モジュールの<em>ローダー</em>を検索しようとします。</p><p>ローダーを検索するために、<code>require</code> は <a href="#pdf-package.searchers"><code>package.searchers</code></a> テーブルによってガイドされます。このテーブルの各項目は検索関数であり、特定の方法でモジュールを検索します。このテーブルを変更することにより、<code>require</code> がモジュールを検索する方法を変更できます。以下の説明は、<a href="#pdf-package.searchers"><code>package.searchers</code></a> のデフォルト構成に基づいています。</p><p>まず、<code>require</code> は <code>package.preload[modname]</code> をクエリします。値がある場合、この値（関数である必要があります）がローダーです。それ以外の場合、<code>require</code> は <a href="#pdf-package.path"><code>package.path</code></a> に格納されているパスを使用して Lua ローダーを検索します。それも失敗した場合、<a href="#pdf-package.cpath"><code>package.cpath</code></a> に格納されているパスを使用して C&nbsp;ローダーを検索します。それも失敗した場合、<em>オールインワン</em>ローダーを試みます（<a href="#pdf-package.searchers"><code>package.searchers</code></a> を参照）。</p><p>ローダーが見つかると、<code>require</code> はローダーを 2 つの引数、<code>modname</code> と追加の値（<em>ローダーデータ</em>）を付けて呼び出します。ローダーデータは、モジュールにとって有用な任意の値を指定できます。デフォルトの検索機能の場合、ローダーが見つかった場所を示します。（たとえば、ローダーがファイルから来た場合、この追加の値はファイルパスです。）ローダーが nil 以外の値を返す場合、<code>require</code> は返された値を <code>package.loaded[modname]</code> に割り当てます。ローダーが nil 以外の値を返さず、<code>package.loaded[modname]</code> に値を割り当てていない場合、<code>require</code> はこのエントリに <b>true</b> を割り当てます。いずれの場合も、<code>require</code> は <code>package.loaded[modname]</code> の最終値を返します。その値に加えて、<code>require</code> は 2 番目の結果として、検索機能によって返されたローダーデータも返します。これは、<code>require</code> がモジュールをどのように見つけたかを示します。</p><p>モジュールのロードまたは実行中にエラーが発生した場合、またはモジュールのローダーが見つからない場合、<code>require</code> はエラーを発生させます。</p><p>
</p><hr /><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>パッケージのコンパイル時の構成を記述する文字列。この文字列は、行のシーケンスです。</p><ul>

<li>最初の行は、ディレクトリ区切り文字の文字列です。デフォルトは、Windows の場合は '<code>\</code>'、他のすべてのシステムの場合は '<code>/</code>' です。</li>

<li>2 番目の行は、パス内のテンプレートを区切る文字です。デフォルトは '<code>;</code>' です。</li>

<li>3 番目の行は、テンプレート内の置換ポイントをマークする文字列です。デフォルトは '<code>?</code>' です。</li>

<li>4 番目の行は、Windows のパスで、実行可能ファイルのディレクトリに置き換えられる文字列です。デフォルトは '<code>!</code>' です。</li>

<li>5 番目の行は、<code>luaopen_</code> 関数名を構築するときに、その後のすべてのテキストを無視するためのマークです。デフォルトは '<code>-</code>' です。</li>

</ul>



<p>
</p><hr /><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p><a href="#pdf-require"><code>require</code></a> が C&nbsp;ローダーを検索するために使用するパスを含む文字列。</p><p>Lua は、環境変数 <a name="pdf-LUA_CPATH_5_4"><code>LUA_CPATH_5_4</code></a>、または環境変数 <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>、または <code>luaconf.h</code> で定義されたデフォルトのパスを使用して、Lua パス <a href="#pdf-package.path"><code>package.path</code></a> を初期化するのと同じ方法で C&nbsp;パス <a href="#pdf-package.cpath"><code>package.cpath</code></a> を初期化します。</p><p>
</p><hr /><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p><a href="#pdf-require"><code>require</code></a> がすでにロードされているモジュールを制御するために使用するテーブル。モジュール <code>modname</code> を require するとき、<code>package.loaded[modname]</code> が false でない場合、<a href="#pdf-require"><code>require</code></a> はそこに格納されている値を返します。</p><p>この変数は、実際のテーブルへの参照にすぎません。この変数への代入は、<a href="#pdf-require"><code>require</code></a> が使用するテーブルを変更しません。実際のテーブルは、C レジストリ（<a href="#4.3">§4.3</a> を参照）に格納され、キー <a name="pdf-LUA_LOADED_TABLE"><code>LUA_LOADED_TABLE</code></a>（文字列）でインデックス付けされます。</p><p>
</p><hr /><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>ホストプログラムを C&nbsp;ライブラリ <code>libname</code> に動的にリンクします。</p><p><code>funcname</code> が "<code>*</code>" の場合、ライブラリへのリンクのみを行い、ライブラリによってエクスポートされたシンボルを、動的にリンクされた他のライブラリで使用できるようにします。それ以外の場合は、ライブラリ内の関数 <code>funcname</code> を検索し、この関数を C&nbsp;関数として返します。したがって、<code>funcname</code> は <a href="#lua_CFunction"><code>lua_CFunction</code></a> プロトタイプ（<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照）に従う必要があります。</p><p>これは低レベルの関数です。パッケージおよびモジュールシステムを完全にバイパスします。<a href="#pdf-require"><code>require</code></a> とは異なり、パス検索を実行せず、拡張子を自動的に追加しません。<code>libname</code> は、必要に応じてパスと拡張子を含む、C&nbsp;ライブラリの完全なファイル名である必要があります。<code>funcname</code> は、C&nbsp;ライブラリによってエクスポートされた正確な名前である必要があります（これは、使用される C&nbsp;コンパイラーとリンカーによって異なる場合があります）。</p><p>この機能は ISO&nbsp;C ではサポートされていません。そのため、一部のプラットフォーム（Windows、Linux、Mac OS X、Solaris、BSD、および <code>dlfcn</code> 標準をサポートするその他の Unix システム）でのみ使用できます。</p><p>この関数は本質的に安全ではありません。Lua がシステムの読み取り可能な動的ライブラリ内の任意の関数を呼び出すことができるためです。（Lua は、関数が適切なプロトタイプを持ち、適切なプロトコル（<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照）を尊重すると仮定して、任意の関数を呼び出します。したがって、任意の動的ライブラリ内の任意の関数を呼び出すと、多くの場合、アクセス違反が発生します。）</p><p>
</p><hr /><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p><a href="#pdf-require"><code>require</code></a> が Lua ローダーを検索するために使用するパスを含む文字列。</p><p>起動時に、Lua は環境変数 <a name="pdf-LUA_PATH_5_4"><code>LUA_PATH_5_4</code></a> または環境変数 <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> の値、またはこれらの環境変数が定義されていない場合は <code>luaconf.h</code> で定義されたデフォルトのパスを使用して、この変数を初期化します。環境変数の値の "<code>;;</code>" は、デフォルトのパスに置き換えられます。</p><p>
</p><hr /><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>特定のモジュールのローダーを格納するテーブル（<a href="#pdf-require"><code>require</code></a> を参照）。</p><p>この変数は、実際のテーブルへの参照にすぎません。この変数への代入は、<a href="#pdf-require"><code>require</code></a> が使用するテーブルを変更しません。実際のテーブルは、C レジストリ（<a href="#4.3">§4.3</a> を参照）に格納され、キー <a name="pdf-LUA_PRELOAD_TABLE"><code>LUA_PRELOAD_TABLE</code></a>（文字列）でインデックス付けされます。</p><p>
</p><hr /><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p><a href="#pdf-require"><code>require</code></a> がモジュールを検索する方法を制御するために使用するテーブル。</p><p>このテーブルの各エントリは、<em>検索関数</em>です。モジュールを検索するとき、<a href="#pdf-require"><code>require</code></a> はこれらの検索関数を昇順で呼び出し、モジュール名（<a href="#pdf-require"><code>require</code></a> に指定された引数）を唯一の引数として指定します。検索機能がモジュールを見つけた場合、モジュール<em>ローダー</em>である別の関数と、ローダーに渡され、<a href="#pdf-require"><code>require</code></a> によって 2 番目の結果として返される追加の値（<em>ローダーデータ</em>）を返します。モジュールが見つからない場合は、理由を説明する文字列（または何も言うことがない場合は <b>nil</b>）を返します。</p><p>Lua は、このテーブルを 4 つの検索関数で初期化します。</p><p>最初の検索機能は、<a href="#pdf-package.preload"><code>package.preload</code></a> テーブルでローダーを探すだけです。</p><p>2 番目の検索機能は、<a href="#pdf-package.path"><code>package.path</code></a> に格納されているパスを使用して、Lua ライブラリとしてローダーを探します。検索は、関数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> で説明されているように行われます。</p><p>3 番目の検索機能は、変数 <a href="#pdf-package.cpath"><code>package.cpath</code></a> によって指定されたパスを使用して、C&nbsp;ライブラリとしてローダーを探します。ここでも、検索は関数 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> で説明されているように行われます。たとえば、C&nbsp;パスが文字列の場合</p><pre>     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>モジュール<code>foo</code>の検索器は、<code>./foo.so</code>、<code>./foo.dll</code>、および<code>/usr/local/foo/init.so</code>の順にファイルを開こうとします。Cライブラリが見つかると、この検索器はまず動的リンク機能を使用してアプリケーションをライブラリにリンクします。次に、ローダーとして使用されるライブラリ内のC関数を見つけようとします。このC関数の名前は、文字列"<code>luaopen_</code>"に、モジュール名のコピーを連結したもので、そのコピーでは、すべてのドットがアンダースコアに置き換えられています。さらに、モジュール名にハイフンが含まれている場合、最初のハイフン以降のサフィックス（ハイフンを含む）は削除されます。たとえば、モジュール名が<code>a.b.c-v2.1</code>の場合、関数名は<code>luaopen_a_b_c</code>になります。</p><p>4番目の検索器は、<em>オールインワンローダー</em>を試します。指定されたモジュールのルート名のライブラリをCパスで検索します。たとえば、<code>a.b.c</code>を要求する場合、<code>a</code>のCライブラリを検索します。見つかった場合、サブモジュールのopen関数を検索します。この例では、<code>luaopen_a_b_c</code>になります。この機能を使用すると、パッケージは複数のCサブモジュールを1つのライブラリにまとめることができ、各サブモジュールは元のopen関数を保持します。</p><p>最初の検索器（preload）を除くすべての検索器は、<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>によって返されるように、モジュールが見つかったファイルパスを余分な値として返します。最初の検索器は常に文字列"<code>:preload:</code>"を返します。</p><p>検索器は、Luaでエラーを発生させたり、副作用を持ったりしてはなりません。（Cでは、たとえばアプリケーションをライブラリにリンクするなど、副作用を持つ場合があります。）</p><p>
</p><hr /><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>指定された<code>path</code>内で、指定された<code>name</code>を検索します。</p><p>パスは、セミコロンで区切られた<em>テンプレート</em>のシーケンスを含む文字列です。各テンプレートについて、関数はテンプレート内の各疑問符（もしあれば）を、<code>name</code>のコピーで置き換えます。そのコピーでは、<code>sep</code>（デフォルトではドット）のすべての出現箇所が<code>rep</code>（デフォルトではシステムのディレクトリセパレーター）に置き換えられ、結果として得られたファイル名を開こうとします。</p><p>たとえば、パスが次の文字列の場合</p><pre>     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>名前<code>foo.a</code>の検索では、ファイル<code>./foo/a.lua</code>、<code>./foo/a.lc</code>、および<code>/usr/local/foo/a/init.lua</code>がこの順に開こうとします。</p><p>読み取りモードで開くことができる最初のファイルの結果の名前（ファイルを閉じた後）を返すか、成功しない場合は、<b>fail</b>とエラーメッセージを返します。（このエラーメッセージは、開こうとしたすべてのファイル名をリストします。）</p><h2>6.4 – <a name="6.4">文字列操作</a></h2>



<p>このライブラリは、部分文字列の検索や抽出、パターンマッチングなど、文字列操作のための汎用関数を提供します。Luaで文字列をインデックス付けする場合、最初の文字は位置1にあります（Cのように0ではありません）。インデックスは負の値にすることもでき、文字列の末尾から後方に向かってインデックス付けされていると解釈されます。したがって、最後の文字は位置-1にあり、以下同様です。</p><p>文字列ライブラリは、テーブル<a name="pdf-string"><code>string</code></a>内にすべての関数を提供します。また、<code>__index</code>フィールドが<code>string</code>テーブルを指す文字列のメタテーブルも設定します。したがって、オブジェクト指向スタイルで文字列関数を使用できます。たとえば、<code>string.byte(s,i)</code>は<code>s:byte(i)</code>と記述できます。</p><p>文字列ライブラリは、1バイトの文字エンコードを前提としています。</p><p>
</p><hr /><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>文字<code>s[i]</code>、<code>s[i+1]</code>、...、<code>s[j]</code>の内部数値コードを返します。<code>i</code>のデフォルト値は1です。<code>j</code>のデフォルト値は<code>i</code>です。これらのインデックスは、関数<a href="#pdf-string.sub"><code>string.sub</code></a>の同じルールに従って修正されます。<p>数値コードは、プラットフォーム間で必ずしも移植可能ではありません。</p><p>
</p><hr /><h3><a name="pdf-string.char"><code>string.char (···)</code></a></h3>ゼロ個以上の整数を受け取ります。引数の数と同じ長さの文字列を返します。各文字には、対応する引数に等しい内部数値コードがあります。<p>数値コードは、プラットフォーム間で必ずしも移植可能ではありません。</p><p>
</p><hr /><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>


<p>指定された関数のバイナリ表現（<em>バイナリチャンク</em>）を含む文字列を返します。これにより、この文字列の後の<a href="#pdf-load"><code>load</code></a>は、関数のコピー（ただし、新しいアップ値付き）を返します。<code>strip</code>が真の値である場合、バイナリ表現には、スペースを節約するために、関数に関するすべてのデバッグ情報が含まれない場合があります。</p><p>アップ値を持つ関数には、アップ値の数のみが保存されます。ロード（再ロード）されると、これらのアップ値は新しいインスタンスを受け取ります。（これらのアップ値がどのように初期化されるかについての詳細は、<a href="#pdf-load"><code>load</code></a>関数を参照してください。デバッグライブラリを使用して、必要に応じて関数のアップ値をシリアル化および再ロードできます。）</p><p>
</p><hr /><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>文字列<code>s</code>内の<code>pattern</code>（<a href="#6.4.1">§6.4.1</a>を参照）の最初のマッチを検索します。マッチが見つかった場合、<code>find</code>はこの出現の開始と終了の<code>s</code>のインデックスを返します。それ以外の場合は、<b>fail</b>を返します。3番目のオプションの数値引数<code>init</code>は、検索を開始する場所を指定します。デフォルト値は1であり、負の値にすることができます。4番目のオプションの引数<code>plain</code>として<b>true</b>を指定すると、パターンマッチング機能が無効になり、関数は<code>pattern</code>内の文字がマジックと見なされない、プレーンな「部分文字列の検索」操作を実行します。</p><p>パターンにキャプチャがある場合、マッチが成功すると、キャプチャされた値も2つのインデックスの後ろに返されます。</p><p>
</p><hr /><h3><a name="pdf-string.format"><code>string.format (formatstring, ···)</code></a></h3>


<p>最初の引数（文字列である必要があります）に指定された説明に従って、可変数の引数の書式設定されたバージョンを返します。フォーマット文字列は、ISO&nbsp;C関数<code>sprintf</code>と同じルールに従います。唯一の違いは、変換指定子と修飾子<code>F</code>、<code>n</code>、<code>*</code>、<code>h</code>、<code>L</code>、および<code>l</code>がサポートされておらず、追加の指定子<code>q</code>があることです。幅と精度は、存在する場合、どちらも2桁に制限されます。</p><p>指定子<code>q</code>は、ブール値、nil、数値、および文字列を、結果がLuaソースコードで有効な定数になるようにフォーマットします。ブール値とnilは、明白な方法（<code>true</code>、<code>false</code>、<code>nil</code>）で記述されます。浮動小数点数は、完全な精度を維持するために16進数で記述されます。文字列は二重引用符で囲まれ、必要に応じてエスケープシーケンスを使用して、Luaインタープリターで安全に読み戻せるようにします。たとえば、呼び出し</p><pre>     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>は、文字列を生成する可能性があります</p><pre>     "a string with \"quotes\" and \
      new line"
</pre><p>この指定子は、修飾子（フラグ、幅、精度）をサポートしていません。</p><p>変換指定子<code>A</code>、<code>a</code>、<code>E</code>、<code>e</code>、<code>f</code>、<code>G</code>、および<code>g</code>はすべて、引数として数値を予期します。指定子<code>c</code>、<code>d</code>、<code>i</code>、<code>o</code>、<code>u</code>、<code>X</code>、および<code>x</code>は、整数を予期します。LuaがC89コンパイラーでコンパイルされている場合、指定子<code>A</code>および<code>a</code>（16進浮動小数点）は修飾子をサポートしません。</p><p>指定子<code>s</code>は文字列を予期します。引数が文字列でない場合は、<a href="#pdf-tostring"><code>tostring</code></a>の同じルールに従って文字列に変換されます。指定子に修飾子がある場合、対応する文字列引数に埋め込まれたゼロを含めることはできません。</p><p>指定子<code>p</code>は、<a href="#lua_topointer"><code>lua_topointer</code></a>によって返されるポインターを書式設定します。これにより、テーブル、userdata、スレッド、文字列、および関数の一意の文字列識別子が与えられます。他の値（数値、nil、ブール値）の場合、この指定子はポインター<code>NULL</code>を表す文字列になります。</p><p>
</p><hr /><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern [, init])</code></a></h3>呼び出されるたびに、文字列<code>s</code>を対象とした<code>pattern</code>（<a href="#6.4.1">§6.4.1</a>を参照）からの次のキャプチャを返すイテレータ関数を返します。<code>pattern</code>がキャプチャを指定しない場合、各呼び出しでマッチ全体が生成されます。3番目のオプションの数値引数<code>init</code>は、検索を開始する場所を指定します。デフォルト値は1であり、負の値にすることができます。<p>例として、次のループは、文字列<code>s</code>のすべての単語を反復処理し、1行に1つずつ出力します。</p><pre>     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>次の例では、指定された文字列からすべての<code>key=value</code>ペアをテーブルに収集します</p><pre>     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>この関数では、パターンの先頭にあるキャレット '<code>^</code>'はアンカーとして機能しません。これは反復処理を妨げるためです。</p><p>
</p><hr /><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3><code>s</code>のコピーを返します。その中で、<code>pattern</code>（<a href="#6.4.1">§6.4.1</a>を参照）のすべて（または指定された場合は最初の<code>n</code>）の出現が、<code>repl</code>で指定された置換文字列に置き換えられています。<code>repl</code>は、文字列、テーブル、または関数にすることができます。<code>gsub</code>はまた、2番目の値として、発生したマッチの合計数も返します。<code>gsub</code>という名前は、<em>Global SUBstitution</em>から来ています。<p><code>repl</code>が文字列の場合、その値は置換に使用されます。文字&nbsp;<code>%</code>はエスケープ文字として機能します。<code>repl</code>内の<code>%<em>d</em></code>形式のシーケンス（<em>d</em>は1から9の間）は、<em>d</em>番目のキャプチャされた部分文字列の値を表します。シーケンス<code>%0</code>は、マッチ全体を表します。シーケンス<code>%%</code>は、単一の&nbsp;<code>%</code>を表します。</p><p><code>repl</code>がテーブルの場合、テーブルは、最初のキャプチャをキーとして使用して、すべてのマッチに対してクエリされます。</p><p><code>repl</code>が関数の場合、この関数は、マッチが発生するたびに、キャプチャされたすべての部分文字列を引数として渡して呼び出されます。</p><p>いずれの場合も、パターンがキャプチャを指定しない場合は、パターン全体がキャプチャ内にあるかのように動作します。</p><p>テーブルクエリまたは関数呼び出しによって返される値が文字列または数値の場合、置換文字列として使用されます。それ以外の場合、<b>false</b>または<b>nil</b>の場合、置換はありません（つまり、元のマッチは文字列に保持されます）。</p><p>以下に例をいくつか示します</p><pre>     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.4"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.4.tar.gz"
</pre>



<p>
</p><hr /><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>


<p>文字列を受け取り、その長さを返します。空の文字列<code>""</code>の長さは0です。埋め込まれたゼロがカウントされるため、<code>"a\000bc\000"</code>の長さは5です。</p><p>
</p><hr /><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>


<p>文字列を受け取り、すべてのuppercaseの文字がlowercaseに変更された、この文字列のコピーを返します。他のすべての文字は変更されません。uppercaseの文字の定義は、現在のロケールに依存します。</p><p>
</p><hr /><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>


<p>文字列<code>s</code>の中で、<code>pattern</code>（<a href="#6.4.1">§6.4.1</a>を参照）に最初に<em>マッチ</em>する箇所を探します。マッチするものが見つかった場合、<code>match</code>はパターンからのキャプチャを返します。それ以外の場合は<b>fail</b>を返します。<code>pattern</code>がキャプチャを指定しない場合は、マッチ全体が返されます。3番目のオプションの数値引数<code>init</code>は、検索を開始する位置を指定します。デフォルト値は1で、負の値も指定できます。</p><p>
</p><hr /><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, ···)</code></a></h3>


<p>フォーマット文字列<code>fmt</code>（<a href="#6.4.2">§6.4.2</a>を参照）に従って、バイナリ形式でシリアライズ（パック）された値<code>v1</code>、<code>v2</code>などを含むバイナリ文字列を返します。</p><p>
</p><hr /><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>


<p><a href="#pdf-string.pack"><code>string.pack</code></a>を、与えられたフォーマットで実行した場合の結果の文字列の長さを返します。フォーマット文字列は、可変長オプションである'<code>s</code>'または'<code>z</code>'を持つことはできません（<a href="#6.4.2">§6.4.2</a>を参照）。</p><p>
</p><hr /><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>


<p>文字列<code>s</code>を<code>n</code>回コピーし、文字列<code>sep</code>で区切って連結した文字列を返します。<code>sep</code>のデフォルト値は空文字列です（つまり、区切り文字なし）。<code>n</code>が正でない場合は、空文字列を返します。</p><p>（この関数を1回呼び出すだけで、マシンのメモリを使い果たしてしまう可能性があることに注意してください。）</p><p>
</p><hr /><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>


<p>文字列<code>s</code>を反転させた文字列を返します。</p><p>
</p><hr /><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>


<p><code>i</code>から始まり<code>j</code>まで続く、<code>s</code>の部分文字列を返します。<code>i</code>と<code>j</code>は負の値を取ることができます。<code>j</code>が省略された場合、-1（文字列の長さと同じ）とみなされます。特に、<code>string.sub(s,1,j)</code>の呼び出しは、長さ<code>j</code>の<code>s</code>の接頭辞を返し、<code>string.sub(s, -i)</code>（正の<code>i</code>の場合）は、長さ<code>i</code>の<code>s</code>の接尾辞を返します。</p><p>負のインデックスの変換後、<code>i</code>が1未満の場合は1に修正されます。<code>j</code>が文字列の長さよりも大きい場合は、文字列の長さに修正されます。これらの修正後、<code>i</code>が<code>j</code>よりも大きい場合、関数は空文字列を返します。</p><p>
</p><hr /><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>


<p>フォーマット文字列<code>fmt</code>（<a href="#6.4.2">§6.4.2</a>を参照）に従って、文字列<code>s</code>にパックされた値（<a href="#pdf-string.pack"><code>string.pack</code></a>を参照）を返します。オプションの<code>pos</code>は、<code>s</code>の読み取りを開始する位置を示します（デフォルトは1）。読み取られた値の後、この関数は<code>s</code>内で最初に読み取られていないバイトのインデックスも返します。</p><p>
</p><hr /><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>


<p>文字列を受け取り、この文字列のすべての小文字を大文字に変更したコピーを返します。他のすべての文字は変更されません。小文字の定義は、現在のロケールによって異なります。</p><h3>6.4.1 – <a name="6.4.1">パターン</a></h3>



<p>Luaのパターンは、正規の文字列で記述され、パターンマッチング関数である<a href="#pdf-string.find"><code>string.find</code></a>、<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>、<a href="#pdf-string.gsub"><code>string.gsub</code></a>、および<a href="#pdf-string.match"><code>string.match</code></a>によってパターンとして解釈されます。このセクションでは、これらの文字列の構文と意味（つまり、何にマッチするか）について説明します。</p><h4>文字クラス</h4><p><em>文字クラス</em>は、文字の集合を表すために使用されます。文字クラスを記述する際には、以下の組み合わせが許可されています。</p><ul>

<li><b><em>x</em>: </b>（<em>x</em>が<em>マジック文字</em>である<code>^$()%.[]*+-?</code>のいずれでもない場合）文字<em>x</em>自体を表します。</li>

<li><b><code>.</code>: </b>（ドット）はすべての文字を表します。</li>

<li><b><code>%a</code>: </b>はすべてのアルファベット文字を表します。</li>

<li><b><code>%c</code>: </b>はすべての制御文字を表します。</li>

<li><b><code>%d</code>: </b>はすべての数字を表します。</li>

<li><b><code>%g</code>: </b>はスペースを除くすべての印刷可能な文字を表します。</li>

<li><b><code>%l</code>: </b>はすべての小文字を表します。</li>

<li><b><code>%p</code>: </b>はすべての句読点を表します。</li>

<li><b><code>%s</code>: </b>はすべての空白文字を表します。</li>

<li><b><code>%u</code>: </b>はすべての大文字を表します。</li>

<li><b><code>%w</code>: </b>はすべての英数字を表します。</li>

<li><b><code>%x</code>: </b>はすべての16進数を表します。</li>

<li><b><code>%<em>x</em></code>: </b>（<em>x</em>が任意の非英数字の場合）文字<em>x</em>を表します。これは、マジック文字をエスケープする標準的な方法です。任意の非英数字（すべての句読点文字、さらには非マジック文字も含む）の前に '<code>%</code>' を付けて、パターン内でそれ自体を表すことができます。</li>

<li><b><code>[<em>set</em>]</code>: </b>は、<em>set</em>内のすべての文字の和集合であるクラスを表します。文字の範囲は、範囲の終端文字を昇順で '<code>-</code>' で区切って指定できます。上記で説明したすべてのクラス<code>%</code><em>x</em>も、<em>set</em>内のコンポーネントとして使用できます。<em>set</em>内の他のすべての文字は、それ自体を表します。たとえば、<code>[%w_]</code>（または<code>[_%w]</code>）はすべての英数字とアンダースコアを表し、<code>[0-7]</code>は8進数を表し、<code>[0-7%l%-]</code>は8進数と小文字と '<code>-</code>' 文字を表します。<p>セット内に閉じ角括弧を配置するには、セット内の最初の文字として配置します。セット内にハイフンを配置するには、セット内の最初または最後の文字として配置します。（両方の場合にエスケープを使用することもできます。）</p><p>範囲とクラスの間の相互作用は定義されていません。したがって、<code>[%a-z]</code>や<code>[a-%%]</code>のようなパターンには意味がありません。</p></li>

<li><b><code>[^<em>set</em>]</code>: </b>は、<em>set</em>の補数を表します。ここで、<em>set</em>は上記のように解釈されます。</li>

</ul><p>単一の文字で表されるすべてのクラス（<code>%a</code>、<code>%c</code>など）の場合、対応する大文字はクラスの補数を表します。たとえば、<code>%S</code>は空白以外のすべての文字を表します。</p><p>文字、スペース、その他の文字グループの定義は、現在のロケールによって異なります。特に、クラス<code>[a-z]</code>は<code>%l</code>と等価ではない場合があります。</p><h4>パターン項目</h4><p><em>パターン項目</em>は次のいずれかです。</p><ul>

<li>単一の文字クラス。クラス内の任意の単一の文字にマッチします。</li>

<li>単一の文字クラスの後に '<code>*</code>' が続く場合。クラス内のゼロ個以上の文字のシーケンスにマッチします。これらの繰り返し項目は、常に可能な限り最長のシーケンスにマッチします。</li>

<li>単一の文字クラスの後に '<code>+</code>' が続く場合。クラス内の1つ以上の文字のシーケンスにマッチします。これらの繰り返し項目は、常に可能な限り最長のシーケンスにマッチします。</li>

<li>単一の文字クラスの後に '<code>-</code>' が続く場合。これも、クラス内のゼロ個以上の文字のシーケンスにマッチします。 '<code>*</code>' とは異なり、これらの繰り返し項目は、常に可能な限り最短のシーケンスにマッチします。</li>

<li>単一の文字クラスの後に '<code>?</code>' が続く場合。クラス内の文字のゼロ個または1個の出現にマッチします。可能な場合は常に1つの出現にマッチします。</li>

<li>
<code>%<em>n</em></code>（<em>n</em>は1から9の間）。このような項目は、<em>n</em>番目のキャプチャされた文字列と等しい部分文字列にマッチします（以下を参照）。</li>

<li>
<code>%b<em>xy</em></code>。ここで、<em>x</em>と<em>y</em>は2つの異なる文字です。このような項目は、<em>x</em>で始まり、<em>y</em>で終わり、<em>x</em>と<em>y</em>が<em>バランス</em>している文字列にマッチします。これは、文字列を左から右に読み、<em>x</em>の場合は<em>+1</em>、<em>y</em>の場合は<em>-1</em>を数えた場合、最後の<em>y</em>はカウントが0に達する最初の<em>y</em>であることを意味します。たとえば、項目<code>%b()</code>は、バランスの取れた括弧を持つ式にマッチします。</li>

<li>
<code>%f[<em>set</em>]</code>。<em>フロンティアパターン</em>です。このような項目は、次の文字が<em>set</em>に属し、前の文字が<em>set</em>に属さないような任意の場所にある空文字列にマッチします。セット<em>set</em>は、上記のように解釈されます。サブジェクトの先頭と末尾は、文字 '<code>\0</code>' であるかのように処理されます。</li>

</ul>




<h4>パターン</h4><p><em>パターン</em>は、パターン項目のシーケンスです。パターンの先頭にあるキャレット '<code>^</code>' は、マッチをサブジェクト文字列の先頭に固定します。パターンの末尾にある '<code>$</code>' は、マッチをサブジェクト文字列の末尾に固定します。他の位置では、'<code>^</code>' と '<code>$</code>' は特別な意味を持たず、それ自身を表します。</p><h4>キャプチャ</h4><p>パターンには、括弧で囲まれたサブパターンを含めることができます。これらは<em>キャプチャ</em>を記述します。マッチが成功すると、キャプチャにマッチするサブジェクト文字列の部分文字列が、後で使用するために保存（<em>キャプチャ</em>）されます。キャプチャは、左括弧に従って番号が付けられます。たとえば、パターン<code>"(a*(.)%w(%s*))"</code>では、<code>"a*(.)%w(%s*)"</code>にマッチする文字列の部分が最初のキャプチャとして保存されるため、番号は1になります。 "<code>.</code>"にマッチする文字は番号2でキャプチャされ、"<code>%s*</code>"にマッチする部分は番号3でキャプチャされます。</p><p>特別なケースとして、キャプチャ<code>()</code>は現在の文字列位置（数値）をキャプチャします。たとえば、文字列<code>"flaaap"</code>にパターン<code>"()aa()"</code>を適用した場合、2つのキャプチャ（3と5）が得られます。</p><h4>複数マッチ</h4><p>関数<a href="#pdf-string.gsub"><code>string.gsub</code></a>とイテレータ<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>は、サブジェクト内の指定されたパターンの複数の出現箇所にマッチします。これらの関数では、新しいマッチは、前のマッチの終了位置よりも少なくとも1バイト後で終了する場合にのみ有効と見なされます。言い換えれば、パターンマシンは、別のマッチの直後に空文字列をマッチとして受け入れることはありません。例として、次のコードの結果を考えてみましょう。</p><pre>     &gt; string.gsub("abc", "()a*()", print);
     --&gt; 1   2
     --&gt; 3   3
     --&gt; 4   4
</pre><p>2番目と3番目の結果は、Luaが '<code>b</code>' の後と '<code>c</code>' の後で空文字列にマッチしたことによるものです。Luaは '<code>a</code>' の後に空文字列をマッチさせません。なぜなら、それは前のマッチと同じ位置で終了するためです。</p><h3>6.4.2 – <a name="6.4.2">PackおよびUnpackのフォーマット文字列</a></h3>

<p><a href="#pdf-string.pack"><code>string.pack</code></a>、<a href="#pdf-string.packsize"><code>string.packsize</code></a>、および<a href="#pdf-string.unpack"><code>string.unpack</code></a>の最初の引数はフォーマット文字列であり、作成または読み取られる構造のレイアウトを記述します。</p><p>フォーマット文字列は、変換オプションのシーケンスです。変換オプションは次のとおりです。</p><ul>
<li><b><code>&lt;</code>: </b>リトルエンディアンを設定します</li>
<li><b><code>&gt;</code>: </b>ビッグエンディアンを設定します</li>
<li><b><code>=</code>: </b>ネイティブエンディアンを設定します</li>
<li><b><code>![<em>n</em>]</code>: </b>最大アライメントを<code>n</code>に設定します（デフォルトはネイティブアライメント）</li>
<li><b><code>b</code>: </b>符号付きバイト（<code>char</code>）</li>
<li><b><code>B</code>: </b>符号なしバイト（<code>char</code>）</li>
<li><b><code>h</code>: </b>符号付き<code>short</code>（ネイティブサイズ）</li>
<li><b><code>H</code>: </b>符号なし<code>short</code>（ネイティブサイズ）</li>
<li><b><code>l</code>: </b>符号付き<code>long</code>（ネイティブサイズ）</li>
<li><b><code>L</code>: </b>符号なし<code>long</code>（ネイティブサイズ）</li>
<li><b><code>j</code>: </b><code>lua_Integer</code></li>
<li><b><code>J</code>: </b><code>lua_Unsigned</code></li>
<li><b><code>T</code>: </b><code>size_t</code>（ネイティブサイズ）</li>
<li><b><code>i[<em>n</em>]</code>: </b><code>n</code>バイトの符号付き<code>int</code>（デフォルトはネイティブサイズ）</li>
<li><b><code>I[<em>n</em>]</code>: </b><code>n</code>バイトの符号なし<code>int</code>（デフォルトはネイティブサイズ）</li>
<li><b><code>f</code>: </b><code>float</code>（ネイティブサイズ）</li>
<li><b><code>d</code>: </b><code>double</code>（ネイティブサイズ）</li>
<li><b><code>n</code>: </b><code>lua_Number</code></li>
<li><b><code>c<em>n</em></code>: </b><code>n</code>バイトの固定長文字列</li>
<li><b><code>z</code>: </b>ゼロ終端文字列</li>
<li><b><code>s[<em>n</em>]</code>: </b>長さが<code>n</code>バイトの符号なし整数としてコード化された長さが前に付いた文字列（デフォルトは<code>size_t</code>）</li>
<li><b><code>x</code>: </b>1バイトのパディング</li>
<li><b><code>X<em>op</em></code>: </b>オプション<code>op</code>に従ってアライメントする空の項目（それ以外の場合は無視されます）</li>
<li><b>'<code> </code>': </b>（スペース）無視されます</li>
</ul><p>（"<code>[<em>n</em>]</code>" はオプションの整数を意味します。）パディング、スペース、および構成（オプション"<code>xX &lt;=&gt;!</code>"）を除き、各オプションは、<a href="#pdf-string.pack"><code>string.pack</code></a>の引数または<a href="#pdf-string.unpack"><code>string.unpack</code></a>の結果に対応します。</p><p>オプション "<code>!<em>n</em></code>", "<code>s<em>n</em></code>", "<code>i<em>n</em></code>", および "<code>I<em>n</em></code>" では、<code>n</code> は 1 から 16 までの任意の整数です。すべての整数オプションはオーバーフローをチェックします。 <a href="#pdf-string.pack"><code>string.pack</code></a> は、指定された値が指定されたサイズに収まるかどうかをチェックし、<a href="#pdf-string.unpack"><code>string.unpack</code></a> は、読み取った値が Lua 整数に収まるかどうかをチェックします。符号なしオプションの場合、Lua 整数も符号なしの値として扱われます。</p><p>任意のフォーマット文字列は、"<code>!1=</code>" が前に付いているかのように開始します。つまり、最大アライメントが 1（アライメントなし）で、ネイティブエンディアンで開始します。</p><p>ネイティブエンディアンは、システム全体がビッグエンディアンまたはリトルエンディアンのいずれかであると想定します。パッキング関数は、混合エンディアンフォーマットの動作を正しくエミュレートしません。</p><p>アライメントは次のように機能します。各オプションについて、フォーマットは、データの開始オフセットがオプションサイズと最大アライメントの最小値の倍数になるまで、追加のパディングを取得します。この最小値は 2 のべき乗である必要があります。オプション "<code>c</code>" および "<code>z</code>" はアラインされません。オプション "<code>s</code>" は、開始整数のアライメントに従います。</p><p>すべてのパディングは、<a href="#pdf-string.pack"><code>string.pack</code></a> によってゼロで埋められ、<a href="#pdf-string.unpack"><code>string.unpack</code></a> によって無視されます。</p><h2>6.5 – <a name="6.5">UTF-8 サポート</a></h2>

<p>このライブラリは、UTF-8 エンコーディングの基本的なサポートを提供します。このライブラリは、すべての関数を <a name="pdf-utf8"><code>utf8</code></a> テーブル内に提供します。このライブラリは、エンコーディングの処理以外に、Unicode のサポートを提供しません。文字分類など、文字の意味を必要とする操作は、その範囲外です。</p><p>特に明記しない限り、バイト位置をパラメータとして期待するすべての関数は、指定された位置がバイトシーケンスの開始であるか、サブジェクト文字列の長さプラス 1 であると想定します。文字列ライブラリと同様に、負のインデックスは文字列の末尾から数えます。</p><p>バイトシーケンスを作成する関数は、元の UTF-8 仕様で定義されているように、<code>0x7FFFFFFF</code> までのすべての値を受け入れます。これは、最大 6 バイトまでのバイトシーケンスを意味します。</p><p>バイトシーケンスを解釈する関数は、有効なシーケンス（整形式であり、過長でない）のみを受け入れます。デフォルトでは、<code>10FFFF</code> より大きい値とサロゲートを拒否し、有効な Unicode コードポイントになるバイトシーケンスのみを受け入れます。ブール値引数 <code>lax</code> が使用可能な場合、これらのチェックを解除し、<code>0x7FFFFFFF</code> までのすべての値を受け入れるようにします。（整形式でないシーケンスと過長なシーケンスは引き続き拒否されます。）</p><p>
</p><hr /><h3><a name="pdf-utf8.char"><code>utf8.char (···)</code></a></h3>


<p>0 個以上の整数を受け取り、それぞれを対応する UTF-8 バイトシーケンスに変換し、これらのシーケンスすべてを連結した文字列を返します。</p><p>
</p><hr /><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>


<p>パターン（関数ではなく文字列） "<code>[\0-\x7F\xC2-\xFD][\x80-\xBF]*</code>"（<a href="#6.4.1">§6.4.1</a>を参照）は、サブジェクトが有効な UTF-8 文字列であると仮定して、正確に 1 つの UTF-8 バイトシーケンスに一致します。</p><p>
</p><hr /><h3><a name="pdf-utf8.codes"><code>utf8.codes (s [, lax])</code></a></h3>


<p>次の構成で、</p><pre>     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>文字列 <code>s</code> 内のすべての UTF-8 文字を反復処理し、<code>p</code> が位置（バイト単位）であり、<code>c</code> が各文字のコードポイントとなるように値を返します。無効なバイトシーケンスが見つかった場合はエラーが発生します。</p><p>
</p><hr /><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j [, lax]]])</code></a></h3>


<p>バイト位置 <code>i</code> と <code>j</code> の間（両方を含む）で開始される、<code>s</code> 内のすべての文字のコードポイント（整数として）を返します。<code>i</code> のデフォルトは 1 で、<code>j</code> のデフォルトは <code>i</code> です。無効なバイトシーケンスが見つかった場合はエラーが発生します。</p><p>
</p><hr /><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j [, lax]]])</code></a></h3>


<p>位置 <code>i</code> と <code>j</code> の間（両方を含む）で開始される文字列 <code>s</code> 内の UTF-8 文字の数を返します。<code>i</code> のデフォルトは 1 で、<code>j</code> のデフォルトは -1 です。無効なバイトシーケンスが見つかった場合は、<b>fail</b> と最初の無効なバイトの位置を返します。</p><p>
</p><hr /><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>


<p><code>s</code> の <code>n</code> 番目の文字（位置 <code>i</code> から数える）のエンコーディングが開始する位置（バイト単位）を返します。負の <code>n</code> は、位置 <code>i</code> より前の文字を取得します。<code>n</code> が非負の場合、<code>i</code> のデフォルトは 1 であり、それ以外の場合は <code>#s + 1</code> であるため、<code>utf8.offset(s, -n)</code> は文字列の末尾から <code>n</code> 番目の文字のオフセットを取得します。指定された文字がサブジェクト内にもその直後にもない場合、関数は <b>fail</b> を返します。</p><p>特別なケースとして、<code>n</code> が 0 の場合、関数は <code>s</code> の <code>i</code> 番目のバイトを含む文字のエンコーディングの開始を返します。</p><p>この関数は、<code>s</code> が有効な UTF-8 文字列であることを前提としています。</p><h2>6.6 – <a name="6.6">テーブル操作</a></h2>

<p>このライブラリは、テーブル操作のための汎用関数を提供します。このライブラリは、すべての関数を <a name="pdf-table"><code>table</code></a> テーブル内に提供します。</p><p>操作でテーブルの長さが必要な場合は常に、長さ演算子に関するすべての注意が適用されることに注意してください（<a href="#3.4.7">§3.4.7</a>を参照）。すべての関数は、引数として指定されたテーブル内の数値以外のキーを無視します。</p><p>
</p><hr /><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>すべての要素が文字列または数値であるリストが与えられた場合、文字列 <code>list[i]..sep..list[i+1] ··· sep..list[j]</code> を返します。<code>sep</code> のデフォルト値は空文字列で、<code>i</code> のデフォルトは 1 で、<code>j</code> のデフォルトは <code>#list</code> です。<code>i</code> が <code>j</code> より大きい場合は、空文字列を返します。</p><p>
</p><hr /><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p><code>list</code> の位置 <code>pos</code> に要素 <code>value</code> を挿入し、要素 <code>list[pos], list[pos+1], ···, list[#list]</code> を上にシフトします。<code>pos</code> のデフォルト値は <code>#list+1</code> であるため、<code>table.insert(t,x)</code> を呼び出すと、<code>x</code> がリスト <code>t</code> の末尾に挿入されます。</p><p>
</p><hr /><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>


<p>テーブル <code>a1</code> からテーブル <code>a2</code> に要素を移動し、次の多重代入と同等の処理を実行します: <code>a2[t],··· = a1[f],···,a1[e]</code>。<code>a2</code> のデフォルトは <code>a1</code> です。移動先範囲は、移動元範囲と重複する可能性があります。移動する要素の数は、Lua 整数に収まる必要があります。</p><p>移動先テーブル <code>a2</code> を返します。</p><p>
</p><hr /><h3><a name="pdf-table.pack"><code>table.pack (···)</code></a></h3>


<p>すべての引数をキー 1、2 などに格納し、引数の総数を持つフィールド "<code>n</code>" を含む新しいテーブルを返します。一部の引数が <b>nil</b> の場合、結果のテーブルがシーケンスではない場合があることに注意してください。</p><p>
</p><hr /><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p><code>list</code> から位置 <code>pos</code> の要素を削除し、削除された要素の値を返します。<code>pos</code> が 1 から <code>#list</code> の間の整数である場合、要素 <code>list[pos+1], list[pos+2], ···, list[#list]</code> を下にシフトし、要素 <code>list[#list]</code> を消去します。インデックス <code>pos</code> は、<code>#list</code> が 0 の場合は 0 にすることも、<code>#list + 1</code> にすることもできます。</p><p><code>pos</code> のデフォルト値は <code>#list</code> であるため、<code>table.remove(l)</code> を呼び出すと、リスト <code>l</code> の最後の要素が削除されます。</p><p>
</p><hr /><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>リスト要素を指定された順序で、<em>インプレース</em> で <code>list[1]</code> から <code>list[#list]</code> までソートします。<code>comp</code> が指定されている場合は、2 つのリスト要素を受け取り、最終的な順序で最初の要素が 2 番目の要素の前に来る必要がある場合に true を返す関数である必要があります。したがって、ソート後、<code>i &lt;= j</code> は <code>not comp(list[j],list[i])</code> を意味します。<code>comp</code> が指定されていない場合は、代わりに標準の Lua 演算子 <code>&lt;</code> が使用されます。</p><p><code>comp</code> 関数は、一貫した順序を定義する必要があります。より正式には、関数は厳密な弱順序を定義する必要があります。（弱順序は全順序に似ていますが、比較目的で異なる要素を同等に扱うことができます。）</p><p>ソートアルゴリズムは安定していません。指定された順序で等しいと見なされる異なる要素は、ソートによって相対位置が変更される可能性があります。</p><p>
</p><hr /><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>指定されたリストから要素を返します。この関数は、次と同等です。</p><pre>     return list[i], list[i+1], ···, list[j]
</pre><p>デフォルトでは、<code>i</code> は 1 で、<code>j</code> は <code>#list</code> です。</p><h2>6.7 – <a name="6.7">数学関数</a></h2>

<p>このライブラリは、基本的な数学関数を提供します。このライブラリは、すべての関数と定数を <a name="pdf-math"><code>math</code></a> テーブル内に提供します。「<code>integer/float</code>」の注釈が付いた関数は、整数引数に対しては整数結果を、非整数引数に対しては浮動小数点結果を返します。丸め関数 <a href="#pdf-math.ceil"><code>math.ceil</code></a>、<a href="#pdf-math.floor"><code>math.floor</code></a>、および <a href="#pdf-math.modf"><code>math.modf</code></a> は、結果が整数の範囲に収まる場合は整数を、それ以外の場合は浮動小数点数を返します。</p><p>
</p><hr /><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p><code>x</code> と <code>-x</code> の間の最大値を返します。（整数/浮動小数点）</p><p>
</p><hr /><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p><code>x</code> の逆コサイン（ラジアン単位）を返します。</p><p>
</p><hr /><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p><code>x</code> の逆サイン（ラジアン単位）を返します。</p><p>
</p><hr /><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>


<p><code>y/x</code> の逆タンジェント（ラジアン単位）を、両方の引数の符号を使用して結果の象限を求めながら返します。<code>x</code> がゼロの場合も正しく処理します。</p><p><code>x</code> のデフォルト値は 1 であるため、<code>math.atan(y)</code> を呼び出すと <code>y</code> の逆タンジェントが返されます。</p><p>
</p><hr /><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p><code>x</code> 以上の最小の整数値を返します。</p><p>
</p><hr /><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p><code>x</code> のコサイン（ラジアン単位であると仮定）を返します。</p><p>
</p><hr /><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>角度 <code>x</code> をラジアンから度に変換します。</p><p>
</p><hr /><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>値 <em>e<sup>x</sup></em> を返します（ここで、<code>e</code> は自然対数の底です）。</p><p>
</p><hr /><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p><code>x</code> 以下の最大の整数値を返します。</p><p>
</p><hr /><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>商をゼロに向かって丸める、<code>x</code> を <code>y</code> で割った余りを返します。（整数/浮動小数点）</p><p>
</p><hr /><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>浮動小数点値 <code>HUGE_VAL</code>。他の任意の数値よりも大きい値です。</p><p>
</p><hr /><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>指定された底での <code>x</code> の対数を返します。<code>base</code> のデフォルトは <em>e</em> です（したがって、関数は <code>x</code> の自然対数を返します）。</p><p>
</p><hr /><h3><a name="pdf-math.max"><code>math.max (x, ···)</code></a></h3>


<p>Lua 演算子 <code>&lt;</code> に従って、最大値を持つ引数を返します。</p><p>
</p><hr /><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>整数の最大値を持つ整数。<p>
</p><hr /><h3><a name="pdf-math.min"><code>math.min (x, ···)</code></a></h3>


<p>Luaの演算子<code>&lt;</code>に従って、最小値を持つ引数を返します。</p><p>
</p><hr /><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>整数の最小値を表す整数。<p>
</p><hr /><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p><code>x</code>の整数部分と小数部分を返します。2番目の結果は常に浮動小数点数です。</p><p>
</p><hr /><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p><em>π</em>の値。</p><p>
</p><hr /><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>角度<code>x</code>を度からラジアンに変換します。</p><p>
</p><hr /><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>引数なしで呼び出された場合、範囲<em>[0,1)</em>で一様分布する擬似乱数浮動小数点数を返します。2つの整数<code>m</code>と<code>n</code>で呼び出された場合、<code>math.random</code>は範囲<em>[m, n]</em>で一様分布する擬似乱数整数を返します。正の<code>n</code>に対する呼び出し<code>math.random(n)</code>は、<code>math.random(1,n)</code>と同等です。呼び出し<code>math.random(0)</code>は、すべてのビットが（擬似）ランダムな整数を生成します。</p><p>この関数は、擬似乱数64ビット整数を生成するために<code>xoshiro256**</code>アルゴリズムを使用します。これらは、引数0で呼び出した結果です。他の結果（範囲と浮動小数点数）は、これらの整数から偏りなく抽出されます。</p><p>Luaは、<a href="#pdf-math.randomseed"><code>math.randomseed</code></a>を引数なしで呼び出した場合と同様の方法で擬似乱数ジェネレーターを初期化するため、<code>math.random</code>はプログラムが実行されるたびに異なる結果のシーケンスを生成する必要があります。</p><p>
</p><hr /><h3><a name="pdf-math.randomseed"><code>math.randomseed ([x [, y]])</code></a></h3>


<p>少なくとも1つの引数で呼び出された場合、整数パラメータ<code>x</code>と<code>y</code>は、擬似乱数ジェネレーターを再初期化するために使用される128ビットの<em>シード</em>に結合されます。等しいシードは、等しい数のシーケンスを生成します。<code>y</code>のデフォルトはゼロです。</p><p>引数なしで呼び出された場合、Luaはランダム化を弱く試みたシードを生成します。</p><p>この関数は、実際に使用された2つのシードコンポーネントを返すため、それらを再度設定するとシーケンスが繰り返されます。</p><p>初期状態に必要なレベルのランダム性を確保するため（または逆に、たとえばプログラムのデバッグ時に決定的なシーケンスを持たせるため）、明示的な引数を使用して<a href="#pdf-math.randomseed"><code>math.randomseed</code></a>を呼び出す必要があります。</p><p>
</p><hr /><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p><code>x</code>のサイン（ラジアン単位とみなされます）を返します。</p><p>
</p><hr /><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p><code>x</code>の平方根を返します。（この値を計算するには、式<code>x^0.5</code>を使用することもできます。）</p><p>
</p><hr /><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p><code>x</code>のタンジェント（ラジアン単位とみなされます）を返します。</p><p>
</p><hr /><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>


<p>値<code>x</code>が整数に変換可能な場合、その整数を返します。それ以外の場合は、<b>fail</b>を返します。</p><p>
</p><hr /><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>


<p><code>x</code>が整数の場合は "<code>integer</code>"、浮動小数点数の場合は "<code>float</code>"、<code>x</code>が数値でない場合は<b>fail</b>を返します。</p><p>
</p><hr /><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>


<p>整数<code>m</code>が符号なし整数として比較されたときに整数<code>n</code>より小さい場合に限り、ブール値<b>true</b>を返します。</p><h2>6.8 – <a name="6.8">入出力機能</a></h2>

<p>I/Oライブラリは、ファイル操作に2つの異なるスタイルを提供します。最初のスタイルは暗黙的なファイルハンドルを使用します。つまり、デフォルトの入力ファイルとデフォルトの出力ファイルを設定する操作があり、すべての入出力操作はこれらのデフォルトファイルに対して行われます。2番目のスタイルは明示的なファイルハンドルを使用します。</p><p>暗黙的なファイルハンドルを使用する場合、すべての操作はテーブル<a name="pdf-io"><code>io</code></a>によって提供されます。明示的なファイルハンドルを使用する場合、操作<a href="#pdf-io.open"><code>io.open</code></a>はファイルハンドルを返し、すべての操作はファイルハンドルのメソッドとして提供されます。</p><p>ファイルハンドルのメタテーブルは、呼び出されたときにファイルを閉じようとする<code>__gc</code>と<code>__close</code>のメタメソッドを提供します。</p><p>テーブル<code>io</code>は、Cからの通常の意味を持つ3つの定義済みのファイルハンドルも提供します。<a name="pdf-io.stdin"><code>io.stdin</code></a>、<a name="pdf-io.stdout"><code>io.stdout</code></a>、および<a name="pdf-io.stderr"><code>io.stderr</code></a>。I/Oライブラリはこれらのファイルを閉じることはありません。</p><p>特に明記されていない限り、すべてのI/O関数は失敗した場合に<b>fail</b>を返し、さらに2番目の結果としてエラーメッセージ、3番目の結果としてシステム依存のエラーコード、成功した場合はfalse以外の値を返します。非POSIXシステムでは、エラーの場合のエラーメッセージとエラーコードの計算は、グローバルC変数<code>errno</code>に依存するため、スレッドセーフでない場合があります。</p><p>
</p><hr /><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p><code>file:close()</code>と同等です。<code>file</code>がない場合は、デフォルトの出力ファイルを閉じます。</p><p>
</p><hr /><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p><code>io.output():flush()</code>と同等です。</p><p>
</p><hr /><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>ファイル名で呼び出された場合、指定されたファイル（テキストモード）を開き、そのハンドルをデフォルトの入力ファイルとして設定します。ファイルハンドルで呼び出された場合、このファイルハンドルをデフォルトの入力ファイルとして設定します。引数なしで呼び出された場合、現在のデフォルトの入力ファイルを返します。</p><p>エラーの場合、この関数はエラーコードを返すのではなく、エラーを発生させます。</p><p>
</p><hr /><h3><a name="pdf-io.lines"><code>io.lines ([filename, ···])</code></a></h3>


<p>指定されたファイル名を読み取りモードで開き、開いたファイルに対して<code>file:lines(···)</code>のように機能するイテレータ関数を返します。イテレータ関数が値を読み取ることができなかった場合、自動的にファイルを閉じます。イテレータ関数に加えて、<code>io.lines</code>は他の3つの値を返します。プレースホルダーとして2つの<b>nil</b>値、プラス作成されたファイルハンドルです。したがって、ジェネリック<b>for</b>ループで使用する場合、ループがエラーまたは<b>break</b>によって中断された場合でも、ファイルは閉じられます。</p><p>呼び出し<code>io.lines()</code>（ファイル名なし）は<code>io.input():lines("l")</code>と同等です。つまり、デフォルトの入力ファイルの行を反復処理します。この場合、イテレータはループが終了してもファイルを閉じません。</p><p>ファイルを開く際のエラーの場合、この関数はエラーコードを返すのではなく、エラーを発生させます。</p><p>
</p><hr /><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>この関数は、文字列<code>mode</code>で指定されたモードでファイルを開きます。成功した場合、新しいファイルハンドルを返します。</p><p><code>mode</code>文字列は、次のいずれかになります。</p><ul>
<li><b>"<code>r</code>": </b>読み取りモード（デフォルト）;</li>
<li><b>"<code>w</code>": </b>書き込みモード;</li>
<li><b>"<code>a</code>": </b>追加モード;</li>
<li><b>"<code>r+</code>": </b>更新モード、以前のすべてのデータは保持されます;</li>
<li><b>"<code>w+</code>": </b>更新モード、以前のすべてのデータは消去されます;</li>
<li><b>"<code>a+</code>": </b>追加更新モード、以前のデータは保持され、書き込みはファイルの最後にのみ許可されます。</li>
</ul><p><code>mode</code>文字列の末尾には'<code>b</code>'を含めることもできます。これは、一部のシステムでファイルをバイナリモードで開くために必要です。</p><p>
</p><hr /><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p><a href="#pdf-io.input"><code>io.input</code></a>と同様ですが、デフォルトの出力ファイルに対して動作します。</p><p>
</p><hr /><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>この関数はシステムに依存し、すべてのプラットフォームで使用できるわけではありません。</p><p>別のプロセスでプログラム<code>prog</code>を開始し、このプログラムからデータを読み取る（<code>mode</code>が<code>"r"</code>の場合、デフォルト）か、このプログラムにデータを書き込む（<code>mode</code>が<code>"w"</code>の場合）ために使用できるファイルハンドルを返します。</p><p>
</p><hr /><h3><a name="pdf-io.read"><code>io.read (···)</code></a></h3>


<p><code>io.input():read(···)</code>と同等です。</p><p>
</p><hr /><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>成功した場合、一時ファイルのハンドルを返します。このファイルは更新モードで開かれ、プログラムが終了すると自動的に削除されます。</p><p>
</p><hr /><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p><code>obj</code>が有効なファイルハンドルであるかどうかを確認します。<code>obj</code>が開いているファイルハンドルの場合は文字列<code>"file"</code>、<code>obj</code>が閉じているファイルハンドルの場合は<code>"closed file"</code>、<code>obj</code>がファイルハンドルではない場合は<b>fail</b>を返します。</p><p>
</p><hr /><h3><a name="pdf-io.write"><code>io.write (···)</code></a></h3>


<p><code>io.output():write(···)</code>と同等です。</p><p>
</p><hr /><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p><code>file</code>を閉じます。ファイルはハンドルがガベージコレクションされると自動的に閉じられますが、それには予測できない時間がかかることに注意してください。</p><p><a href="#pdf-io.popen"><code>io.popen</code></a>で作成されたファイルハンドルを閉じると、<a href="#pdf-file:close"><code>file:close</code></a>は<a href="#pdf-os.execute"><code>os.execute</code></a>によって返された同じ値を返します。</p><p>
</p><hr /><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p><code>file</code>に書き込まれたデータを保存します。</p><p>
</p><hr /><h3><a name="pdf-file:lines"><code>file:lines (···)</code></a></h3>


<p>呼び出されるたびに、指定された形式に従ってファイルを読み取るイテレータ関数を返します。形式が指定されていない場合は、デフォルトとして "<code>l</code>" を使用します。例として、次の構文は</p><pre>     for c in file:lines(1) do <em>body</em> end
</pre><p>現在の位置から始まるファイルのすべての文字を反復処理します。<a href="#pdf-io.lines"><code>io.lines</code></a>とは異なり、この関数はループが終了してもファイルを閉じません。</p><p>
</p><hr /><h3><a name="pdf-file:read"><code>file:read (···)</code></a></h3>


<p>何を読み取るかを指定する指定された形式に従って、ファイル<code>file</code>を読み取ります。形式ごとに、関数は読み取られた文字の文字列または数値を返すか、指定された形式でデータを読み取ることができない場合は<b>fail</b>を返します。（後者の場合、関数は後続の形式を読み取りません。）引数なしで呼び出された場合、次の行を読み取るデフォルトの形式を使用します（以下を参照）。</p><p>使用可能な形式は次のとおりです。</p><ul>

<li><b>"<code>n</code>": </b>数値を読み取り、Luaの字句規則に従って浮動小数点数または整数として返します。（数値には、先頭の空白と符号を含めることができます。）この形式は、常に数値の有効なプレフィックスである最長の入力シーケンスを読み取ります。そのプレフィックスが有効な数値を形成しない場合（たとえば、空の文字列、"<code>0x</code>"、または "<code>3.4e-</code>"）、または長すぎる場合（200文字を超える）、破棄され、形式は<b>fail</b>を返します。</li>

<li><b>"<code>a</code>": </b>現在の位置から始まるファイル全体を読み取ります。ファイルの終わりに、空の文字列を返します。この形式は失敗しません。</li>

<li><b>"<code>l</code>": </b>次の行を読み取り、行末をスキップし、ファイルの終わりに<b>fail</b>を返します。これはデフォルトの形式です。</li>

<li><b>"<code>L</code>": </b>行末文字（存在する場合）を保持したまま、次の行を読み取り、ファイルの終わりに<b>fail</b>を返します。</li>

<li><b><em>number</em>: </b>最大でこのバイト数の文字列を読み取り、ファイルの終わりに<b>fail</b>を返します。<code>number</code>がゼロの場合、何も読み取らず、空の文字列を返すか、ファイルの終わりに<b>fail</b>を返します。</li>

</ul><p>形式"<code>l</code>"と"<code>L</code>"はテキストファイルに対してのみ使用する必要があります。</p><p>
</p><hr /><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>ファイルの先頭からのファイル位置を、文字列<code>whence</code>で指定されたベースに<code>offset</code>を加えた位置に設定および取得します。以下のように</p><ul>
<li><b>"<code>set</code>": </b>ベースは位置0（ファイルの先頭）です。</li>
<li><b>"<code>cur</code>": </b>ベースは現在の位置です。</li>
<li><b>"<code>end</code>": </b>ベースはファイルの末尾です。</li>
</ul><p>成功した場合、<code>seek</code>は、ファイルの先頭からバイト単位で測定された最終的なファイル位置を返します。<code>seek</code>が失敗した場合、<b>fail</b>とエラーを説明する文字列を返します。</p><p><code>whence</code>のデフォルト値は<code>"cur"</code>で、<code>offset</code>のデフォルト値は0です。したがって、呼び出し<code>file:seek()</code>は、現在のファイル位置を返しますが、変更はしません。呼び出し<code>file:seek("set")</code>は、位置をファイルの先頭に設定し（0を返します）。呼び出し<code>file:seek("end")</code>は、位置をファイルの末尾に設定し、そのサイズを返します。</p><p>
</p><hr /><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>ファイルに対するバッファリングモードを設定します。3つのモードが利用可能です。</p><ul>
<li><b>"<code>no</code>": </b> バッファリングなし。</li>
<li><b>"<code>full</code>": </b> フルバッファリング。</li>
<li><b>"<code>line</code>": </b> 行バッファリング。</li>
</ul>

<p>最後の2つのケースでは、<code>size</code>はバッファのサイズ（バイト単位）のヒントです。デフォルトは適切なサイズです。</p><p>各モードの具体的な動作は移植性がないため、詳細についてはプラットフォームの基盤となるISO&nbsp;C関数<code>setvbuf</code>を確認してください。</p><p>
</p><hr /><h3><a name="pdf-file:write"><code>file:write (···)</code></a></h3>


<p>引数のそれぞれの値を<code>file</code>に書き込みます。引数は文字列または数値である必要があります。</p><p>成功した場合、この関数は<code>file</code>を返します。</p><h2>6.9 – <a name="6.9">オペレーティングシステム機能</a></h2>

<p>このライブラリは、テーブル<a name="pdf-os"><code>os</code></a>を通して実装されています。</p><p>
</p><hr /><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>プログラムが使用したCPU時間の概算（秒単位）を、基盤となるISO&nbsp;C関数<code>clock</code>によって返される値として返します。</p><p>
</p><hr /><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>指定された文字列<code>format</code>に従ってフォーマットされた、日付と時間を含む文字列またはテーブルを返します。</p><p><code>time</code>引数が存在する場合、これはフォーマットされる時間です（この値の説明については<a href="#pdf-os.time"><code>os.time</code></a>関数を参照してください）。それ以外の場合、<code>date</code>は現在の時間をフォーマットします。</p><p><code>format</code>が'<code>!</code>'で始まる場合、日付は協定世界時でフォーマットされます。このオプションの文字の後、<code>format</code>が文字列"<code>*t</code>"の場合、<code>date</code>は次のフィールドを持つテーブルを返します：<code>year</code>、<code>month</code>（1–12）、<code>day</code>（1–31）、<code>hour</code>（0–23）、<code>min</code>（0–59）、<code>sec</code>（うるう秒のため0–61）、<code>wday</code>（曜日、1–7、日曜日は1）、<code>yday</code>（年の日数、1–366）、および<code>isdst</code>（夏時間フラグ、ブール値）。この最後のフィールドは、情報が利用できない場合は存在しない可能性があります。</p><p><code>format</code>が"<code>*t</code>"でない場合、<code>date</code>はISO&nbsp;C関数<code>strftime</code>と同じルールに従ってフォーマットされた日付を文字列として返します。</p><p><code>format</code>がない場合、デフォルトは"<code>%c</code>"になり、これは現在のロケールを使用して人間が読める日付と時刻の表現を提供します。</p><p>非POSIXシステムでは、この関数はC&nbsp;関数<code>gmtime</code>およびC&nbsp;関数<code>localtime</code>に依存しているため、スレッドセーフでない場合があります。</p><p>
</p><hr /><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>時間<code>t1</code>から時間<code>t2</code>までの差（秒単位）を返します（ここで、時間は<a href="#pdf-os.time"><code>os.time</code></a>によって返される値です）。POSIX、Windows、および他のいくつかのシステムでは、この値は正確に<code>t2</code><em>-</em><code>t1</code>です。</p><p>
</p><hr /><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>この関数は、ISO&nbsp;C関数<code>system</code>と同等です。オペレーティングシステムのシェルによって実行されるように<code>command</code>を渡します。その最初の結果は、コマンドが正常に終了した場合は<b>true</b>、それ以外の場合は<b>fail</b>です。この最初の結果の後、関数は以下のように、文字列と数値を返します。</p><ul>

<li><b>"<code>exit</code>": </b> コマンドが正常に終了しました。次の数値は、コマンドの終了ステータスです。</li>

<li><b>"<code>signal</code>": </b> コマンドがシグナルによって終了しました。次の数値は、コマンドを終了したシグナルです。</li>

</ul>

<p><code>command</code>なしで呼び出された場合、<code>os.execute</code>はシェルが利用可能な場合はtrueであるブール値を返します。</p><p>
</p><hr /><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>ホストプログラムを終了するためにISO&nbsp;C関数<code>exit</code>を呼び出します。<code>code</code>が<b>true</b>の場合、返されるステータスは<code>EXIT_SUCCESS</code>です。<code>code</code>が<b>false</b>の場合、返されるステータスは<code>EXIT_FAILURE</code>です。<code>code</code>が数値の場合、返されるステータスはこの数値です。<code>code</code>のデフォルト値は<b>true</b>です。</p><p>オプションの2番目の引数<code>close</code>がtrueの場合、関数は終了する前にLua状態を閉じます（<a href="#lua_close"><code>lua_close</code></a>を参照）。</p><p>
</p><hr /><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>プロセス環境変数<code>varname</code>の値を返します。変数定義されていない場合は<b>fail</b>を返します。</p><p>
</p><hr /><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>指定された名前のファイル（またはPOSIXシステム上の空のディレクトリ）を削除します。この関数が失敗した場合、<b>fail</b>に加えて、エラーとエラーコードを説明する文字列を返します。それ以外の場合は、trueを返します。</p><p>
</p><hr /><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p><code>oldname</code>という名前のファイルまたはディレクトリを<code>newname</code>に名前変更します。この関数が失敗した場合、<b>fail</b>に加えて、エラーとエラーコードを説明する文字列を返します。それ以外の場合は、trueを返します。</p><p>
</p><hr /><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>プログラムの現在のロケールを設定します。<code>locale</code>はロケールを指定するシステム依存の文字列です。<code>category</code>は変更するカテゴリを説明するオプションの文字列です：<code>"all"</code>、<code>"collate"</code>、<code>"ctype"</code>、<code>"monetary"</code>、<code>"numeric"</code>、または<code>"time"</code>。デフォルトのカテゴリは<code>"all"</code>です。この関数は新しいロケールの名前を返します。リクエストが受け入れられない場合は<b>fail</b>を返します。</p><p><code>locale</code>が空の文字列の場合、現在のロケールは実装定義のネイティブロケールに設定されます。<code>locale</code>が文字列"<code>C</code>"の場合、現在のロケールは標準Cロケールに設定されます。</p><p>最初の引数として<b>nil</b>を付けて呼び出された場合、この関数は指定されたカテゴリの現在のロケールの名前のみを返します。</p><p>この関数は、C&nbsp;関数<code>setlocale</code>に依存しているため、スレッドセーフでない場合があります。</p><p>
</p><hr /><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>引数なしで呼び出された場合は現在の時刻を返します。または、指定されたテーブルで指定されたローカルの日時を表す時刻を返します。このテーブルには、フィールド<code>year</code>、<code>month</code>、および<code>day</code>が必要であり、フィールド<code>hour</code>（デフォルトは12）、<code>min</code>（デフォルトは0）、<code>sec</code>（デフォルトは0）、および<code>isdst</code>（デフォルトは<b>nil</b>）を持つことができます。他のフィールドは無視されます。これらのフィールドの説明については、<a href="#pdf-os.date"><code>os.date</code></a>関数を参照してください。</p><p>関数が呼び出されると、これらのフィールドの値が有効な範囲内にある必要はありません。たとえば、<code>sec</code>が-10の場合、他のフィールドで指定された時間の10秒前を意味します。<code>hour</code>が1000の場合、他のフィールドで指定された時間の1000時間後を意味します。</p><p>返される値は数値であり、その意味はシステムによって異なります。POSIX、Windows、およびその他のいくつかのシステムでは、この数値はある特定の開始時間（「エポック」）からの秒数をカウントします。他のシステムでは、意味は指定されておらず、<code>time</code>によって返される数値は、<a href="#pdf-os.date"><code>os.date</code></a>および<a href="#pdf-os.difftime"><code>os.difftime</code></a>への引数としてのみ使用できます。</p><p>テーブルで呼び出された場合、<code>os.time</code>は<a href="#pdf-os.date"><code>os.date</code></a>関数でドキュメント化されているすべてのフィールドも正規化するため、呼び出し前と同じ時刻を表しますが、値は有効な範囲内になります。</p><p>
</p><hr /><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>一時ファイルに使用できるファイル名を持つ文字列を返します。ファイルは、使用する前に明示的に開き、不要になったら明示的に削除する必要があります。</p><p>POSIXシステムでは、この関数はセキュリティリスクを回避するために、その名前のファイルも作成します。（名前を取得してからファイルを作成するまでの間に、別の誰かが間違った権限でファイルを作成する可能性があります。）ファイルを使用するためにファイルを開き、削除する必要があるのは変わりません（たとえ使用しなくても）。</p><p>可能であれば、プログラムが終了したときにファイルを自動的に削除する<a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>を使用することをお勧めします。</p><h2>6.10 – <a name="6.10">デバッグライブラリ</a></h2>

<p>このライブラリは、Luaプログラムへのデバッグインターフェイス（<a href="#4.7">§4.7</a>）の機能を提供します。このライブラリを使用するときは注意が必要です。そのいくつかの関数は、Luaコードに関する基本的な仮定（たとえば、関数のローカル変数は外部からアクセスできないこと、userdataメタテーブルはLuaコードで変更できないこと、Luaプログラムはクラッシュしないこと）に違反するため、そうでない場合は安全なコードを危険にさらす可能性があります。さらに、このライブラリの一部の関数は遅くなる可能性があります。</p><p>このライブラリのすべての関数は、<a name="pdf-debug"><code>debug</code></a>テーブル内に提供されています。スレッドを操作するすべての関数には、操作するスレッドであるオプションの最初の引数があります。デフォルトは常に現在のスレッドです。</p><p>
</p><hr /><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>ユーザーが入力した各文字列を実行して、ユーザーとの対話モードに入ります。単純なコマンドやその他のデバッグ機能を使用して、ユーザーはグローバル変数とローカル変数を検査したり、それらの値を変更したり、式を評価したりできます。単語<code>cont</code>のみを含む行は、この関数を終了させ、呼び出し元が実行を継続できるようにします。</p><p><code>debug.debug</code>のコマンドは、どの関数にも字句的にネストされていないため、ローカル変数に直接アクセスできないことに注意してください。</p><p>
</p><hr /><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>スレッドの現在のフック設定を、3つの値として返します：現在のフック関数、現在のフックマスク、および<a href="#pdf-debug.sethook"><code>debug.sethook</code></a>関数によって設定された現在のフックカウント。</p><p>アクティブなフックがない場合は<b>fail</b>を返します。</p><p>
</p><hr /><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>関数に関する情報を含むテーブルを返します。関数を直接指定することも、<code>f</code>の値として数値を指定することもできます。これは、指定されたスレッドの呼び出しスタックのレベル<code>f</code>で実行されている関数を意味します：レベル0は現在の関数（<code>getinfo</code>自体）です。レベル1は<code>getinfo</code>を呼び出した関数です（スタックにカウントされない末尾呼び出しを除く）。以下同様です。<code>f</code>がアクティブな関数の数よりも大きい数値の場合、<code>getinfo</code>は<b>fail</b>を返します。</p><p>返されるテーブルには、<a href="#lua_getinfo"><code>lua_getinfo</code></a>によって返されるすべてのフィールドを含めることができ、どのフィールドに入力するかを記述する文字列<code>what</code>を含めることができます。<code>what</code>のデフォルトは、有効な行のテーブルを除く、利用可能なすべての情報を取得することです。存在する場合、オプション「<code>f</code>」は、関数自体を持つ<code>func</code>という名前のフィールドを追加します。存在する場合、オプション「<code>L</code>」は、有効な行のテーブルを持つ<code>activelines</code>という名前のフィールドを追加します。</p><p>たとえば、式<code>debug.getinfo(1,"n").name</code>は、合理的な名前が見つかる場合は、現在の関数の名前を返し、式<code>debug.getinfo(print)</code>は、<a href="#pdf-print"><code>print</code></a>関数に関するすべての利用可能な情報を含むテーブルを返します。</p><p>
</p><hr /><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>この関数は、スタックのレベル<code>f</code>の関数のインデックス<code>local</code>を持つローカル変数の名前と値を返します。この関数は、明示的なローカル変数だけでなく、パラメータと一時的な値にもアクセスします。</p><p>最初のパラメータまたはローカル変数のインデックスは1であり、以下同様に、コードで宣言された順序に従い、関数の現在のスコープでアクティブな変数のみをカウントします。コンパイル時の定数は、コンパイラによって最適化された場合、このリストに表示されない場合があります。負のインデックスはvararg引数を参照します。-1は最初のvararg引数です。指定されたインデックスの変数が存在しない場合、関数は<b>fail</b>を返し、範囲外のレベルで呼び出された場合はエラーが発生します。（<a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a>を呼び出して、レベルが有効かどうかを確認できます。）</p><p>「<code>(</code>」（左括弧）で始まる変数名は、名前が不明な変数（ループ制御変数などの内部変数、およびデバッグ情報なしで保存されたチャンクの変数）を表します。</p><p>パラメータ<code>f</code>は関数である場合もあります。その場合、<code>getlocal</code>は関数パラメータの名前のみを返します。</p><p>
</p><hr /><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>指定された<code>value</code>のメタテーブルを返します。メタテーブルがない場合は<b>nil</b>を返します。</p><p>
</p><hr /><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>レジストリテーブルを返します（<a href="#4.3">§4.3</a>を参照）。</p><p>
</p><hr /><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>この関数は、関数<code>f</code>のインデックス<code>up</code>を持つアップバリューの名前と値を返します。指定されたインデックスを持つアップバリューがない場合は、<b>fail</b>を返します。</p><p>（Lua関数の場合、アップバリューとは、関数が使用し、その結果としてクロージャに含まれる外部ローカル変数です。）</p><p>C言語関数の場合、この関数はすべてのアップバリューの名前として空の文字列<code>""</code>を使用します。</p><p>変数名'<code>?</code>'（疑問符）は、名前が不明な変数（デバッグ情報なしで保存されたチャンクからの変数）を表します。</p><p>
</p><hr /><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u, n)</code></a></h3>


<p>userdata <code>u</code>に関連付けられた<code>n</code>番目のユーザー値を返し、さらに、userdataがその値を持っていない場合は<b>false</b>のブール値を返します。</p><p>
</p><hr /><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>指定された関数をデバッグフックとして設定します。文字列<code>mask</code>と数値<code>count</code>は、フックがいつ呼び出されるかを記述します。文字列マスクは、以下の文字を任意の組み合わせで持つことができ、それぞれの意味は以下のとおりです。</p><ul>
<li><b>'<code>c</code>':</b> Luaが関数を呼び出すたびにフックが呼び出されます。</li>
<li><b>'<code>r</code>':</b> Luaが関数から戻るたびにフックが呼び出されます。</li>
<li><b>'<code>l</code>':</b> Luaが新しいコード行に入るたびにフックが呼び出されます。</li>
</ul><p>さらに、0以外の<code>count</code>を指定すると、<code>count</code>命令ごとにフックが呼び出されます。</p><p>引数なしで呼び出された場合、<a href="#pdf-debug.sethook"><code>debug.sethook</code></a>はフックをオフにします。</p><p>フックが呼び出されると、その最初のパラメータは、呼び出しをトリガーしたイベントを記述する文字列です：<code>"call"</code>、<code>"tail call"</code>、<code>"return"</code>、<code>"line"</code>、および<code>"count"</code>。行イベントの場合、フックは2番目のパラメータとして新しい行番号も取得します。フック内では、レベル2で<code>getinfo</code>を呼び出して、実行中の関数に関する詳細情報を取得できます。（レベル0は<code>getinfo</code>関数、レベル1はフック関数です。）</p><p>
</p><hr /><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>この関数は、スタックのレベル<code>level</code>にある関数のインデックス<code>local</code>を持つローカル変数に値<code>value</code>を割り当てます。指定されたインデックスを持つローカル変数がない場合は<b>fail</b>を返し、範囲外の<code>level</code>で呼び出された場合はエラーを発生させます。（<code>getinfo</code>を呼び出して、レベルが有効かどうかを確認できます。）それ以外の場合は、ローカル変数の名前を返します。</p><p>変数インデックスと名前の詳細については、<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>を参照してください。</p><p>
</p><hr /><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>指定された<code>value</code>のメタテーブルを指定された<code>table</code>（<b>nil</b>にすることも可能）に設定します。<code>value</code>を返します。</p><p>
</p><hr /><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>この関数は、関数<code>f</code>のインデックス<code>up</code>を持つアップバリューに値<code>value</code>を割り当てます。指定されたインデックスを持つアップバリューがない場合は<b>fail</b>を返します。それ以外の場合は、アップバリューの名前を返します。</p><p>アップバリューの詳細については、<a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a>を参照してください。</p><p>
</p><hr /><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value, n)</code></a></h3>


<p>指定された<code>value</code>を指定された<code>udata</code>に関連付けられた<code>n</code>番目のユーザー値として設定します。<code>udata</code>は完全なuserdataである必要があります。</p><p><code>udata</code>を返します。userdataがその値を持っていない場合は<b>fail</b>を返します。</p><p>
</p><hr /><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p><code>message</code>が存在するが、文字列でも<b>nil</b>でもない場合、この関数はそれ以上の処理を行わずに<code>message</code>を返します。それ以外の場合は、コールスタックのトレースバックを含む文字列を返します。オプションの<code>message</code>文字列は、トレースバックの先頭に追加されます。オプションの<code>level</code>数値は、トレースバックを開始するレベルを指定します（デフォルトは1、<code>traceback</code>を呼び出す関数です）。</p><p>
</p><hr /><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>指定された関数の<code>n</code>番目のアップバリューの一意の識別子（ライトuserdataとして）を返します。</p><p>これらの固有の識別子により、プログラムは異なるクロージャがアップバリューを共有しているかどうかを確認できます。アップバリューを共有する（つまり、同じ外部ローカル変数にアクセスする）Luaクロージャは、それらのアップバリューインデックスに対して同一のIDを返します。</p><p>
</p><hr /><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>Luaクロージャ<code>f1</code>の<code>n1</code>番目のアップバリューが、Luaクロージャ<code>f2</code>の<code>n2</code>番目のアップバリューを参照するようにします。</p><h1>7 – <a name="7">Luaスタンドアロン</a></h1>

<p>LuaはホストCプログラムに組み込むための拡張言語として設計されていますが、スタンドアロン言語としても頻繁に使用されます。スタンドアロン言語としてのLuaのインタープリター（単に<code>lua</code>と呼ばれる）は、標準ディストリビューションに付属しています。スタンドアロンインタープリターには、すべての標準ライブラリが含まれています。その使い方は次のとおりです。</p><pre>     lua [options] [script [args]]
</pre><p>オプションは次のとおりです。</p><ul>
<li><b><code>-e <em>stat</em></code>:</b> 文字列<em>stat</em>を実行します。</li>
<li><b><code>-i</code>:</b> <em>script</em>の実行後に対話モードに入ります。</li>
<li><b><code>-l <em>mod</em></code>:</b> <em>mod</em>を「require」し、結果をグローバル<em>mod</em>に割り当てます。</li>
<li><b><code>-l <em>g=mod</em></code>:</b> <em>mod</em>を「require」し、結果をグローバル<em>g</em>に割り当てます。</li>
<li><b><code>-v</code>:</b> バージョン情報を出力します。</li>
<li><b><code>-E</code>:</b> 環境変数を無視します。</li>
<li><b><code>-W</code>:</b> 警告をオンにします。</li>
<li><b><code>--</code>:</b> オプションの処理を停止します。</li>
<li><b><code>-</code>:</b> <code>stdin</code>をファイルとして実行し、オプションの処理を停止します。</li>
</ul><p>（<code>-l <em>g=mod</em></code>形式はリリース5.4.4で導入されました。）</p><p>オプションを処理した後、<code>lua</code>は指定された<em>script</em>を実行します。引数なしで呼び出された場合、標準入力（<code>stdin</code>）がターミナルである場合は<code>lua</code>は<code>lua -v -i</code>として動作し、そうでない場合は<code>lua -</code>として動作します。</p><p>オプション<code>-E</code>なしで呼び出された場合、インタープリターは、引数を実行する前に環境変数<a name="pdf-LUA_INIT_5_4"><code>LUA_INIT_5_4</code></a>（またはバージョン付きの名前が定義されていない場合は<a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>）を確認します。変数の内容が<code>@<em>filename</em></code>の形式の場合、<code>lua</code>はそのファイルを実行します。それ以外の場合、<code>lua</code>は文字列自体を実行します。</p><p>オプション<code>-E</code>を指定して呼び出された場合、Luaは環境変数を参照しません。特に、<a href="#pdf-package.path"><code>package.path</code></a>と<a href="#pdf-package.cpath"><code>package.cpath</code></a>の値は、<code>luaconf.h</code>で定義されたデフォルトパスで設定されます。</p><p>オプション<code>-e</code>、<code>-l</code>、および<code>-W</code>は、表示される順序で処理されます。たとえば、次のような呼び出しでは</p><pre>     $ lua -e 'a=1' -llib1 script.lua
</pre><p>最初に<code>a</code>を1に設定し、次にライブラリ<code>lib1</code>をrequireし、最後に引数なしでファイル<code>script.lua</code>を実行します。（ここで<code>$</code>はシェルプロンプトです。プロンプトは異なる場合があります。）</p><p>コードを実行する前に、<code>lua</code>は、<code>arg</code>という名前のグローバルテーブルにすべてのコマンドライン引数を収集します。スクリプト名はインデックス0に、スクリプト名の後の最初の引数はインデックス1に、というように続きます。スクリプト名より前の引数（つまり、インタープリター名とオプション）は負のインデックスになります。たとえば、次の呼び出しでは</p><pre>     $ lua -la b.lua t1 t2
</pre><p>テーブルは次のようになります。</p><pre>     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>呼び出しにスクリプトがない場合、インタープリター名はインデックス0になり、その後に他の引数が続きます。たとえば、次の呼び出しでは</p><pre>     $ lua -e "print(arg[1])"
</pre><p>「<code>-e</code>」が出力されます。スクリプトがある場合、スクリプトは引数<code>arg[1]</code>、···、<code>arg[#arg]</code>で呼び出されます。Luaのすべてのチャンクと同様に、スクリプトは可変長引数関数としてコンパイルされます。</p><p>対話モードでは、Luaは繰り返しプロンプトを表示して行を待ちます。行を読み取った後、Luaは最初にその行を式として解釈しようとします。成功した場合は、その値を出力します。それ以外の場合は、その行をステートメントとして解釈します。不完全なステートメントを記述した場合、インタープリターは別のプロンプトを発行して完了を待ちます。</p><p>グローバル変数<a name="pdf-_PROMPT"><code>_PROMPT</code></a>に文字列が含まれている場合、その値はプロンプトとして使用されます。同様に、グローバル変数<a name="pdf-_PROMPT2"><code>_PROMPT2</code></a>に文字列が含まれている場合、その値はセカンダリプロンプトとして使用されます（不完全なステートメント中に発行されます）。</p><p>スクリプトで保護されていないエラーが発生した場合、インタープリターは標準エラーストリームにエラーを報告します。エラーオブジェクトが文字列ではなく、メタメソッド<code>__tostring</code>を持つ場合、インタープリターはこのメタメソッドを呼び出して最終的なメッセージを生成します。それ以外の場合、インタープリターはエラーオブジェクトを文字列に変換し、スタックトレースバックを追加します。警告がオンの場合、警告は単に標準エラー出力に出力されます。</p><p>正常に終了すると、インタープリターはメインのLua状態を閉じます（<a href="#lua_close"><code>lua_close</code></a>を参照）。スクリプトは、<a href="#pdf-os.exit"><code>os.exit</code></a>を呼び出して終了することにより、このステップを回避できます。</p><p>UnixシステムでLuaをスクリプトインタープリターとして使用できるようにするために、Luaはファイルチャンクの最初の行が<code>#</code>で始まる場合、その行をスキップします。したがって、Luaスクリプトは、<code>chmod +x</code>と<code>#!</code>形式を使用して、次のように実行可能プログラムにすることができます。</p><pre>     #!/usr/local/bin/lua
</pre><p>もちろん、Luaインタープリターの場所はマシンによって異なる場合があります。<code>lua</code>が<code>PATH</code>にある場合、</p><pre>     #!/usr/bin/env lua
</pre><p>よりポータブルなソリューションになります。</p><h1>8 – <a name="8">以前のバージョンとの非互換性</a></h1>



<p>ここでは、Lua 5.3からLua 5.4にプログラムを移行する際に発生する可能性のある非互換性をリストします。</p><p>適切なオプションを使用してLuaをコンパイルすることにより、いくつかの非互換性を回避できます（ファイル<code>luaconf.h</code>を参照）。ただし、これらの互換性オプションはすべて将来削除されます。多くの場合、互換性の問題は、これらの互換性オプションが削除されたときに発生します。したがって、機会があれば、すべての互換性オプションをオフにしてコンパイルされたLuaのバージョンでコードをテストするようにしてください。これにより、Luaの新しいバージョンへの移行が容易になります。</p><p>Luaのバージョンでは、定数の数値や関数をマクロとして実装するなど、プログラムのソースコードの変更を意味しない方法で、C APIを常に変更できます。したがって、異なるLuaバージョン間でバイナリが互換性があると想定しないでください。新しいバージョンを使用する場合は、常にLua APIのクライアントを再コンパイルしてください。</p><p>同様に、Luaのバージョンでは、プリコンパイルされたチャンクの内部表現を常に変更できます。プリコンパイルされたチャンクは、異なるLuaバージョン間では互換性がありません。</p><p>公式ディストリビューションの標準パスは、バージョン間で変更される可能性があります。</p><h2>8.1 – <a name="8.1">言語の非互換性</a></h2>
<ul>

<li>算術演算およびビット演算における文字列の数値への強制型変換が、コア言語から削除されました。文字列ライブラリは、文字列メタメソッドを使用して、算術演算（ただしビット演算は除く）に対して同様の処理を行います。ただし、以前のバージョンとは異なり、新しい実装では、文字列内の数値の暗黙的な型が保持されます。たとえば、<code>"1" + "2"</code>の結果は、浮動小数点数ではなく整数になりました。</li>

<li>オーバーフローするリテラル10進整数定数は、ラップアラウンドせずに浮動小数点数として読み取られます。古い動作（ラップアラウンド付きの整数として読み取る）が必要な場合は、このような定数に16進数表記を使用できます。</li>

<li><code>__lt</code>メタメソッドを使用して<code>__le</code>をエミュレートすることが削除されました。必要な場合、このメタメソッドを明示的に定義する必要があります。</li>

<li>整数に対する数値の<b>for</b>ループのセマンティクスが一部詳細に変更されました。特に、制御変数がラップアラウンドすることはありません。</li>

<li><b>goto</b>のラベルは、同じ名前のラベルが表示されている場所では宣言できません。たとえ、この他のラベルが囲んでいるブロックで宣言されていても同様です。</li>

<li>オブジェクトをファイナライズするとき、Luaは関数ではない<code>__gc</code>メタメソッドを無視しません。値が存在する場合、任意の値が呼び出されます。（呼び出し可能でない値は、ファイナライザの呼び出し時に他のエラーと同様に警告を生成します。）</li>

</ul>




<h2>8.2 – <a name="8.2">ライブラリの非互換性</a></h2>
<ul>

<li>関数 <a href="#pdf-print"><code>print</code></a> は、引数をフォーマットするために <a href="#pdf-tostring"><code>tostring</code></a> を呼び出しません。代わりに、この機能はハードコードされています。値をどのように出力するかを変更するには、<code>__tostring</code> を使用する必要があります。</li>

<li>関数 <a href="#pdf-math.random"><code>math.random</code></a> によって使用される擬似乱数ジェネレータは、現在、ややランダムなシードで開始されます。さらに、異なるアルゴリズムを使用しています。</li>

<li><a href="#pdf-utf8"><code>utf8</code></a> ライブラリのデコード関数は、デフォルトではサロゲートを有効なコードポイントとして受け入れません。これらの関数に追加のパラメータを指定することで、より寛容にすることができます。</li>

<li>関数 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> のオプション "<code>setpause</code>" と "<code>setstepmul</code>" は非推奨になりました。これらを設定するには、新しいオプション "<code>incremental</code>" を使用する必要があります。</li>

<li>関数 <a href="#pdf-io.lines"><code>io.lines</code></a> は、現在、1つではなく4つの値を返します。これは、<code>load(io.lines(filename, "L"))</code> のように、オプションのパラメータを持つ別の関数の唯一の引数として使用する場合に問題になる可能性があります。この問題を修正するには、呼び出しを括弧で囲んで、結果の数を1つに調整できます。</li>

</ul>




<h2>8.3 – <a name="8.3">APIの非互換性</a></h2>


<ul>

<li>フルユーザーデータは、現在、任意の数の関連付けられたユーザー値を持つことができます。したがって、関数 <code>lua_newuserdata</code>, <code>lua_setuservalue</code>, および <code>lua_getuservalue</code> は、追加の引数を持つ <a href="#lua_newuserdatauv"><code>lua_newuserdatauv</code></a>, <a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a>, および <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a> に置き換えられました。<p>互換性のために、古い名前は、1つのユーザー値を想定するマクロとして引き続き機能します。ただし、ユーザー値がゼロのユーザーデータは、メモリ効率が良いことに注意してください。</p></li>

<li>関数 <a href="#lua_resume"><code>lua_resume</code></a> に追加のパラメータが追加されました。この出力パラメータは、コルーチンによってyieldまたは返されたスタックのトップにある値の数を返します。(以前のバージョンでは、これらの値はスタック全体でした。)</li>

<li>関数 <a href="#lua_version"><code>lua_version</code></a> は、バージョン番号のアドレスではなく、バージョン番号を返します。Luaコアは、同じコアの独自の静的コピーを使用しているライブラリで正しく動作するはずであるため、同じアドレス空間を使用しているかどうかを確認する必要はありません。</li>

<li>定数 <code>LUA_ERRGCMM</code> は削除されました。ファイナライザのエラーは伝播されず、代わりに警告が生成されます。</li>

<li>関数 <a href="#lua_gc"><code>lua_gc</code></a> のオプション <code>LUA_GCSETPAUSE</code> と <code>LUA_GCSETSTEPMUL</code> は非推奨になりました。これらを設定するには、新しいオプション <code>LUA_GCINC</code> を使用する必要があります。</li>

</ul>




<h1>9 – <a name="9">Luaの完全な構文</a></h1>

<p>以下は、拡張BNFにおけるLuaの完全な構文です。拡張BNFでは通常、{A}は0個以上のAを、[A]はオプションのAを意味します。(演算子の優先順位については<a href="#3.4.8">§3.4.8</a>を参照してください。終端記号のName、Numeral、LiteralStringの説明については<a href="#3.1">§3.1</a>を参照してください。)</p><pre>
	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  ‘<b>;</b>’ | 
		 varlist ‘<b>=</b>’ explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> attnamelist [‘<b>=</b>’ explist] 

	attnamelist ::=  Name attrib {‘<b>,</b>’ Name attrib}

	attrib ::= [‘<b>&lt;</b>’ Name ‘<b>&gt;</b>’]

	retstat ::= <b>return</b> [explist] [‘<b>;</b>’]

	label ::= ‘<b>::</b>’ Name ‘<b>::</b>’

	funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]

	varlist ::= var {‘<b>,</b>’ var}

	var ::=  Name | prefixexp ‘<b>[</b>’ exp ‘<b>]</b>’ | prefixexp ‘<b>.</b>’ Name 

	namelist ::= Name {‘<b>,</b>’ Name}

	explist ::= exp {‘<b>,</b>’ exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | ‘<b>...</b>’ | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’

	functioncall ::=  prefixexp args | prefixexp ‘<b>:</b>’ Name args 

	args ::=  ‘<b>(</b>’ [explist] ‘<b>)</b>’ | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b>

	parlist ::= namelist [‘<b>,</b>’ ‘<b>...</b>’] | ‘<b>...</b>’

	tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp

	fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’

	binop ::=  ‘<b>+</b>’ | ‘<b>-</b>’ | ‘<b>*</b>’ | ‘<b>/</b>’ | ‘<b>//</b>’ | ‘<b>^</b>’ | ‘<b>%</b>’ | 
		 ‘<b>&amp;</b>’ | ‘<b>~</b>’ | ‘<b>|</b>’ | ‘<b>&gt;&gt;</b>’ | ‘<b>&lt;&lt;</b>’ | ‘<b>..</b>’ | 
		 ‘<b>&lt;</b>’ | ‘<b>&lt;=</b>’ | ‘<b>&gt;</b>’ | ‘<b>&gt;=</b>’ | ‘<b>==</b>’ | ‘<b>~=</b>’ | 
		 <b>and</b> | <b>or</b>

	unop ::= ‘<b>-</b>’ | <b>not</b> | ‘<b>#</b>’ | ‘<b>~</b>’

</pre>

<p>







</p><p class="footer">最終更新日: 2023年5月2日 20:09:38 UTC</p>
<!--
Last change: revised for Lua 5.4.6
-->



</body></html>