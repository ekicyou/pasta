<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 - Section 4.6</title>
</head>
<body>
<h2>4.6 &ndash; <a name="4.6">Functions and Types</a></h2>

<p>
Here we list all functions and types from the C&nbsp;API in
alphabetical order.
Each function has an indicator like this:
<span class="apii">[-o, +p, <em>x</em>]</span>


<p>
The first field, <code>o</code>,
is how many elements the function pops from the stack.
The second field, <code>p</code>,
is how many elements the function pushes onto the stack.
(Any function always pushes its results after popping its arguments.)
A field in the form <code>x|y</code> means the function can push (or pop)
<code>x</code> or <code>y</code> elements,
depending on the situation;
an interrogation mark '<code>?</code>' means that
we cannot know how many elements the function pops/pushes
by looking only at its arguments.
(For instance, they may depend on what is in the stack.)
The third field, <code>x</code>,
tells whether the function may raise errors:
'<code>-</code>' means the function never raises any error;
'<code>m</code>' means the function may raise only out-of-memory errors;
'<code>v</code>' means the function may raise the errors explained in the text;
'<code>e</code>' means the function can run arbitrary Lua code,
either directly or through metamethods,
and therefore may raise any errors.



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
Converts the acceptable index <code>idx</code>
into an equivalent absolute index
(that is, one that does not depend on the stack size).





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
The type of the memory-allocator function used by Lua states.
The allocator function must provide a
functionality similar to <code>realloc</code>,
but not exactly the same.
Its arguments are
<code>ud</code>, an opaque pointer passed to <a href="#lua_newstate"><code>lua_newstate</code></a>;
<code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
<code>osize</code>, the original size of the block or some code about what
is being allocated;
and <code>nsize</code>, the new size of the block.


<p>
When <code>ptr</code> is not <code>NULL</code>,
<code>osize</code> is the size of the block pointed by <code>ptr</code>,
that is, the size given when it was allocated or reallocated.


<p>
When <code>ptr</code> is <code>NULL</code>,
<code>osize</code> encodes the kind of object that Lua is allocating.
<code>osize</code> is any of
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>, <a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>, or <a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a> when (and only when)
Lua is creating a new object of that type.
When <code>osize</code> is some other value,
Lua is allocating memory for something else.


<p>
Lua assumes the following behavior from the allocator function:


<p>
When <code>nsize</code> is zero,
the allocator must behave like <code>free</code>
and then return <code>NULL</code>.


<p>
When <code>nsize</code> is not zero,
the allocator must behave like <code>realloc</code>.
In particular, the allocator returns <code>NULL</code>
if and only if it cannot fulfill the request.


<p>
Here is a simple implementation for the allocator function,
corresponding to the function <a href="#luaL_alloc"><code>luaL_alloc</code></a> from the
auxiliary library.

<pre>
     void *luaL_alloc (void *ud, void *ptr, size_t osize,
                                            size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
Note that ISO&nbsp;C ensures
that <code>free(NULL)</code> has no effect and that
<code>realloc(NULL,size)</code> is equivalent to <code>malloc(size)</code>.





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
Performs an arithmetic or bitwise operation over the two values
(or one, in the case of negations)
at the top of the stack,
with the value on the top being the second operand,
pops these values, and pushes the result of the operation.
The function follows the semantics of the corresponding Lua operator
(that is, it may call metamethods).


<p>
The value of <code>op</code> must be one of the following constants:

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a></b>:  performs addition (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a></b>:  performs subtraction (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a></b>:  performs multiplication (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a></b>:  performs float division (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a></b>:  performs floor division (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a></b>:  performs modulo (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a></b>:  performs exponentiation (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a></b>:  performs mathematical negation (unary <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a></b>:  performs bitwise NOT (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a></b>:  performs bitwise AND (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a></b>:  performs bitwise OR (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a></b>:  performs bitwise exclusive OR (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a></b>:  performs left shift (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a></b>:  performs right shift (<code>&gt;&gt;</code>)</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
Sets a new panic function and returns the old one (see <a href="#4.4">&sect;4.4</a>).





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
Calls a function.
Like regular Lua calls,
<code>lua_call</code> respects the <code>__call</code> metamethod.
So, here the word "function"
means any callable value.


<p>
To do a call you must use the following protocol:
first, the function to be called is pushed onto the stack;
then, the arguments to the call are pushed
in direct order;
that is, the first argument is pushed first.
Finally you call <a href="#lua_call"><code>lua_call</code></a>;
<code>nargs</code> is the number of arguments that you pushed onto the stack.
When the function returns,
all arguments and the function value are popped
and the call results are pushed onto the stack.
The number of results is adjusted to <code>nresults</code>,
unless <code>nresults</code> is <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>,
which makes all results from the function to be pushed.
In the first case, an explicit number of results,
the caller must ensure that the stack has space for the
returned values.
In the second case, all results,
Lua takes care that the returned values fit into the stack space,
but it does not ensure any extra space in the stack.
The function results are pushed onto the stack in direct order
(the first result is pushed first),
so that after the call the last result is on the top of the stack.


<p>
The maximum value for <code>nresults</code> is 250.


<p>
Any error while calling and running the function is propagated upwards
(with a <code>longjmp</code>).


<p>
The following example shows how the host program can do the
equivalent to this Lua code:

<pre>
     a = f("how", t.x, 14)
</pre><p>
Here it is in&nbsp;C:

<pre>
     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
</pre><p>
Note that the code above is <em>balanced</em>:
at its end, the stack is back to its original configuration.
This is considered good programming practice.





<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
This function behaves exactly like <a href="#lua_call"><code>lua_call</code></a>,
but allows the called function to yield (see <a href="#4.5">&sect;4.5</a>).





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
Type for C&nbsp;functions.


<p>
In order to communicate properly with Lua,
a C&nbsp;function must use the following protocol,
which defines the way parameters and results are passed:
a C&nbsp;function receives its arguments from Lua in its stack
in direct order (the first argument is pushed first).
So, when the function starts,
<code>lua_gettop(L)</code> returns the number of arguments received by the function.
The first argument (if any) is at index 1
and its last argument is at index <code>lua_gettop(L)</code>.
To return values to Lua, a C&nbsp;function just pushes them onto the stack,
in direct order (the first result is pushed first),
and returns in C the number of results.
Any other value in the stack below the results will be properly
discarded by Lua.
Like a Lua function, a C&nbsp;function called by Lua can also return
many results.


<p>
As an example, the following function receives a variable number
of numeric arguments and returns their average and their sum:

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* number of arguments */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
Ensures that the stack has space for at least <code>n</code> extra elements,
that is, that you can safely push up to <code>n</code> values into it.
It returns false if it cannot fulfill the request,
either because it would cause the stack
to be greater than a fixed maximum size
(typically at least several thousand elements) or
because it cannot allocate memory for the extra space.
This function never shrinks the stack;
if the stack already has space for the extra elements,
it is left unchanged.





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
Close all active to-be-closed variables in the main thread,
release all objects in the given Lua state
(calling the corresponding garbage-collection metamethods, if any),
and frees all dynamic memory used by this state.


<p>
On several platforms, you may not need to call this function,
because all resources are naturally released when the host program ends.
On the other hand, long-running programs that create multiple states,
such as daemons or web servers,
will probably need to close states as soon as they are not needed.





<hr><h3><a name="lua_closeslot"><code>lua_closeslot</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_closeslot (lua_State *L, int index);</pre>

<p>
Close the to-be-closed slot at the given index and set its value to <b>nil</b>.
The index must be the last index previously marked to be closed
(see <a href="#lua_toclose"><code>lua_toclose</code></a>) that is still active (that is, not closed yet).


<p>
A <code>__close</code> metamethod cannot yield
when called through this function.





<hr><h3><a name="lua_closethread"><code>lua_closethread</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int lua_closethread (lua_State *L, lua_State *from);</pre>

<p>
Resets a thread, cleaning its call stack and closing all pending
to-be-closed variables.
The parameter <code>from</code> represents the coroutine that is resetting <code>L</code>.
If there is no such coroutine,
this parameter can be <code>NULL</code>.


<p>
Unless <code>L</code> is equal to <code>from</code>,
the call returns a status code:
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> for no errors in the thread
(either the original error that stopped the thread or
errors in closing methods),
or an error status otherwise.
In case of error,
the error object is put on the top of the stack.


<p>
If <code>L</code> is equal to <code>from</code>,
it corresponds to a thread closing itself.
In that case,
the call does not return;
instead, the resume that (re)started the thread returns.
The thread must be running inside a resume.





<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
Compares two Lua values.
Returns 1 if the value at index <code>index1</code> satisfies <code>op</code>
when compared with the value at index <code>index2</code>,
following the semantics of the corresponding Lua operator
(that is, it may call metamethods).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices is not valid.


<p>
The value of <code>op</code> must be one of the following constants:

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a></b>:  compares for equality (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a></b>:  compares for less than (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a></b>:  compares for less or equal (<code>&lt;=</code>)</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
Concatenates the <code>n</code> values at the top of the stack,
pops them, and leaves the result on the top.
If <code>n</code>&nbsp;is&nbsp;1, the result is the single value on the stack
(that is, the function does nothing);
if <code>n</code> is 0, the result is the empty string.
Concatenation is performed following the usual semantics of Lua
(see <a href="#3.4.6">&sect;3.4.6</a>).





<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
Copies the element at index <code>fromidx</code>
into the valid index <code>toidx</code>,
replacing the value at that position.
Values at other positions are not affected.





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_createtable (lua_State *L, int nseq, int nrec);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
Parameter <code>nseq</code> is a hint for how many elements the table
will have as a sequence;
parameter <code>nrec</code> is a hint for how many other elements
the table will have.
Lua may use these hints to preallocate memory for the new table.
This preallocation may help performance when you know in advance
how many elements the table will have.
Otherwise you should use the function <a href="#lua_newtable"><code>lua_newtable</code></a>.





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
Dumps a function as a binary chunk.
Receives a Lua function on the top of the stack
and produces a binary chunk that,
if loaded again,
results in a function equivalent to the one dumped.
As it produces parts of the chunk,
<a href="#lua_dump"><code>lua_dump</code></a> calls function <code>writer</code> (see <a href="#lua_Writer"><code>lua_Writer</code></a>)
with the given <code>data</code>
to write them.


<p>
The function <a href="#lua_dump"><code>lua_dump</code></a> fully preserves the Lua stack
through the calls to the writer function,
except that it may push some values for internal use
before the first call,
and it restores the stack size to its original size
after the last call.


<p>
If <code>strip</code> is true,
the binary representation may not include all debug information
about the function,
to save space.


<p>
The value returned is the error code returned by the last
call to the writer;
0&nbsp;means no errors.





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
Raises a Lua error,
using the value on the top of the stack as the error object.
This function does a long jump,
and therefore never returns
(see <a href="#luaL_error"><code>luaL_error</code></a>).





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gc (lua_State *L, int what, ...);</pre>

<p>
Controls the garbage collector.


<p>
This function performs several tasks,
according to the value of the parameter <code>what</code>.
For options that need extra arguments,
they are listed after the option.

<ul>

<li><b><a name="pdf-LUA_GCCOLLECT"><code>LUA_GCCOLLECT</code></a></b>: 
Performs a full garbage-collection cycle.
</li>

<li><b><a name="pdf-LUA_GCSTOP"><code>LUA_GCSTOP</code></a></b>: 
Stops the garbage collector.
</li>

<li><b><a name="pdf-LUA_GCRESTART"><code>LUA_GCRESTART</code></a></b>: 
Restarts the garbage collector.
</li>

<li><b><a name="pdf-LUA_GCCOUNT"><code>LUA_GCCOUNT</code></a></b>: 
Returns the current amount of memory (in Kbytes) in use by Lua.
</li>

<li><b><a name="pdf-LUA_GCCOUNTB"><code>LUA_GCCOUNTB</code></a></b>: 
Returns the remainder of dividing the current amount of bytes of
memory in use by Lua by 1024.
</li>

<li><b><a name="pdf-LUA_GCSTEP"><code>LUA_GCSTEP</code></a> (size_t n)</b>: 
Performs a step of garbage collection.
</li>

<li><b><a name="pdf-LUA_GCISRUNNING"><code>LUA_GCISRUNNING</code></a></b>: 
Returns a boolean that tells whether the collector is running
(i.e., not stopped).
</li>

<li><b><a name="pdf-LUA_GCINC"><code>LUA_GCINC</code></a></b>: 
Changes the collector to incremental mode.
Returns the previous mode (<code>LUA_GCGEN</code> or <code>LUA_GCINC</code>).
</li>

<li><b><a name="pdf-LUA_GCGEN"><code>LUA_GCGEN</code></a></b>: 
Changes the collector to generational mode.
Returns the previous mode (<code>LUA_GCGEN</code> or <code>LUA_GCINC</code>).
</li>

<li><b><a name="pdf-LUA_GCPARAM"><code>LUA_GCPARAM</code></a> (int param, int val)</b>: 
Changes and/or returns the value of a parameter of the collector.
If <code>val</code> is -1, the call only returns the current value.
The argument <code>param</code> must have one of the following values:

<ul>
<li><b><a name="pdf-LUA_GCPMINORMUL"><code>LUA_GCPMINORMUL</code></a></b>:  The minor multiplier. </li>
<li><b><a name="pdf-LUA_GCPMAJORMINOR"><code>LUA_GCPMAJORMINOR</code></a></b>:  The major-minor multiplier. </li>
<li><b><a name="pdf-LUA_GCPMINORMAJOR"><code>LUA_GCPMINORMAJOR</code></a></b>:  The minor-major multiplier. </li>
<li><b><a name="pdf-LUA_GCPPAUSE"><code>LUA_GCPPAUSE</code></a></b>:  The garbage-collector pause. </li>
<li><b><a name="pdf-LUA_GCPSTEPMUL"><code>LUA_GCPSTEPMUL</code></a></b>:  The step multiplier. </li>
<li><b><a name="pdf-LUA_GCPSTEPSIZE"><code>LUA_GCPSTEPSIZE</code></a></b>:  The step size. </li>
</ul><p>
</li>

</ul>

<p>
For more details about these options,
see <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>.


<p>
This function should not be called by a finalizer.





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
Returns the memory-allocator function of a given state.
If <code>ud</code> is not <code>NULL</code>, Lua stores in <code>*ud</code> the
opaque pointer given when the memory-allocator function was set.





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given index.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
Returns a pointer to a raw memory area associated with the
given Lua state.
The application can use this area for any purpose;
Lua does not use it for anything.


<p>
Each new thread has this area initialized with a copy
of the area of the main thread.


<p>
By default, this area has the size of a pointer to void,
but you can recompile Lua with a different size for this area.
(See <code>LUA_EXTRASPACE</code> in <code>luaconf.h</code>.)





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
Pushes onto the stack the value of the global <code>name</code>.
Returns the type of that value.





<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Pushes onto the stack the value <code>t[i]</code>,
where <code>t</code> is the value at the given index.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
If the value at the given index has a metatable,
the function pushes that metatable onto the stack and returns&nbsp;1.
Otherwise,
the function returns&nbsp;0 and pushes nothing on the stack.





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given index
and <code>k</code> is the value on the top of the stack.


<p>
This function pops the key from the stack,
pushing the resulting value in its place.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
Returns the index of the top element in the stack.
Because indices start at&nbsp;1,
this result is equal to the number of elements in the stack;
in particular, 0&nbsp;means an empty stack.





<hr><h3><a name="lua_getiuservalue"><code>lua_getiuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getiuservalue (lua_State *L, int index, int n);</pre>

<p>
Pushes onto the stack the <code>n</code>-th user value associated with the
full userdata at the given index and
returns the type of the pushed value.


<p>
If the userdata does not have that value,
pushes <b>nil</b> and returns <a href="#pdf-LUA_TNONE"><code>LUA_TNONE</code></a>.





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index,
shifting up the elements above this index to open space.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
The type of integers in Lua.


<p>
By default this type is <code>long long</code>,
(usually a 64-bit two's complement integer),
but that can be changed to <code>long</code> or <code>int</code>
(usually a 32-bit two's complement integer).
(See <code>LUA_INT_TYPE</code> in <code>luaconf.h</code>.)


<p>
Lua also defines the constants
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a> and <a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>,
with the minimum and the maximum values that fit in this type.





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a boolean,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a C&nbsp;function,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a function
(either C or Lua), and 0&nbsp;otherwise.





<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is an integer
(that is, the value is a number and is represented as an integer),
and 0&nbsp;otherwise.





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a light userdata,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is <b>nil</b>,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
Returns 1 if the given index is not valid,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
Returns 1 if the given index is not valid
or if the value at this index is <b>nil</b>,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a number
or a string convertible to a number,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a string
or a number (which is always convertible to a string),
and 0&nbsp;otherwise.





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a table,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a thread,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a userdata
(either full or light), and 0&nbsp;otherwise.





<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
Returns 1 if the given coroutine can yield,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
The type for continuation-function contexts.
It must be a numeric type.
This type is defined as <code>intptr_t</code>
when <code>intptr_t</code> is available,
so that it can store pointers too.
Otherwise, it is defined as <code>ptrdiff_t</code>.





<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
Type for continuation functions (see <a href="#4.5">&sect;4.5</a>).





<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
Returns the length of the value at the given index.
It is equivalent to the '<code>#</code>' operator in Lua (see <a href="#3.4.7">&sect;3.4.7</a>) and
may trigger a metamethod for the "length" event (see <a href="#2.4">&sect;2.4</a>).
The result is pushed on the stack.





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
Loads a Lua chunk without running it.
If there are no errors,
<code>lua_load</code> pushes the compiled chunk as a Lua
function on top of the stack.
Otherwise, it pushes an error message.


<p>
The <code>lua_load</code> function uses a user-supplied <code>reader</code> function
to read the chunk (see <a href="#lua_Reader"><code>lua_Reader</code></a>).
The <code>data</code> argument is an opaque value passed to the reader function.


<p>
The <code>chunkname</code> argument gives a name to the chunk,
which is used for error messages and in debug information (see <a href="#4.7">&sect;4.7</a>).


<p>
<code>lua_load</code> automatically detects whether the chunk is text or binary
and loads it accordingly (see program <code>luac</code>).
The string <code>mode</code> works as in function <a href="#pdf-load"><code>load</code></a>,
with the addition that
a <code>NULL</code> value is equivalent to the string "<code>bt</code>".
Moreover, it may have a '<code>B</code>' instead of a '<code>b</code>',
meaning a <em>fixed buffer</em> with the binary dump.


<p>
A fixed buffer means that the address returned by the reader function
will contain the chunk until everything created by the chunk has
been collected;
therefore, Lua can avoid copying to internal structures
some parts of the chunk.
(In general, a fixed buffer would keep its contents
until the end of the program,
for instance with the chunk in ROM.)
Moreover, for a fixed buffer,
the reader function should return the entire chunk in the first read.
(As an example, <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a> does that,
which means that you can use it to load fixed buffers.)


<p>
The function <a href="#lua_load"><code>lua_load</code></a> fully preserves the Lua stack
through the calls to the reader function,
except that it may push some values for internal use
before the first call,
and it restores the stack size to its original size plus one
(for the pushed result) after the last call.


<p>
<code>lua_load</code> can return
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>, <a href="#pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>, or <a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>.
The function may also return other values corresponding to
errors raised by the read function (see <a href="#4.4.1">&sect;4.4.1</a>).


<p>
If the resulting function has upvalues,
its first upvalue is set to the value of the global environment
stored at index <code>LUA_RIDX_GLOBALS</code> in the registry (see <a href="#4.3">&sect;4.3</a>).
When loading main chunks,
this upvalue will be the <code>_ENV</code> variable (see <a href="#2.2">&sect;2.2</a>).
Other upvalues are initialized with <b>nil</b>.





<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud,
                                   unsigned int seed);</pre>

<p>
Creates a new independent state and returns its main thread.
Returns <code>NULL</code> if it cannot create the state
(due to lack of memory).
The argument <code>f</code> is the allocator function;
Lua will do all memory allocation for this state
through this function (see <a href="#lua_Alloc"><code>lua_Alloc</code></a>).
The second argument, <code>ud</code>, is an opaque pointer that Lua
passes to the allocator in every call.
The third argument, <code>seed</code>,
is a seed for the hashing of strings.





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
It is equivalent to <code>lua_createtable(L,0,0)</code>.





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
Creates a new thread, pushes it on the stack,
and returns a pointer to a <a href="#lua_State"><code>lua_State</code></a> that represents this new thread.
The new thread returned by this function shares with the original thread
its global environment,
but has an independent execution stack.


<p>
Threads are subject to garbage collection,
like any Lua object.





<hr><h3><a name="lua_newuserdatauv"><code>lua_newuserdatauv</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue);</pre>

<p>
This function creates and pushes on the stack a new full userdata,
with <code>nuvalue</code> associated Lua values, called <code>user values</code>,
plus an associated block of raw memory with <code>size</code> bytes.
(The user values can be set and read with the functions
<a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a> and <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a>.)


<p>
The function returns the address of the block of memory.
Lua ensures that this address is valid as long as
the corresponding userdata is alive (see <a href="#2.5">&sect;2.5</a>).
Moreover, if the userdata is marked for finalization (see <a href="#2.5.3">&sect;2.5.3</a>),
its address is valid at least until the call to its finalizer.





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>v</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
Pops a key from the stack,
and pushes a key&ndash;value pair from the table at the given index,
the "next" pair after the given key.
If there are no more elements in the table,
then <a href="#lua_next"><code>lua_next</code></a> returns&nbsp;0 and pushes nothing.


<p>
A typical table traversal looks like this:

<pre>
     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }
</pre>

<p>
While traversing a table,
avoid calling <a href="#lua_tolstring"><code>lua_tolstring</code></a> directly on a key,
unless you know that the key is actually a string.
Recall that <a href="#lua_tolstring"><code>lua_tolstring</code></a> may change
the value at the given index;
this confuses the next call to <a href="#lua_next"><code>lua_next</code></a>.


<p>
This function may raise an error if the given key
is neither <b>nil</b> nor present in the table.
See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying
the table during its traversal.





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
The type of floats in Lua.


<p>
By default this type is double,
but that can be changed to a single float or a long double.
(See <code>LUA_FLOAT_TYPE</code> in <code>luaconf.h</code>.)





<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
Tries to convert a Lua float to a Lua integer;
the float <code>n</code> must have an integral value.
If that value is within the range of Lua integers,
it is converted to an integer and assigned to <code>*p</code>.
The macro results in a boolean indicating whether the
conversion was successful.
(Note that this range test can be tricky to do
correctly without this macro, due to rounding.)


<p>
This macro may evaluate its arguments more than once.





<hr><h3><a name="lua_numbertocstring"><code>lua_numbertocstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>unsigned lua_numbertocstring (lua_State *L, int idx,
                                        char *buff);</pre>

<p>
Converts the number at acceptable index <code>idx</code> to a string
and puts the result in <code>buff</code>.
The buffer must have a size of at least <a name="pdf-LUA_N2SBUFFSZ"><code>LUA_N2SBUFFSZ</code></a> bytes.
The conversion follows a non-specified format (see <a href="#3.4.3">&sect;3.4.3</a>).
The function returns the number of bytes written to the buffer
(including the final zero),
or zero if the value at <code>idx</code> is not a number.





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
Calls a function (or a callable object) in protected mode.


<p>
Both <code>nargs</code> and <code>nresults</code> have the same meaning as
in <a href="#lua_call"><code>lua_call</code></a>.
If there are no errors during the call,
<a href="#lua_pcall"><code>lua_pcall</code></a> behaves exactly like <a href="#lua_call"><code>lua_call</code></a>.
However, if there is any error,
<a href="#lua_pcall"><code>lua_pcall</code></a> catches it,
pushes a single value on the stack (the error object),
and returns an error code.
Like <a href="#lua_call"><code>lua_call</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a> always removes the function
and its arguments from the stack.


<p>
If <code>msgh</code> is 0,
then the error object returned on the stack
is exactly the original error object.
Otherwise, <code>msgh</code> is the stack index of a
<em>message handler</em>.
(This index cannot be a pseudo-index.)
In case of runtime errors,
this handler will be called with the error object
and its return value will be the object
returned on the stack by <a href="#lua_pcall"><code>lua_pcall</code></a>.


<p>
Typically, the message handler is used to add more debug
information to the error object, such as a stack traceback.
Such information cannot be gathered after the return of <a href="#lua_pcall"><code>lua_pcall</code></a>,
since by then the stack has unwound.


<p>
The <a href="#lua_pcall"><code>lua_pcall</code></a> function returns one of the following status codes:
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>, <a href="#pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>, <a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>, or <a href="#pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>.





<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
This function behaves exactly like <a href="#lua_pcall"><code>lua_pcall</code></a>,
except that it allows the called function to yield (see <a href="#4.5">&sect;4.5</a>).





<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>e</em>]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
Pops <code>n</code> elements from the stack.
It is implemented as a macro over <a href="#lua_settop"><code>lua_settop</code></a>.





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
Pushes a boolean value with value <code>b</code> onto the stack.





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
Pushes a new C&nbsp;closure onto the stack.
This function receives a pointer to a C&nbsp;function
and pushes onto the stack a Lua value of type <code>function</code> that,
when called, invokes the corresponding C&nbsp;function.
The parameter <code>n</code> tells how many upvalues this function will have
(see <a href="#4.2">&sect;4.2</a>).


<p>
Any function to be callable by Lua must
follow the correct protocol to receive its parameters
and return its results (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
the so called upvalues;
these upvalues are then accessible to the function whenever it is called.
This association is called a C&nbsp;closure (see <a href="#4.2">&sect;4.2</a>).
To create a C&nbsp;closure,
first the initial values for its upvalues must be pushed onto the stack.
(When there are multiple upvalues, the first value is pushed first.)
Then <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
is called to create and push the C&nbsp;function onto the stack,
with the argument <code>n</code> telling how many values will be
associated with the function.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> also pops these values from the stack.


<p>
The maximum value for <code>n</code> is 255.


<p>
When <code>n</code> is zero,
this function creates a <em>light C&nbsp;function</em>,
which is just a pointer to the C&nbsp;function.
In that case, it never raises a memory error.





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Pushes a C&nbsp;function onto the stack.
This function is equivalent to <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> with no upvalues.





<hr><h3><a name="lua_pushexternalstring"><code>lua_pushexternalstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushexternalstring (lua_State *L,
                const char *s, size_t len, lua_Alloc falloc, void *ud);</pre>

<p>
Creates an <em>external string</em>,
that is, a string that uses memory not managed by Lua.
The pointer <code>s</code> points to the external buffer
holding the string content,
and <code>len</code> is the length of the string.
The string should have a zero at its end,
that is, the condition <code>s[len] == '\0'</code> should hold.
As with any string in Lua,
the length must fit in a Lua integer.


<p>
If <code>falloc</code> is different from <code>NULL</code>,
that function will be called by Lua
when the external buffer is no longer needed.
The contents of the buffer should not change before this call.
The function will be called with the given <code>ud</code>,
the string <code>s</code> as the block,
the length plus one (to account for the ending zero) as the old size,
and 0 as the new size.


<p>
Even when using an external buffer,
Lua still has to allocate a header for the string.
In case of a memory-allocation error,
Lua will call <code>falloc</code> before raising the error.


<p>
The function returns a pointer to the string (that is, <code>s</code>).





<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
Pushes onto the stack a formatted string
and returns a pointer to this string (see <a href="#4.1.3">&sect;4.1.3</a>).
The result is a copy of <code>fmt</code> with
each <em>conversion specifier</em> replaced by a string representation
of its respective extra argument.
A conversion specifier (and its corresponding extra argument) can be
'<code>%%</code>' (inserts the character '<code>%</code>'),
'<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
'<code>%f</code>' (inserts a <a href="#lua_Number"><code>lua_Number</code></a>),
'<code>%I</code>' (inserts a <a href="#lua_Integer"><code>lua_Integer</code></a>),
'<code>%p</code>' (inserts a void pointer),
'<code>%d</code>' (inserts an <code>int</code>),
'<code>%c</code>' (inserts an <code>int</code> as a one-byte character), and
'<code>%U</code>' (inserts an <code>unsigned long</code> as a UTF-8 byte sequence).


<p>
Every occurrence of '<code>%</code>' in the string <code>fmt</code>
must form a valid conversion specifier.


<p>
Besides memory allocation errors,
this function may raise an error if the resulting string is too large.





<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
Pushes the global environment onto the stack.





<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
Pushes an integer with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
Pushes a light userdata onto the stack.


<p>
Userdata represent C&nbsp;values in Lua.
A <em>light userdata</em> represents a pointer, a <code>void*</code>.
It is a value (like a number):
you do not create it, it has no individual metatable,
and it is not collected (as it was never created).
A light userdata is equal to "any"
light userdata with the same C&nbsp;address.





<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
This macro is equivalent to <a href="#lua_pushstring"><code>lua_pushstring</code></a>,
but should be used only when <code>s</code> is a literal string.
(Lua may optimize this case.)





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
Pushes the string pointed to by <code>s</code> with size <code>len</code>
onto the stack.
Lua will make or reuse an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.
The string can contain any binary data,
including embedded zeros.


<p>
Returns a pointer to the internal copy of the string (see <a href="#4.1.3">&sect;4.1.3</a>).


<p>
Besides memory allocation errors,
this function may raise an error if the string is too large.





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
Pushes a nil value onto the stack.





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
Pushes a float with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
Pushes the zero-terminated string pointed to by <code>s</code>
onto the stack.
Lua will make or reuse an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.


<p>
Returns a pointer to the internal copy of the string (see <a href="#4.1.3">&sect;4.1.3</a>).


<p>
If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and returns <code>NULL</code>.





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
Pushes the thread represented by <code>L</code> onto the stack.
Returns 1 if this thread is the main thread of its state.





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
Pushes a copy of the element at the given index
onto the stack.





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
Equivalent to <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>,
except that it receives a <code>va_list</code>
instead of a variable number of arguments,
and it does not raise errors.
Instead, in case of errors it pushes the error message
and returns <code>NULL</code>.





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
Returns 1 if the two values in indices <code>index1</code> and
<code>index2</code> are primitively equal
(that is, equal without calling the <code>__eq</code> metamethod).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices are not valid.





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_gettable"><code>lua_gettable</code></a>, but does a raw access
(i.e., without metamethods).
The value at <code>index</code> must be a table.





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Pushes onto the stack the value <code>t[n]</code>,
where <code>t</code> is the table at the given index.
The access is raw,
that is, it does not use the <code>__index</code> metavalue.


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the table at the given index and
<code>k</code> is the pointer <code>p</code> represented as a light userdata.
The access is raw;
that is, it does not use the <code>__index</code> metavalue.


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Unsigned lua_rawlen (lua_State *L, int index);</pre>

<p>
Returns the raw "length" of the value at the given index:
for strings, this is the string length;
for tables, this is the result of the length operator ('<code>#</code>')
with no metamethods;
for userdata, this is the size of the block of memory allocated
for the userdata.
For other values, this call returns&nbsp;0.





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_settable"><code>lua_settable</code></a>, but does a raw assignment
(i.e., without metamethods).
The value at <code>index</code> must be a table.





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Does the equivalent of <code>t[i] = v</code>,
where <code>t</code> is the table at the given index
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not use the <code>__newindex</code> metavalue.





<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
Does the equivalent of <code>t[p] = v</code>,
where <code>t</code> is the table at the given index,
<code>p</code> is encoded as a light userdata,
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not use the <code>__newindex</code> metavalue.





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
The reader function used by <a href="#lua_load"><code>lua_load</code></a>.
Every time <a href="#lua_load"><code>lua_load</code></a> needs another piece of the chunk,
it calls the reader,
passing along its <code>data</code> parameter.
The reader must return a pointer to a block of memory
with a new piece of the chunk
and set <code>size</code> to the block size.
The block must exist until the reader function is called again.
To signal the end of the chunk,
the reader must return <code>NULL</code> or set <code>size</code> to zero.
The reader function may return pieces of any size greater than zero.





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
Sets the C&nbsp;function <code>f</code> as the new value of global <code>name</code>.
It is defined as a macro:

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
Removes the element at the given valid index,
shifting down the elements above this index to fill the gap.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index
without shifting any element
(therefore replacing the value at that given index),
and then pops the top element.





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs,
                          int *nresults);</pre>

<p>
Starts and resumes a coroutine in the given thread <code>L</code>.


<p>
To start a coroutine,
you push the main function plus any arguments
onto the empty stack of the thread.
then you call <a href="#lua_resume"><code>lua_resume</code></a>,
with <code>nargs</code> being the number of arguments.
The function returns when the coroutine suspends,
finishes its execution, or raises an unprotected error.
When it returns without errors,
<code>*nresults</code> is updated and
the top of the stack contains
the <code>*nresults</code> values passed to <a href="#lua_yield"><code>lua_yield</code></a>
or returned by the body function.
<a href="#lua_resume"><code>lua_resume</code></a> returns
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the coroutine yields,
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> if the coroutine finishes its execution
without errors,
or an error code in case of errors (see <a href="#4.4.1">&sect;4.4.1</a>).
In case of errors,
the error object is pushed on the top of the stack.
(In that case, <code>nresults</code> is not updated,
as its value would have to be 1 for the sole error object.)


<p>
To resume a suspended coroutine,
you remove the <code>*nresults</code> yielded values from its stack,
push the values to be passed as results from <code>yield</code>,
and then call <a href="#lua_resume"><code>lua_resume</code></a>.


<p>
The parameter <code>from</code> represents the coroutine that is resuming <code>L</code>.
If there is no such coroutine,
this parameter can be <code>NULL</code>.





<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
Rotates the stack elements between the valid index <code>idx</code>
and the top of the stack.
The elements are rotated <code>n</code> positions in the direction of the top,
for a positive <code>n</code>,
or <code>-n</code> positions in the direction of the bottom,
for a negative <code>n</code>.
The absolute value of <code>n</code> must not be greater than the size
of the slice being rotated.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
Changes the allocator function of a given state to <code>f</code>
with user data <code>ud</code>.





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
Pops a value from the stack and
sets it as the new value of global <code>name</code>.





<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Does the equivalent to <code>t[n] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_setiuservalue"><code>lua_setiuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>int lua_setiuservalue (lua_State *L, int index, int n);</pre>

<p>
Pops a value from the stack and sets it as
the new <code>n</code>-th user value associated to the
full userdata at the given index.
Returns 0 if the userdata does not have that value.





<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>
Pops a table or <b>nil</b> from the stack and
sets that value as the new metatable for the value at the given index.
(<b>nil</b> means no metatable.)


<p>
(For historical reasons, this function returns an <code>int</code>,
which now is always 1.)





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index,
<code>v</code> is the value on the top of the stack,
and <code>k</code> is the value just below the top.


<p>
This function pops both the key and the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
Receives any acceptable stack index, or&nbsp;0,
and sets the stack top to this index.
If the new top is greater than the old one,
then the new elements are filled with <b>nil</b>.
If <code>index</code> is&nbsp;0, then all stack elements are removed.


<p>
This function can run arbitrary code when removing an index
marked as to-be-closed from the stack.





<hr><h3><a name="lua_setwarnf"><code>lua_setwarnf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);</pre>

<p>
Sets the warning function to be used by Lua to emit warnings
(see <a href="#lua_WarnFunction"><code>lua_WarnFunction</code></a>).
The <code>ud</code> parameter sets the value <code>ud</code> passed to
the warning function.





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
An opaque structure that points to a thread and indirectly
(through the thread) to the whole state of a Lua interpreter.
The Lua library is fully reentrant:
it has no global variables.
All information about a state is accessible through this structure.


<p>
A pointer to this structure must be passed as the first argument to
every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,
which creates a Lua state from scratch.





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
Returns the status of the thread <code>L</code>.


<p>
The status can be <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> for a normal thread,
an error code if the thread finished the execution
of a <a href="#lua_resume"><code>lua_resume</code></a> with an error,
or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the thread is suspended.


<p>
You can call functions only in threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>.
You can resume threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
(to start a new coroutine) or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
(to resume a coroutine).





<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
Converts the zero-terminated string <code>s</code> to a number,
pushes that number into the stack,
and returns the total size of the string,
that is, its length plus one.
The conversion can result in an integer or a float,
according to the lexical conventions of Lua (see <a href="#3.1">&sect;3.1</a>).
The string may have leading and trailing whitespaces and a sign.
If the string is not a valid numeral,
returns 0 and pushes nothing.
(Note that the result can be used as a boolean,
true if the conversion succeeds.)





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;boolean
value (0&nbsp;or&nbsp;1).
Like all tests in Lua,
<a href="#lua_toboolean"><code>lua_toboolean</code></a> returns true for any Lua value
different from <b>false</b> and <b>nil</b>;
otherwise it returns false.
(If you want to accept only actual boolean values,
use <a href="#lua_isboolean"><code>lua_isboolean</code></a> to test the value's type.)





<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
Converts a value at the given index to a C&nbsp;function.
That value must be a C&nbsp;function;
otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_toclose"><code>lua_toclose</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void lua_toclose (lua_State *L, int index);</pre>

<p>
Marks the given index in the stack as a
to-be-closed slot (see <a href="#3.3.8">&sect;3.3.8</a>).
Like a to-be-closed variable in Lua,
the value at that slot in the stack will be closed
when it goes out of scope.
Here, in the context of a C function,
to go out of scope means that the running function returns to Lua,
or there is an error,
or the slot is removed from the stack through
<a href="#lua_settop"><code>lua_settop</code></a> or <a href="#lua_pop"><code>lua_pop</code></a>,
or there is a call to <a href="#lua_closeslot"><code>lua_closeslot</code></a>.
A slot marked as to-be-closed should not be removed from the stack
by any other function in the API except <a href="#lua_settop"><code>lua_settop</code></a> or <a href="#lua_pop"><code>lua_pop</code></a>,
unless previously deactivated by <a href="#lua_closeslot"><code>lua_closeslot</code></a>.


<p>
This function raises an error if the value at the given slot
neither has a <code>__close</code> metamethod nor is a false value.


<p>
This function should not be called for an index
that is equal to or below an active to-be-closed slot.


<p>
Note that, both in case of errors and of a regular return,
by the time the <code>__close</code> metamethod runs,
the C&nbsp;stack was already unwound,
so that any automatic C&nbsp;variable declared in the calling function
(e.g., a buffer) will be out of scope.





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tointegerx"><code>lua_tointegerx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the signed integral type <a href="#lua_Integer"><code>lua_Integer</code></a>.
The Lua value must be an integer,
or a number or string convertible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>);
otherwise, <code>lua_tointegerx</code> returns&nbsp;0.


<p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;string.
The Lua value must be a string or a number;
otherwise, the function returns <code>NULL</code>.
If the value is a number,
then <code>lua_tolstring</code> also
<em>changes the actual value in the stack to a string</em>.
(This change confuses <a href="#lua_next"><code>lua_next</code></a>
when <code>lua_tolstring</code> is applied to keys during a table traversal.)


<p>
If <code>len</code> is not <code>NULL</code>,
the function sets <code>*len</code> with the string length.
The returned C&nbsp;string always has a zero ('<code>\0</code>')
after its last character,
but can contain other zeros in its body.


<p>
The pointer returned by <code>lua_tolstring</code>
may be invalidated by the garbage collector if the
corresponding Lua value is removed from the stack (see <a href="#4.1.3">&sect;4.1.3</a>).


<p>
This function can raise memory errors only
when converting a number to a string
(as then it may create a new string).





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the C&nbsp;type <a href="#lua_Number"><code>lua_Number</code></a> (see <a href="#lua_Number"><code>lua_Number</code></a>).
The Lua value must be a number or a string convertible to a number
(see <a href="#3.4.3">&sect;3.4.3</a>);
otherwise, <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> returns&nbsp;0.


<p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a generic
C&nbsp;pointer (<code>void*</code>).
The value can be a userdata, a table, a thread, a string, or a function;
otherwise, <code>lua_topointer</code> returns <code>NULL</code>.
Different objects will give different pointers.
There is no way to convert the pointer back to its original value.


<p>
Typically this function is used only for hashing and debug information.





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tolstring"><code>lua_tolstring</code></a> with <code>len</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a Lua thread
(represented as <code>lua_State*</code>).
This value must be a thread;
otherwise, the function returns <code>NULL</code>.





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
If the value at the given index is a full userdata,
returns its memory-block address.
If the value is a light userdata,
returns its value (a pointer).
Otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
Returns the type of the value in the given valid index,
or <code>LUA_TNONE</code> for a non-valid but acceptable index.
The types returned by <a href="#lua_type"><code>lua_type</code></a> are coded by the following constants
defined in <code>lua.h</code>:
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>,
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>,
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>,
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>,
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>,
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>,
and
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>.





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
Returns the name of the type encoded by the value <code>tp</code>,
which must be one the values returned by <a href="#lua_type"><code>lua_type</code></a>.





<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
The unsigned version of <a href="#lua_Integer"><code>lua_Integer</code></a>.





<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
Returns the pseudo-index that represents the <code>i</code>-th upvalue of
the running function (see <a href="#4.2">&sect;4.2</a>).
<code>i</code> must be in the range <em>[1,256]</em>.





<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_version (lua_State *L);</pre>

<p>
Returns the version number of this core.





<hr><h3><a name="lua_WarnFunction"><code>lua_WarnFunction</code></a></h3>
<pre>typedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);</pre>

<p>
The type of warning functions, called by Lua to emit warnings.
The first parameter is an opaque pointer
set by <a href="#lua_setwarnf"><code>lua_setwarnf</code></a>.
The second parameter is the warning message.
The third parameter is a boolean that
indicates whether the message is
to be continued by the message in the next call.


<p>
See <a href="#pdf-warn"><code>warn</code></a> for more details about warnings.





<hr><h3><a name="lua_warning"><code>lua_warning</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_warning (lua_State *L, const char *msg, int tocont);</pre>

<p>
Emits a warning with the given message.
A message in a call with <code>tocont</code> true should be
continued in another call to this function.


<p>
See <a href="#pdf-warn"><code>warn</code></a> for more details about warnings.





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
The type of the writer function used by <a href="#lua_dump"><code>lua_dump</code></a>.
Every time <a href="#lua_dump"><code>lua_dump</code></a> produces another piece of chunk,
it calls the writer,
passing along the buffer to be written (<code>p</code>),
its size (<code>sz</code>),
and the <code>ud</code> parameter supplied to <a href="#lua_dump"><code>lua_dump</code></a>.


<p>
After <a href="#lua_dump"><code>lua_dump</code></a> writes its last piece,
it will signal that by calling the writer function one more time,
with a <code>NULL</code> buffer (and size 0).


<p>
The writer returns an error code:
0&nbsp;means no errors;
any other value means an error and stops <a href="#lua_dump"><code>lua_dump</code></a> from
calling the writer again.





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
Exchange values between different threads of the same state.


<p>
This function pops <code>n</code> values from the stack <code>from</code>,
and pushes them onto the stack <code>to</code>.





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
This function is equivalent to <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
but it has no continuation (see <a href="#4.5">&sect;4.5</a>).
Therefore, when the thread resumes,
it continues the function that called
the function calling <code>lua_yield</code>.
To avoid surprises,
this function should be called only in a tail call.





<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
Yields a coroutine (thread).


<p>
When a C&nbsp;function calls <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
the running coroutine suspends its execution,
and the call to <a href="#lua_resume"><code>lua_resume</code></a> that started this coroutine returns.
The parameter <code>nresults</code> is the number of values from the stack
that will be passed as results to <a href="#lua_resume"><code>lua_resume</code></a>.


<p>
When the coroutine is resumed again,
Lua calls the given continuation function <code>k</code> to continue
the execution of the C&nbsp;function that yielded (see <a href="#4.5">&sect;4.5</a>).
This continuation function receives the same stack
from the previous function,
with the <code>n</code> results removed and
replaced by the arguments passed to <a href="#lua_resume"><code>lua_resume</code></a>.
Moreover,
the continuation function receives the value <code>ctx</code>
that was passed to <a href="#lua_yieldk"><code>lua_yieldk</code></a>.


<p>
Usually, this function does not return;
when the coroutine eventually resumes,
it continues executing the continuation function.
However, there is one special case,
which is when this function is called
from inside a line or a count hook (see <a href="#4.7">&sect;4.7</a>).
In that case, <code>lua_yieldk</code> should be called with no continuation
(probably in the form of <a href="#lua_yield"><code>lua_yield</code></a>) and no results,
and the hook should return immediately after the call.
Lua will yield and,
when the coroutine resumes again,
it will continue the normal execution
of the (Lua) function that triggered the hook.


<p>
This function can raise an error if it is called from a thread
with a pending C call with no continuation function
(what is called a <em>C-call boundary</em>),
or it is called from a thread that is not running inside a resume
(typically the main thread).








</body>
</html>
