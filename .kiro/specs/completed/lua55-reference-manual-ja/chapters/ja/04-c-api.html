<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 Reference Manual - Chapter 04</title>
</head>
<body>
<h1>4 – <a name="4">アプリケーションプログラミングインターフェイス</a></h1>



<p>このセクションでは、Lua の C API、つまり、Lua と通信するためにホストプログラムで使用できる C 関数のセットについて説明します。すべての API 関数および関連する型と定数は、ヘッダーファイル <a name="pdf-lua.h"><code>lua.h</code></a> で宣言されています。</p><p>「関数」という用語を使用する場合でも、API の任意の機能は、代わりにマクロとして提供される場合があります。特に明記されていない限り、そのようなすべてのマクロは、引数を正確に一度だけ使用します（常に Lua ステートである最初の引数を除く）。したがって、隠れた副作用は生成されません。</p><p>ほとんどの C ライブラリと同様に、Lua API 関数は、引数の有効性または一貫性をチェックしません。ただし、マクロ <a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a> を定義して Lua をコンパイルすることにより、この動作を変更できます。</p><p>Lua ライブラリは完全にリエントラントです。つまり、グローバル変数はありません。必要なすべての情報を、<em>Lua ステート</em>と呼ばれる動的な構造に保持します。</p><p>各 Lua ステートには、独立した協調的な実行ラインに対応する1つ以上のスレッドがあります。型 <a href="#lua_State"><code>lua_State</code></a> は（その名前にもかかわらず）スレッドを参照します。（間接的に、スレッドを介して、スレッドに関連付けられている Lua ステートも参照します。）</p><p>スレッドへのポインタは、ライブラリ内のすべての関数への最初の引数として渡す必要があります。ただし、<a href="#lua_newstate"><code>lua_newstate</code></a> は例外です。これは、Lua ステートを最初から作成し、新しいステートの<em>メインスレッド</em>へのポインタを返します。</p><h2>4.1 – <a name="4.1">スタック</a></h2>



<p>Lua は、値を C との間で受け渡すために、<em>仮想スタック</em>を使用します。このスタック内の各要素は、Lua 値（<b>nil</b>、数値、文字列など）を表します。API 内の関数は、受け取る Lua ステートパラメータを介してこのスタックにアクセスできます。</p><p>LuaがCを呼び出すたびに、呼び出された関数は新しいスタックを取得します。このスタックは、以前のスタックや、まだアクティブなC関数のスタックとは独立しています。このスタックには、最初にC関数への引数が含まれており、C関数は一時的なLua値を保存し、呼び出し元に返される結果をプッシュする必要があります（<a href="#lua_CFunction"><code>lua_CFunction</code></a>を参照）。</p><p>便宜上、APIのほとんどのクエリ操作は厳密なスタック規律に従いません。代わりに、<em>インデックス</em>を使用してスタック内の任意の要素を参照できます。正のインデックスは絶対スタック位置を表し、スタックの底を1として始まります。負のインデックスは、スタックの最上部を基準としたオフセットを表します。より具体的には、スタックに<em>n</em>個の要素がある場合、インデックス1は最初の要素（つまり、最初にスタックにプッシュされた要素）を表し、インデックス<em>n</em>は最後の要素を表します。インデックス-1も最後の要素（つまり、最上部の要素）を表し、インデックス-<em>n</em>は最初の要素を表します。</p><h3>4.1.1 – <a name="4.1.1">スタックサイズ</a></h3>

<p>Lua APIを操作するときは、一貫性を確保する責任があります。特に、<em>スタックオーバーフローを制御する責任があります</em>。API関数を呼び出すときは、スタックに結果を格納するのに十分な空き容量があることを確認する必要があります。</p><p>上記ルールには1つの例外があります。結果の数が固定されていないLua関数を呼び出す場合（<a href="#lua_call"><code>lua_call</code></a>を参照）、Luaはスタックにすべての結果を格納するのに十分なスペースがあることを保証します。ただし、追加のスペースは保証しません。したがって、このような呼び出しの後にスタックに何かをプッシュする前に、<a href="#lua_checkstack"><code>lua_checkstack</code></a>を使用する必要があります。</p><p>LuaがCを呼び出すたびに、スタックに少なくとも<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>個の追加要素のためのスペースがあることを保証します。つまり、最大で<code>LUA_MINSTACK</code>個の値を安全にプッシュできます。<code>LUA_MINSTACK</code>は20として定義されているため、コードが要素をスタックにプッシュするループがない限り、通常はスタック領域を気にする必要はありません。必要に応じて、関数<a href="#lua_checkstack"><code>lua_checkstack</code></a>を使用して、スタックに新しい要素をプッシュするための十分なスペースがあることを確認できます。</p><h3>4.1.2 – <a name="4.1.2">有効なインデックスと許容可能なインデックス</a></h3>

<p>スタックインデックスを受け取るAPIの関数は、<em>有効なインデックス</em>または<em>許容可能なインデックス</em>でのみ機能します。</p><p><em>有効なインデックス</em>とは、変更可能なLua値を格納する位置を参照するインデックスです。これは、1からスタックの最上部（<code>1 ≤ abs(index) ≤ top</code>）までのスタックインデックスと、Cコードからアクセスできるがスタックにはないいくつかの位置を表す<em>擬似インデックス</em>で構成されます。擬似インデックスは、レジストリ（<a href="#4.3">§4.3</a>を参照）とC関数のアップバリュー（<a href="#4.2">§4.2</a>を参照）にアクセスするために使用されます。</p><p>特定の変更可能な位置を必要とせず、値のみを必要とする関数（クエリ関数など）は、許容可能なインデックスで呼び出すことができます。<em>許容可能なインデックス</em>は、有効なインデックスのいずれかですが、スタック用に割り当てられた領域内のスタックの最上部より後の任意の正のインデックス、つまりスタックサイズまでのインデックスにすることもできます。（0は許容可能なインデックスではないことに注意してください。）現在のC関数の実際のアップバリュー数よりも大きいアップバリュー（<a href="#4.2">§4.2</a>を参照）へのインデックスも許容されます（ただし、無効です）。特に記載がない限り、APIの関数は許容可能なインデックスで動作します。</p><p>許容可能なインデックスは、スタックをクエリするときにスタックの最上部に対する追加のテストを回避するのに役立ちます。たとえば、C関数は、3番目の引数があるかどうかを確認する必要なく、つまり3が有効なインデックスであるかどうかを確認する必要なく、3番目の引数をクエリできます。</p><p>許容可能なインデックスで呼び出すことができる関数の場合、無効なインデックスは、仮想型<a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>の値を含むかのように扱われ、これはnil値のように動作します。</p><h3>4.1.3 – <a name="4.1.3">文字列へのポインタ</a></h3>

<p>APIのいくつかの関数は、スタック内のLua文字列へのポインタ（<code>const char*</code>）を返します。（<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>、<a href="#lua_pushlstring"><code>lua_pushlstring</code></a>、<a href="#lua_pushstring"><code>lua_pushstring</code></a>、<a href="#lua_tolstring"><code>lua_tolstring</code></a>を参照。また、補助ライブラリの<a href="#luaL_checklstring"><code>luaL_checklstring</code></a>、<a href="#luaL_checkstring"><code>luaL_checkstring</code></a>、<a href="#luaL_tolstring"><code>luaL_tolstring</code></a>も参照）。</p><p>一般に、Luaのガベージコレクションは内部メモリを解放または移動し、内部文字列へのポインタを無効にする可能性があります。これらのポインタを安全に使用できるように、APIは、スタックインデックスの文字列へのポインタは、そのインデックスの文字列値がスタックから削除されない限り有効であることを保証します。（ただし、別のインデックスに移動することはできます。）インデックスが（アップバリューを参照する）擬似インデックスである場合、ポインタは、対応する呼び出しがアクティブであり、対応するアップバリューが変更されない限り有効です。</p><p>デバッグインターフェースの一部の関数も、<a href="#lua_getlocal"><code>lua_getlocal</code></a>、<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>、<a href="#lua_setlocal"><code>lua_setlocal</code></a>、<a href="#lua_setupvalue"><code>lua_setupvalue</code></a>など、文字列へのポインタを返します。これらの関数では、呼び出し元の関数がアクティブであり、指定されたクロージャ（指定されている場合）がスタック内にある限り、ポインタが有効であることが保証されます。</p><p>これらの保証を除いて、ガベージコレクタは内部文字列へのポインタを自由に無効にすることができます。</p><h2>4.2 – <a name="4.2">Cクロージャ</a></h2>

<p>C関数が作成されるとき、いくつかの値をそれに関連付けて、<em>Cクロージャ</em>を作成できます（<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>を参照）。これらの値は<em>アップバリュー</em>と呼ばれ、呼び出されるたびに関数からアクセスできます。</p><p>C関数が呼び出されるたびに、そのアップバリューは特定の擬似インデックスに配置されます。これらの擬似インデックスは、マクロ<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>によって生成されます。関数に関連付けられた最初のアップバリューは、インデックス<code>lua_upvalueindex(1)</code>にあり、以下同様です。<code>lua_upvalueindex(<em>n</em>)</code>へのアクセスは、<em>n</em>が現在の関数のアップバリューの数よりも大きい場合（ただし、クロージャ内のアップバリューの最大数に1を加えた256以下の場合）は、許容可能だが無効なインデックスを生成します。</p><p>Cクロージャは、対応するアップバリューの値を変更することもできます。</p><h2>4.3 – <a name="4.3">レジストリ</a></h2>

<p>Luaは、任意のCコードがLua値を格納するために使用できる、事前定義されたテーブルである<em>レジストリ</em>を提供します。レジストリテーブルは、常に擬似インデックス<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>でアクセスできます。任意のCライブラリは、このテーブルにデータを格納できますが、他のライブラリが使用するキーとは異なるキーを選択して、競合を回避する必要があります。通常、キーとしてライブラリ名を含む文字列、またはコード内のCオブジェクトのアドレスを持つライトuserdata、またはコードによって作成された任意のLuaオブジェクトを使用する必要があります。変数名と同様に、アンダースコアで始まり、大文字が続く文字列キーはLua用に予約されています。</p><p>レジストリの整数キーは、参照メカニズム（<a href="#luaL_ref"><code>luaL_ref</code></a>を参照）およびいくつかの事前定義された値によって使用されます。したがって、レジストリの整数キーを他の目的で使用しないでください。</p><p>新しいLua状態を作成すると、そのレジストリにはいくつかの事前定義された値が付属します。これらの事前定義された値には、<code>lua.h</code>の定数として定義された整数キーでインデックスが付けられています。次の定数が定義されています</p><ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b> このインデックスでは、レジストリは状態のメインスレッドを持ちます。（メインスレッドは、状態とともに作成されたものです。）</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b> このインデックスでは、レジストリはグローバル環境を持ちます。</li>
</ul>




<h2>4.4 – <a name="4.4">Cでのエラー処理</a></h2>



<p>内部的に、LuaはCの<code>longjmp</code>機能を使用してエラーを処理します。（Luaは、C++としてコンパイルした場合、例外を使用します。詳細については、ソースコードで<code>LUAI_THROW</code>を検索してください。）Luaは、メモリ割り当てエラーや型エラーなどのエラーに直面すると、エラーを<em>発生</em>させます。つまり、long jumpを実行します。<em>保護された環境</em>は<code>setjmp</code>を使用してリカバリポイントを設定します。エラーは、最も最近のアクティブなリカバリポイントにジャンプします。</p><p>C関数内では、<a href="#lua_error"><code>lua_error</code></a>を呼び出すことで、エラーを明示的に発生させることができます。</p><p>APIのほとんどの関数は、たとえばメモリ割り当てエラーが原因でエラーを発生させる可能性があります。各関数のドキュメントには、エラーを発生させる可能性があるかどうかが示されています。</p><p>保護された環境の外でエラーが発生した場合、Luaは<em>パニック関数</em>（<a href="#lua_atpanic"><code>lua_atpanic</code></a>を参照）を呼び出し、次に<code>abort</code>を呼び出して、ホストアプリケーションを終了します。パニック関数は、（たとえば、Luaの外の独自のリカバリポイントにlong jumpを実行して）戻らないことで、この終了を回避できます。</p><p>パニック関数は、名前が示すように、最後の手段のメカニズムです。プログラムはそれを避ける必要があります。原則として、C関数がLua状態を持つLuaによって呼び出される場合、すでに保護されているため、そのLua状態に対して必要なことを実行できます。ただし、Cコードが他のLua状態（たとえば、関数へのLua状態引数、レジストリに格納されているLua状態、または<a href="#lua_newthread"><code>lua_newthread</code></a>の結果）を操作する場合、エラーを発生させないAPI呼び出しでのみそれらを使用する必要があります。</p><p>パニック関数は、メッセージハンドラのように実行されます（<a href="#2.3">§2.3</a>を参照）。特に、エラーオブジェクトはスタックの最上部にあります。ただし、スタック領域については保証はありません。スタックに何かをプッシュするには、パニック関数は最初に利用可能なスペースを確認する必要があります（<a href="#4.1.1">§4.1.1</a>を参照）。</p><h3>4.4.1 – <a name="4.4.1">ステータスコード</a></h3>

<p>APIでエラーを報告するいくつかの関数は、さまざまな種類のエラーまたはその他の状態を示すために、次のステータスコードを使用します</p><ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b> エラーなし。</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b> ランタイムエラー。</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b> メモリ割り当てエラー。このようなエラーの場合、Luaはメッセージハンドラを呼び出しません。</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b> メッセージハンドラの実行中にエラーが発生しました。</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b> 事前コンパイル中の構文エラー。</li>

<li><b><a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a>: </b> スレッド（コルーチン）が中断されました。</li>

<li><b><a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>: </b> ファイル関連のエラー。たとえば、ファイルを開いたり読み取ったりできません。</li>

</ul><p>これらの定数は、ヘッダーファイル<code>lua.h</code>で定義されています。</p><h2>4.5 – <a name="4.5">Cでの中断の処理</a></h2>

<p>内部的には、LuaはコルーチンをyieldするためにCの<code>longjmp</code>機能を使用します。そのため、C関数<code>foo</code>がAPI関数を呼び出し、このAPI関数が（直接的またはyieldする別の関数を呼び出すことによって間接的に）yieldする場合、<code>longjmp</code>によってCスタックからフレームが削除されるため、Luaはもはや<code>foo</code>に戻ることができません。</p><p>この種の問題を回避するために、LuaはAPI呼び出しをまたいでyieldしようとするたびにエラーを発生させます。ただし、<a href="#lua_yieldk"><code>lua_yieldk</code></a>、<a href="#lua_callk"><code>lua_callk</code></a>、および<a href="#lua_pcallk"><code>lua_pcallk</code></a>の3つの関数は例外です。これらの関数はすべて、yield後に実行を継続するための<em>継続関数</em>（<code>k</code>という名前のパラメータとして）を受け取ります。</p><p>継続を説明するために、いくつかの用語を設定する必要があります。Luaから呼び出されたC関数を、<em>元の関数</em>と呼びます。この元の関数は、C APIのこれら3つの関数のいずれかを呼び出し、これを<em>呼び出し先関数</em>と呼びます。そして、呼び出し先関数が現在のスレッドをyieldします。これは、呼び出し先関数が<a href="#lua_yieldk"><code>lua_yieldk</code></a>である場合、または呼び出し先関数が<a href="#lua_callk"><code>lua_callk</code></a>または<a href="#lua_pcallk"><code>lua_pcallk</code></a>のいずれかであり、それらによって呼び出された関数がyieldする場合に発生します。</p><p>呼び出し先関数の実行中に実行中のスレッドがyieldすると仮定します。スレッドが再開した後、最終的に呼び出し先関数の実行が完了します。ただし、Cスタック内のフレームはyieldによって破棄されているため、呼び出し先関数は元の関数に戻ることができません。代わりに、Luaは<em>継続関数</em>を呼び出します。この継続関数は、呼び出し先関数の引数として渡されたものです。名前が示すように、継続関数は元の関数のタスクを継続する必要があります。</p><p>例として、次の関数を考えてみましょう。</p><pre>     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* calls Lua */
       ...     /* code 2 */
     }
</pre><p>ここで、<a href="#lua_pcall"><code>lua_pcall</code></a>によって実行されるLuaコードがyieldできるようにしたいとします。まず、ここで示すように関数を書き直すことができます。</p><pre>     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>上記のコードでは、新しい関数<code>k</code>は<em>継続関数</em>（<a href="#lua_KFunction"><code>lua_KFunction</code></a>型）であり、<a href="#lua_pcall"><code>lua_pcall</code></a>を呼び出した後に元の関数が行っていたすべての作業を行う必要があります。次に、<a href="#lua_pcall"><code>lua_pcall</code></a>によって実行されているLuaコードが何らかの方法（エラーまたはyield）で中断された場合に<code>k</code>を呼び出す必要があることをLuaに通知する必要があります。そのため、<a href="#lua_pcall"><code>lua_pcall</code></a>を<a href="#lua_pcallk"><code>lua_pcallk</code></a>に置き換えて、コードをここで示すように書き換えます。</p><pre>     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>継続への外部からの明示的な呼び出しに注意してください。Luaは、エラーが発生した場合やyield後に再開する場合など、必要な場合にのみ継続を呼び出します。呼び出された関数がyieldせずに正常に返った場合、<a href="#lua_pcallk"><code>lua_pcallk</code></a>（および<a href="#lua_callk"><code>lua_callk</code></a>）も正常に返ります。（もちろん、その場合に継続を呼び出す代わりに、元の関数内で同等の作業を直接行うことができます。）</p><p>Luaの状態に加えて、継続関数には他の2つのパラメータがあります。それは呼び出しの最終ステータスと、最初に<a href="#lua_pcallk"><code>lua_pcallk</code></a>に渡されたコンテキスト値（<code>ctx</code>）です。Luaはこのコンテキスト値を使用しません。元の関数から継続関数にこの値を渡すだけです。<a href="#lua_pcallk"><code>lua_pcallk</code></a>の場合、ステータスは<a href="#lua_pcallk"><code>lua_pcallk</code></a>によって返される値と同じですが、yield後に実行されている場合は（<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>ではなく）<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>になります。<a href="#lua_yieldk"><code>lua_yieldk</code></a>および<a href="#lua_callk"><code>lua_callk</code></a>の場合、Luaが継続を呼び出すときのステータスは常に<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>です。（これらの2つの関数では、エラーが発生した場合に継続を呼び出すことはありません。エラーを処理しないためです。）同様に、<a href="#lua_callk"><code>lua_callk</code></a>を使用する場合は、ステータスとして<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>を指定して継続関数を呼び出す必要があります。（<a href="#lua_yieldk"><code>lua_yieldk</code></a>の場合、通常<a href="#lua_yieldk"><code>lua_yieldk</code></a>は返さないため、継続関数を直接呼び出すことにあまり意味はありません。）</p><p>Luaは、継続関数を元の関数であるかのように扱います。継続関数は、元の関数と同じLuaスタックを、呼び出し先関数が返された場合と同じ状態で受け取ります。（たとえば、<a href="#lua_callk"><code>lua_callk</code></a>の後、関数とその引数はスタックから削除され、呼び出しの結果に置き換えられます。）また、同じアップ値も持ちます。それが返すものはすべて、元の関数の戻り値としてLuaによって処理されます。</p><h2>4.6 – <a name="4.6">関数と型</a></h2>

<p>ここでは、C&nbsp;APIのすべての関数と型をアルファベット順にリストします。各関数には、次のようなインジケータがあります: <span class="apii">[-o, +p, <em>x</em>]</span></p><p>最初のフィールド<code>o</code>は、関数がスタックからポップする要素の数です。2番目のフィールド<code>p</code>は、関数がスタックにプッシュする要素の数です。（すべての関数は常に、引数をポップした後で結果をプッシュします。）<code>x|y</code>形式のフィールドは、関数が状況に応じて<code>x</code>または<code>y</code>要素をプッシュ（またはポップ）できることを意味します。疑問符'<code>?</code>'は、引数だけを見て関数がポップ/プッシュする要素の数を知ることができないことを意味します。（たとえば、スタックの内容に依存する場合があります。）3番目のフィールド<code>x</code>は、関数がエラーを発生させる可能性があるかどうかを示します。 '<code>-</code>'は関数がエラーを発生させないことを意味します。 '<code>m</code>'は関数がメモリ不足エラーのみを発生させる可能性があることを意味します。 '<code>v</code>'は、テキストで説明されているエラーを関数が発生させる可能性があることを意味します。 '<code>e</code>'は関数が直接またはメタメソッドを通じて任意のLuaコードを実行できるため、任意のエラーが発生する可能性があることを意味します。</p><hr /><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>許容可能なインデックス<code>idx</code>を、同等の絶対インデックス（つまり、スタックサイズに依存しないインデックス）に変換します。</p><hr /><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>Luaの状態によって使用されるメモリアロケーション関数の型。アロケータ関数は、<code>realloc</code>に似た機能を提供する必要がありますが、まったく同じではありません。その引数は、<a href="#lua_newstate"><code>lua_newstate</code></a>に渡される不透明なポインタである<code>ud</code>、割り当て/再割り当て/解放されるブロックへのポインタである<code>ptr</code>、ブロックの元のサイズまたは割り当てられているものに関するコードである<code>osize</code>、およびブロックの新しいサイズである<code>nsize</code>です。</p><p><code>ptr</code>が<code>NULL</code>でない場合、<code>osize</code>は<code>ptr</code>によって指されるブロックのサイズ、つまり、割り当てまたは再割り当て時に指定されたサイズです。</p><p><code>ptr</code>が<code>NULL</code>の場合、<code>osize</code>はLuaが割り当てているオブジェクトの種類をエンコードします。<code>osize</code>は、Luaがその型の新しいオブジェクトを作成している場合（およびその場合にのみ）、<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>、<a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>、<a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>、<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>、または<a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>のいずれかになります。<code>osize</code>が他の値である場合、Luaは他の何かに対してメモリを割り当てています。</p><p>Luaは、アロケータ関数から次の動作を想定します。</p><p><code>nsize</code>がゼロの場合、アロケータは<code>free</code>のように動作し、<code>NULL</code>を返す必要があります。</p><p><code>nsize</code>がゼロでない場合、アロケータは<code>realloc</code>のように動作する必要があります。特に、アロケータはリクエストを完了できない場合にのみ<code>NULL</code>を返します。</p><p>アロケータ関数の簡単な実装を次に示します。これは、補助ライブラリで<a href="#luaL_newstate"><code>luaL_newstate</code></a>によって使用されます。</p><pre>     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>ISO&nbsp;Cでは、<code>free(NULL)</code>には効果がなく、<code>realloc(NULL,size)</code>は<code>malloc(size)</code>と同等であることが保証されていることに注意してください。</p><hr /><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
</p><pre>void lua_arith (lua_State *L, int op);</pre>

<p>スタックの先頭にある2つの値（または否定の場合には1つ）に対して算術演算またはビット演算を実行します。スタックの先頭の値が2番目のオペランドになります。これらの値をポップし、演算の結果をプッシュします。この関数は、対応するLua演算子のセマンティクスに従います（つまり、メタメソッドを呼び出す場合があります）。</p><p><code>op</code>の値は、次の定数のいずれかである必要があります。</p><ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 加算（<code>+</code>）を実行</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 減算（<code>-</code>）を実行</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 乗算（<code>*</code>）を実行</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 浮動小数点除算（<code>/</code>）を実行</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> 床除算（<code>//</code>）を実行</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> モジュロ（<code>%</code>）を実行</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 指数演算（<code>^</code>）を実行</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 数学的な否定（単項<code>-</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> ビット単位のNOT（<code>~</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> ビット単位のAND（<code>&amp;</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> ビット単位のOR（<code>|</code>）を実行</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> ビット単位の排他的OR（<code>~</code>）を実行</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> 左シフト（<code>&lt;&lt;</code>）を実行</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> 右シフト（<code>&gt;&gt;</code>）を実行</li>

</ul>




<hr /><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>新しいパニック関数を設定し、古い関数を返します（<a href="#4.4">§4.4</a>を参照）。</p><hr /><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
</p><pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>関数を呼び出します。通常のLua呼び出しと同様に、<code>lua_call</code>は<code>__call</code>メタメソッドを尊重します。したがって、ここで「関数」という言葉は、呼び出し可能な値を意味します。</p><p>呼び出しを行うには、次のプロトコルを使用する必要があります。最初に、呼び出す関数をスタックにプッシュします。次に、呼び出しの引数を直接の順序でプッシュします。つまり、最初の引数が最初にプッシュされます。最後に<a href="#lua_call"><code>lua_call</code></a>を呼び出します。<code>nargs</code>はスタックにプッシュした引数の数です。関数が戻ると、すべての引数と関数値がポップされ、呼び出し結果がスタックにプッシュされます。結果の数は<code>nresults</code>に調整されます。ただし、<code>nresults</code>が<a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>の場合を除きます。この場合、関数からのすべての結果がプッシュされます。Luaは、返された値がスタックスペースに収まるようにしますが、スタック内の追加のスペースを保証しません。関数の結果は直接の順序で（最初の結果が最初にプッシュされる）スタックにプッシュされるため、呼び出し後、最後の結果がスタックの先頭になります。</p><p>関数の呼び出しおよび実行中のエラーはすべて、上位に（<code>longjmp</code>を使用して）伝播されます。</p><p>次の例は、ホストプログラムがこのLuaコードと同等の処理をどのように実行できるかを示しています。</p><pre>     a = f("how", t.x, 14)
</pre><p>以下はCでの記述です。</p><pre>     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
</pre><p>上記のコードは<em>バランスが取れている</em>ことに注意してください。最後に、スタックは元の構成に戻ります。これは、優れたプログラミングの習慣と見なされます。</p><hr /><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
</p><pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>この関数は、<a href="#lua_call"><code>lua_call</code></a>とまったく同じように動作しますが、呼び出された関数がyieldできるようにします（<a href="#4.5">§4.5</a>を参照）。</p><hr /><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>C&nbsp;関数の型。</p><p>Luaと正しく通信するために、C関数は次のプロトコルに従う必要があります。このプロトコルは、パラメータと結果がどのように渡されるかを定義します。C関数は、Luaから引数をスタックに直接順に受け取ります（最初の引数が最初にプッシュされます）。したがって、関数が開始すると、<code>lua_gettop(L)</code>は関数が受け取った引数の数を返します。最初の引数（存在する場合）はインデックス1にあり、最後の引数はインデックス<code>lua_gettop(L)</code>にあります。Luaに値を返すには、C関数はそれらをスタックに直接順にプッシュし（最初の結果が最初にプッシュされます）、Cで結果の数を返します。結果の下のスタックにある他の値は、Luaによって適切に破棄されます。Lua関数と同様に、Luaによって呼び出されるC関数も多くの結果を返すことができます。</p><p>例として、次の関数は可変数の数値引数を受け取り、それらの平均と合計を返します。</p><pre>     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* number of arguments */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }
</pre>




<hr /><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>スタックに少なくとも<code>n</code>個の追加要素のためのスペースがあること、つまり、最大<code>n</code>個の値を安全にプッシュできることを保証します。スタックが固定の最大サイズ（通常、数千個以上の要素）を超える場合、または追加のスペース用のメモリを割り当てることができないために、要求を満たすことができない場合は、falseを返します。この関数はスタックを縮小することはありません。スタックにすでに余分な要素のためのスペースがある場合、変更されずに残ります。</p><hr /><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_close (lua_State *L);</pre>

<p>メインスレッドでアクティブなすべてのクローズ対象変数を閉じ、指定されたLua状態のすべてのオブジェクトを解放し（対応するガベージコレクションメタメソッド（存在する場合）を呼び出し）、この状態によって使用されるすべての動的メモリを解放します。</p><p>一部のプラットフォームでは、ホストプログラムが終了するとすべてのリソースが自然に解放されるため、この関数を呼び出す必要がない場合があります。一方、デーモンやWebサーバーなど、複数の状態を作成する長時間実行されるプログラムは、不要になった状態をできるだけ早く閉じる必要があるでしょう。</p><hr /><h3><a name="lua_closeslot"><code>lua_closeslot</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void lua_closeslot (lua_State *L, int index);</pre>

<p>指定されたインデックスにあるクローズ対象のスロットを閉じ、その値を<b>nil</b>に設定します。インデックスは、まだアクティブ（つまり、まだ閉じられていない）である、以前にクローズ対象としてマークされた最後のインデックス（<a href="#lua_toclose"><code>lua_toclose</code></a>を参照）である必要があります。</p><p>この関数を介して呼び出された場合、<code>__close</code>メタメソッドはyieldできません。</p><p>（この関数はリリース5.4.3で導入されました。）</p><hr /><h3><a name="lua_closethread"><code>lua_closethread</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int lua_closethread (lua_State *L, lua_State *from);</pre>

<p>スレッドをリセットし、そのコールスタックをクリーンアップし、保留中のすべてのクローズ対象変数を閉じます。ステータスコードを返します。スレッドにエラーがない場合は<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>（スレッドを停止させた元のエラー、またはクローズメソッドのエラー）、それ以外の場合はエラー状態です。エラーの場合、スタックのトップにエラーオブジェクトを残します。</p><p>パラメータ<code>from</code>は、<code>L</code>をリセットしているコルーチンを表します。そのようなコルーチンがない場合、このパラメータは<code>NULL</code>にすることができます。</p><p>（この関数はリリース5.4.6で導入されました。）</p><hr /><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>2つのLua値を比較します。インデックス<code>index1</code>の値が、対応するLua演算子のセマンティクスに従って（つまり、メタメソッドを呼び出す可能性がある）、インデックス<code>index2</code>の値と比較した場合に<code>op</code>を満たす場合は1を返します。それ以外の場合は0を返します。また、いずれかのインデックスが無効な場合も0を返します。</p><p><code>op</code>の値は、次の定数のいずれかである必要があります。</p><ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b>等価性（<code>==</code>）を比較します</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b>より小さい（<code>&lt;</code>）を比較します</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b>以下（<code>&lt;=</code>）を比較します</li>

</ul>




<hr /><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
</p><pre>void lua_concat (lua_State *L, int n);</pre>

<p>スタックのトップにある<code>n</code>個の値を連結し、それらをポップし、結果をトップに残します。<code>n</code>が1の場合、結果はスタック上の単一の値です（つまり、関数は何もしません）。<code>n</code>が0の場合、結果は空の文字列です。連結はLuaの通常のセマンティクスに従って実行されます（<a href="#3.4.6">§3.4.6</a>を参照）。</p><hr /><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>インデックス<code>fromidx</code>にある要素を有効なインデックス<code>toidx</code>にコピーし、その位置の値を置き換えます。他の位置の値は影響を受けません。</p><hr /><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>新しい空のテーブルを作成し、スタックにプッシュします。パラメータ<code>narr</code>は、テーブルがシーケンスとして持つ要素数のヒントです。パラメータ<code>nrec</code>は、テーブルが持つ他の要素数のヒントです。Luaは、これらのヒントを使用して、新しいテーブルのメモリを事前に割り当てることができます。この事前割り当ては、テーブルにいくつの要素があるかを事前に知っている場合にパフォーマンスを向上させるのに役立つ場合があります。それ以外の場合は、関数<a href="#lua_newtable"><code>lua_newtable</code></a>を使用できます。</p><hr /><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>関数をバイナリチャンクとしてダンプします。スタックのトップにあるLua関数を受け取り、再度ロードした場合、ダンプされたものと同等の関数になるバイナリチャンクを生成します。チャンクの一部を生成するときに、<a href="#lua_dump"><code>lua_dump</code></a>は、指定された<code>data</code>を使用してそれらを書き込むために関数<code>writer</code>（<a href="#lua_Writer"><code>lua_Writer</code></a>を参照）を呼び出します。</p><p><code>strip</code>がtrueの場合、バイナリ表現には、スペースを節約するために関数のすべてのデバッグ情報が含まれない場合があります。</p><p>返される値は、ライターへの最後の呼び出しによって返されるエラーコードです。0はエラーがないことを意味します。</p><p>この関数はスタックからLua関数をポップしません。</p><hr /><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
</p><pre>int lua_error (lua_State *L);</pre>

<p>スタックのトップにある値をエラーオブジェクトとして使用して、Luaエラーを発生させます。この関数はロングジャンプを実行するため、決して戻りません（<a href="#luaL_error"><code>luaL_error</code></a>を参照）。</p><hr /><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gc (lua_State *L, int what, ...);</pre>

<p>ガベージコレクタを制御します。</p><p>この関数は、パラメータ<code>what</code>の値に応じて、いくつかのタスクを実行します。追加の引数を必要とするオプションの場合、オプションの後にそれらがリストされます。</p><ul>

<li><b><code>LUA_GCCOLLECT</code>: </b>完全なガベージコレクションサイクルを実行します。</li>

<li><b><code>LUA_GCSTOP</code>: </b>ガベージコレクタを停止します。</li>

<li><b><code>LUA_GCRESTART</code>: </b>ガベージコレクタを再起動します。</li>

<li><b><code>LUA_GCCOUNT</code>: </b>Luaで使用されている現在のメモリ量（Kバイト単位）を返します。</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>Luaで使用されている現在のメモリ量（バイト単位）を1024で割った余りを返します。</li>

<li><b><code>LUA_GCSTEP</code> <code>(int stepsize)</code>: </b><code>stepsize</code> Kバイトの割り当てに対応する、ガベージコレクションの増分ステップを実行します。</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>コレクターが実行中かどうか（つまり、停止していない）を示すブール値を返します。</li>

<li><b><code>LUA_GCINC</code> (int pause, int stepmul, stepsize): </b>指定されたパラメータを使用して、コレクターを増分モードに変更します（<a href="#2.5.1">§2.5.1</a>を参照）。以前のモード（<code>LUA_GCGEN</code>または<code>LUA_GCINC</code>）を返します。</li>

<li><b><code>LUA_GCGEN</code> (int minormul, int majormul): </b>指定されたパラメータを使用して、コレクターを世代モードに変更します（<a href="#2.5.2">§2.5.2</a>を参照）。以前のモード（<code>LUA_GCGEN</code>または<code>LUA_GCINC</code>）を返します。</li>

</ul><p>これらのオプションの詳細については、<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>を参照してください。</p><p>この関数はファイナライザーによって呼び出されるべきではありません。</p><hr /><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>指定された状態のメモリ割り当て関数を返します。<code>ud</code>が<code>NULL</code>でない場合、Luaはメモリ割り当て関数が設定されたときに与えられた不透明なポインタを<code>*ud</code>に格納します。</p><hr /><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>スタックに値<code>t[k]</code>をプッシュします。ここで、<code>t</code>は指定されたインデックスにある値です。Luaと同様に、この関数は「index」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a>を参照）。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_getextraspace (lua_State *L);</pre>

<p>指定されたLua状態に関連付けられた生のメモリ領域へのポインタを返します。アプリケーションはこの領域を任意の目的で使用できます。Luaはそれを使用しません。</p><p>各新しいスレッドには、メインスレッドの領域のコピーで初期化されたこの領域があります。</p><p>デフォルトでは、この領域はvoidへのポインタのサイズですが、この領域の異なるサイズでLuaを再コンパイルできます。（<code>luaconf.h</code>の<code>LUA_EXTRASPACE</code>を参照）。</p><hr /><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>グローバル<code>name</code>の値をスタックにプッシュします。その値の型を返します。</p><hr /><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>スタックに値<code>t[i]</code>をプッシュします。ここで、<code>t</code>は指定されたインデックスにある値です。Luaと同様に、この関数は「index」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a>を参照）。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>指定されたインデックスの値にメタテーブルがある場合、関数はそのメタテーブルをスタックにプッシュし、1を返します。それ以外の場合、関数は0を返し、スタックには何もプッシュしません。</p><hr /><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
</p><pre>int lua_gettable (lua_State *L, int index);</pre>

<p>スタックに値<code>t[k]</code>をプッシュします。ここで、<code>t</code>は指定されたインデックスにある値であり、<code>k</code>はスタックのトップにある値です。</p><p>この関数は、スタックからキーをポップし、その場所に結果の値をプッシュします。Luaと同様に、この関数は「index」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a>を参照）。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gettop (lua_State *L);</pre>

<p>スタックのトップ要素のインデックスを返します。インデックスは1から始まるため、この結果はスタック内の要素数と同じです。特に、0は空のスタックを意味します。</p><hr /><h3><a name="lua_getiuservalue"><code>lua_getiuservalue</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_getiuservalue (lua_State *L, int index, int n);</pre>

<p>スタックに、指定されたインデックスにあるフルユーザーデータに関連付けられた<code>n</code>番目のユーザー値をプッシュし、プッシュされた値の型を返します。</p><p>ユーザーデータにその値がない場合、<b>nil</b>をプッシュし、<a href="#pdf-LUA_TNONE"><code>LUA_TNONE</code></a>を返します。</p><hr /><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, –]</span>
</p><pre>void lua_insert (lua_State *L, int index);</pre>

<p>トップ要素を指定された有効なインデックスに移動し、このインデックスの上にある要素を上にシフトしてスペースを開きます。擬似インデックスは実際のスタック位置ではないため、この関数を擬似インデックスで呼び出すことはできません。</p><hr /><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>Luaの整数の型。</p><p>デフォルトでは、この型は<code>long long</code>（通常は64ビットの2の補数整数）ですが、<code>long</code>または<code>int</code>（通常は32ビットの2の補数整数）に変更できます。（<code>luaconf.h</code>の<code>LUA_INT_TYPE</code>を参照）。</p><p>Luaは、この型に収まる最小値と最大値を使用して、定数<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a>と<a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>も定義します。</p><hr /><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がブール値の場合は1を返し、それ以外の場合は0を返します。</p><hr /><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がC関数の場合は1を返し、それ以外の場合は0を返します。</p><hr /><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が関数（CまたはLua）の場合は1を返し、それ以外の場合は0を返します。</p><hr /><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が整数（つまり、値が数値であり、整数として表現されている）であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がライトユーザーデータであれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnil (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が <b>nil</b> であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnone (lua_State *L, int index);</pre>

<p>指定されたインデックスが無効であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>指定されたインデックスが無効であるか、そのインデックスの値が <b>nil</b> であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が数値または数値に変換可能な文字列であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isstring (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が文字列または数値（常に文字列に変換可能）であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_istable (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がテーブルであれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isthread (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がスレッドであれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>指定されたインデックスの値がユーザーデータ（フルまたはライト）であれば 1 を返し、そうでなければ 0 を返します。</p><hr /><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_isyieldable (lua_State *L);</pre>

<p>指定されたコルーチンが yield できる場合は 1 を返し、それ以外の場合は 0 を返します。</p><hr /><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>継続関数コンテキストの型。数値型でなければなりません。この型は、<code>intptr_t</code> が利用可能な場合は <code>intptr_t</code> として定義され、ポインタも格納できるようにします。それ以外の場合は、<code>ptrdiff_t</code> として定義されます。</p><hr /><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>継続関数の型（<a href="#4.5">§4.5</a> を参照）。</p><hr /><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
</p><pre>void lua_len (lua_State *L, int index);</pre>

<p>指定されたインデックスの値の長さを返します。Lua の '<code>#</code>' 演算子（<a href="#3.4.7">§3.4.7</a> を参照）と同等であり、「length」イベントのメタメソッドをトリガーする場合があります（<a href="#2.4">§2.4</a> を参照）。結果はスタックにプッシュされます。</p><hr /><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>Lua のチャンクを実行せずにロードします。エラーがない場合、<code>lua_load</code> はコンパイルされたチャンクを Lua 関数としてスタックの一番上にプッシュします。それ以外の場合は、エラーメッセージをプッシュします。</p><p><code>lua_load</code> 関数は、チャンクを読み込むためにユーザーが提供する <code>reader</code> 関数を使用します（<a href="#lua_Reader"><code>lua_Reader</code></a> を参照）。<code>data</code> 引数は、reader 関数に渡される不透明な値です。</p><p><code>chunkname</code> 引数は、エラーメッセージやデバッグ情報で使用されるチャンクの名前を指定します（<a href="#4.7">§4.7</a> を参照）。</p><p>
<code>lua_load</code> は、チャンクがテキスト形式かバイナリ形式かを自動的に検出し、それに応じてロードします（プログラム <code>luac</code> を参照）。文字列 <code>mode</code> は、関数 <a href="#pdf-load"><code>load</code></a> と同様に動作しますが、<code>NULL</code> 値は文字列 "<code>bt</code>" と同等であるという追加があります。</p><p>
<code>lua_load</code> は内部でスタックを使用するため、reader 関数は常に、戻る際にスタックを変更しないようにする必要があります。</p><p>
<code>lua_load</code> は <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、<a href="#pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>、または <a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a> を返すことができます。この関数は、読み取り関数によって発生したエラーに対応する他の値を返す場合もあります（<a href="#4.4.1">§4.4.1</a> を参照）。</p><p>結果の関数にアップバリューがある場合、その最初のアップバリューは、レジストリのインデックス <code>LUA_RIDX_GLOBALS</code> に格納されているグローバル環境の値に設定されます（<a href="#4.3">§4.3</a> を参照）。メインチャンクをロードする場合、このアップバリューは <code>_ENV</code> 変数になります（<a href="#2.2">§2.2</a> を参照）。他のアップバリューは <b>nil</b> で初期化されます。</p><hr /><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>新しい独立した状態を作成し、そのメスレッドを返します。状態を作成できない場合（メモリ不足が原因）は <code>NULL</code> を返します。引数 <code>f</code> はアロケーター関数です。Lua は、この状態のすべてのメモリ割り当てをこの関数を介して行います（<a href="#lua_Alloc"><code>lua_Alloc</code></a> を参照）。2 番目の引数 <code>ud</code> は、Lua がすべての呼び出しでアロケーターに渡す不透明なポインタです。</p><hr /><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void lua_newtable (lua_State *L);</pre>

<p>新しい空のテーブルを作成し、それをスタックにプッシュします。これは <code>lua_createtable(L, 0, 0)</code> と同等です。</p><hr /><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>新しいスレッドを作成し、スタックにプッシュし、この新しいスレッドを表す <a href="#lua_State"><code>lua_State</code></a> へのポインタを返します。この関数によって返される新しいスレッドは、元のスレッドとグローバル環境を共有しますが、独立した実行スタックを持ちます。</p><p>スレッドは、他の Lua オブジェクトと同様に、ガベージコレクションの対象となります。</p><hr /><h3><a name="lua_newuserdatauv"><code>lua_newuserdatauv</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue);</pre>

<p>この関数は、新しいフルユーザーデータをスタックに作成してプッシュします。このユーザーデータには、<code>nuvalue</code> 個の関連する Lua 値（<code>ユーザー値</code> と呼ばれます）と、<code>size</code> バイトの関連する生のメモリブロックがあります。（ユーザー値は、関数 <a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a> および <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a> で設定および読み取ることができます。）</p><p>この関数は、メモリブロックのアドレスを返します。Lua は、対応するユーザーデータが存続している限り、このアドレスが有効であることを保証します（<a href="#2.5">§2.5</a> を参照）。さらに、ユーザーデータがファイナライズのためにマークされている場合（<a href="#2.5.3">§2.5.3</a> を参照）、そのアドレスは少なくともファイナライザーの呼び出しまで有効です。</p><hr /><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>v</em>]</span>
</p><pre>int lua_next (lua_State *L, int index);</pre>

<p>スタックからキーをポップし、指定されたインデックスのテーブルからキーと値のペア（指定されたキーの「次の」ペア）をプッシュします。テーブルに要素がなくなると、<a href="#lua_next"><code>lua_next</code></a> は 0 を返し、何もプッシュしません。</p><p>一般的なテーブルトラバーサルは次のようになります。</p><pre>     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }
</pre>

<p>テーブルのトラバーサル中は、キーが実際に文字列であることがわかっている場合を除き、キーに対して直接 <a href="#lua_tolstring"><code>lua_tolstring</code></a> を呼び出すことは避けてください。<a href="#lua_tolstring"><code>lua_tolstring</code></a> は指定されたインデックスの値を変更する可能性があることに注意してください。これは、<a href="#lua_next"><code>lua_next</code></a> の次の呼び出しを混乱させます。</p><p>指定されたキーが <b>nil</b> でもない場合、テーブルに存在しない場合は、この関数がエラーを発生させる可能性があります。テーブルのトラバーサル中にテーブルを変更する場合の注意点については、関数 <a href="#pdf-next"><code>next</code></a> を参照してください。</p><hr /><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>Lua の浮動小数点数の型。</p><p>デフォルトでは、この型は double ですが、単精度 float または long double に変更できます。（<code>luaconf.h</code> の <code>LUA_FLOAT_TYPE</code> を参照。）</p><hr /><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>Lua の浮動小数点数を Lua の整数に変換しようとします。浮動小数点数 <code>n</code> は整数値でなければなりません。その値が Lua の整数の範囲内にある場合は、整数に変換され、<code>*p</code> に代入されます。このマクロは、変換が成功したかどうかを示すブール値を返します。（この範囲テストは、このマクロがないと正しく行うのが難しい場合があることに注意してください。）</p><p>このマクロは、引数を複数回評価する場合があります。</p><hr /><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>関数（または呼び出し可能なオブジェクト）を保護モードで呼び出します。</p><p><code>nargs</code> と <code>nresults</code> の両方とも、<a href="#lua_call"><code>lua_call</code></a> と同じ意味を持ちます。呼び出し中にエラーがない場合、<a href="#lua_pcall"><code>lua_pcall</code></a> は <a href="#lua_call"><code>lua_call</code></a> とまったく同じように動作します。ただし、エラーが発生した場合、<a href="#lua_pcall"><code>lua_pcall</code></a> はそれをキャッチし、単一の値をスタックにプッシュし（エラーオブジェクト）、エラーコードを返します。<a href="#lua_call"><code>lua_call</code></a> と同様に、<a href="#lua_pcall"><code>lua_pcall</code></a> は常にスタックから関数とその引数を削除します。</p><p><code>msgh</code> が 0 の場合、スタックに返されるエラーオブジェクトは元のエラーオブジェクトとまったく同じです。それ以外の場合、<code>msgh</code> は<em>メッセージハンドラー</em>のスタックインデックスです。（このインデックスは疑似インデックスにすることはできません。）ランタイムエラーが発生した場合、このハンドラーはエラーオブジェクトとともに呼び出され、その戻り値は <a href="#lua_pcall"><code>lua_pcall</code></a> によってスタックに返されるオブジェクトになります。</p><p>通常、メッセージハンドラーは、スタックトレースバックなど、エラーオブジェクトに詳細なデバッグ情報を追加するために使用されます。このような情報は、<a href="#lua_pcall"><code>lua_pcall</code></a> の戻り後には収集できません。スタックが巻き戻されているためです。</p><p><a href="#lua_pcall"><code>lua_pcall</code></a> 関数は、次のステータスコードのいずれかを返します。<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、<a href="#pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>、<a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>、または <a href="#pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>。</p><hr /><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
</p><pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>この関数は、呼び出された関数が yield できることを除いて（<a href="#4.5">§4.5</a> を参照）、<a href="#lua_pcall"><code>lua_pcall</code></a> とまったく同じように動作します。</p><hr /><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>e</em>]</span>
</p><pre>void lua_pop (lua_State *L, int n);</pre>

<p>スタックから <code>n</code> 個の要素をポップします。これは、<a href="#lua_settop"><code>lua_settop</code></a> に対するマクロとして実装されています。</p><hr /><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>値 <code>b</code> を持つブール値をスタックにプッシュします。</p><hr /><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
</p><pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>新しい C&nbsp;クロージャをスタックにプッシュします。この関数は C&nbsp;関数へのポインタを受け取り、対応する C&nbsp;関数を呼び出す、呼び出し時に <code>function</code> 型の Lua 値をスタックにプッシュします。パラメーター <code>n</code> は、この関数が持つアップバリューの数を指定します（<a href="#4.2">§4.2</a> を参照）。</p><p>Lua から呼び出し可能なすべての関数は、パラメーターを受け取り、結果を返すための正しいプロトコルに従う必要があります（<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照）。</p><p>C&nbsp;関数が作成されるとき、アップバリューと呼ばれるいくつかの値をそれに関連付けることができます。これらのアップバリューは、関数が呼び出されるたびにアクセスできます。この関連付けは C&nbsp;クロージャと呼ばれます（<a href="#4.2">§4.2</a> を参照）。C&nbsp;クロージャを作成するには、最初にアップバリューの初期値をスタックにプッシュする必要があります。（複数のアップバリューがある場合、最初の値が最初にプッシュされます。）次に、<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> を呼び出して、C&nbsp;関数をスタックに作成してプッシュします。引数 <code>n</code> は、関数に関連付けられる値の数を指定します。<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> は、これらの値もスタックからポップします。</p><p><code>n</code> の最大値は 255 です。</p><p><code>n</code> が 0 の場合、この関数は<em>ライト C&nbsp;関数</em>を作成します。これは C&nbsp;関数へのポインタにすぎません。その場合、メモリエラーが発生することはありません。</p><hr /><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>C&nbsp;関数をスタックにプッシュします。この関数は、アップバリューがない <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> と同等です。</p><hr /><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>書式設定された文字列をスタックにプッシュし、この文字列へのポインタを返します（<a href="#4.1.3">§4.1.3</a> を参照）。これは ISO&nbsp;C 関数 <code>sprintf</code> に似ていますが、2 つの重要な違いがあります。まず、結果のスペースを割り当てる必要はありません。結果は Lua 文字列であり、Lua がメモリ割り当て（およびガベージコレクションによる割り当て解除）を処理します。2 番目に、変換指定子はかなり制限されています。フラグ、幅、または精度はありません。変換指定子は '<code>%%</code>' (文字 '<code>%</code>' を挿入)、'<code>%s</code>' (ヌル終端文字列を挿入、サイズ制限なし)、'<code>%f</code>' (<a href="#lua_Number"><code>lua_Number</code></a> を挿入)、'<code>%I</code>' (<a href="#lua_Integer"><code>lua_Integer</code></a> を挿入)、'<code>%p</code>' (ポインタを挿入)、'<code>%d</code>' (<code>int</code> を挿入)、'<code>%c</code>' (1 バイト文字として <code>int</code> を挿入)、および '<code>%U</code>' (UTF-8 バイトシーケンスとして <code>long int</code> を挿入) のみです。</p><p>この関数は、メモリオーバーフローまたは無効な変換指定子によるエラーを発生させる場合があります。</p><hr /><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>グローバル環境をスタックにプッシュします。</p><hr /><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>値 <code>n</code> を持つ整数をスタックにプッシュします。</p><hr /><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>ライトユーザーデータをスタックにプッシュします。</p><p>ユーザーデータは Lua で C&nbsp;値を表します。<em>ライトユーザーデータ</em>はポインタ（<code>void*</code>）を表します。これは値（数値のような）であり、作成されず、個別のメタテーブルを持たず、収集されません（作成されなかったため）。ライトユーザーデータは、同じ C&nbsp;アドレスを持つ「任意」のライトユーザーデータと等しくなります。</p><hr /><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>このマクロは <a href="#lua_pushstring"><code>lua_pushstring</code></a> と同等ですが、<code>s</code> がリテラル文字列の場合にのみ使用する必要があります。（Lua はこのケースを最適化する場合があります。）</p><hr /><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>サイズ <code>len</code> の <code>s</code> が指す文字列をスタックにプッシュします。Lua は指定された文字列の内部コピーを作成または再利用するため、関数が戻った直後に <code>s</code> のメモリを解放または再利用できます。文字列には、埋め込みゼロを含む任意のバイナリデータを含めることができます。</p><p>文字列の内部コピーへのポインタを返します（<a href="#4.1.3">§4.1.3</a> を参照）。</p><hr /><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnil (lua_State *L);</pre>

<p>スタックにnil値をプッシュします。</p><hr /><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>スタックに値が<code>n</code>であるfloat値をプッシュします。</p><hr /><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
</p><pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p><code>s</code>が指すゼロ終端文字列をスタックにプッシュします。Luaは与えられた文字列の内部コピーを作成または再利用するため、関数が戻った直後に<code>s</code>のメモリを解放または再利用できます。</p><p>文字列の内部コピーへのポインタを返します（<a href="#4.1.3">§4.1.3</a> を参照）。</p><p><code>s</code>が<code>NULL</code>の場合、<b>nil</b>をプッシュして<code>NULL</code>を返します。</p><hr /><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_pushthread (lua_State *L);</pre>

<p><code>L</code>で表されるスレッドをスタックにプッシュします。このスレッドがそのステートのメインスレッドである場合は1を返します。</p><hr /><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>与えられたインデックスにある要素のコピーをスタックにプッシュします。</p><hr /><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
</p><pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p><a href="#lua_pushfstring"><code>lua_pushfstring</code></a>と同等ですが、可変個数の引数の代わりに<code>va_list</code>を受け取ります。</p><hr /><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>インデックス<code>index1</code>と<code>index2</code>にある2つの値がプリミティブに等しい（つまり、<code>__eq</code>メタメソッドを呼び出さずに等しい）場合は1を返します。それ以外の場合は0を返します。いずれかのインデックスが無効な場合も0を返します。</p><hr /><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, –]</span>
</p><pre>int lua_rawget (lua_State *L, int index);</pre>

<p><a href="#lua_gettable"><code>lua_gettable</code></a>に似ていますが、生のアクセス（つまり、メタメソッドなし）を行います。<code>index</code>の値はテーブルでなければなりません。</p><hr /><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>スタックに値<code>t[n]</code>をプッシュします。ここで、<code>t</code>は与えられたインデックスにあるテーブルです。アクセスは生であり、<code>__index</code>メタ値を使用しません。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>スタックに値<code>t[k]</code>をプッシュします。ここで、<code>t</code>は与えられたインデックスにあるテーブルであり、<code>k</code>はライトユーザーデータとして表現されたポインタ<code>p</code>です。アクセスは生であり、つまり<code>__index</code>メタ値を使用しません。</p><p>プッシュされた値の型を返します。</p><hr /><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Unsigned lua_rawlen (lua_State *L, int index);</pre>

<p>与えられたインデックスの値の生の「長さ」を返します。文字列の場合は文字列の長さ、テーブルの場合はメタメソッドなしの長さ演算子（'<code>#</code>'）の結果、ユーザーデータの場合はユーザーデータに割り当てられたメモリブロックのサイズです。その他の値の場合、この呼び出しは0を返します。</p><hr /><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
</p><pre>void lua_rawset (lua_State *L, int index);</pre>

<p><a href="#lua_settable"><code>lua_settable</code></a>に似ていますが、生の代入（つまり、メタメソッドなし）を行います。<code>index</code>の値はテーブルでなければなりません。</p><hr /><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p><code>t[i] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスにあるテーブルであり、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。代入は生であり、つまり<code>__newindex</code>メタ値を使用しません。</p><hr /><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
</p><pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p><code>t[p] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスにあるテーブル、<code>p</code>はライトユーザーデータとしてエンコードされ、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。代入は生であり、つまり<code>__newindex</code>メタ値を使用しません。</p><hr /><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p><a href="#lua_load"><code>lua_load</code></a>で使用されるリーダ関数。 <a href="#lua_load"><code>lua_load</code></a>がチャンクの別の部分を必要とするたびに、リーダを呼び出し、その<code>data</code>パラメータを渡します。リーダは、チャンクの新しい部分を持つメモリブロックへのポインタを返し、<code>size</code>をブロックサイズに設定する必要があります。ブロックは、リーダ関数が再度呼び出されるまで存在する必要があります。チャンクの終わりを知らせるために、リーダは<code>NULL</code>を返すか、<code>size</code>をゼロに設定する必要があります。リーダ関数は、ゼロより大きい任意のサイズのピースを返すことができます。</p><hr /><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
</p><pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>グローバル変数<code>name</code>の新しい値としてC関数<code>f</code>を設定します。これはマクロとして定義されています</p><pre>     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr /><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_remove (lua_State *L, int index);</pre>

<p>指定された有効なインデックスにある要素を削除し、このインデックスより上の要素を下に移動してギャップを埋めます。疑似インデックスは実際のスタック位置ではないため、この関数を疑似インデックスで呼び出すことはできません。</p><hr /><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>void lua_replace (lua_State *L, int index);</pre>

<p>スタックの一番上の要素を与えられた有効なインデックスに移動し、他の要素をシフトすることなく（したがって、指定されたインデックスの値を置き換え）、一番上の要素をポップします。</p><hr /><h3><a name="lua_resetthread"><code>lua_resetthread</code></a></h3><p>
<span class="apii">[-0, +?, –]</span>
</p><pre>int lua_resetthread (lua_State *L);</pre>

<p>この関数は非推奨です。<code>from</code>が<code>NULL</code>である<a href="#lua_closethread"><code>lua_closethread</code></a>と同等です。</p><hr /><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>int lua_resume (lua_State *L, lua_State *from, int nargs,
                          int *nresults);</pre>

<p>与えられたスレッド<code>L</code>でコルーチンを開始および再開します。</p><p>コルーチンを開始するには、メイン関数と任意の引数をスレッドの空のスタックにプッシュします。次に、<a href="#lua_resume"><code>lua_resume</code></a>を呼び出し、<code>nargs</code>を引数の数とします。この呼び出しは、コルーチンが中断するか実行を終了したときに戻ります。戻ると、<code>*nresults</code>が更新され、スタックの一番上には<a href="#lua_yield"><code>lua_yield</code></a>に渡された値、または本体関数によって返された値である<code>*nresults</code>値が含まれています。コルーチンが中断した場合、<a href="#lua_resume"><code>lua_resume</code></a>は<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>を返します。コルーチンがエラーなしで実行を終了した場合は<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>を返し、エラーの場合はエラーコードを返します（<a href="#4.4.1">§4.4.1</a>を参照）。エラーの場合、エラーオブジェクトはスタックの一番上にあります。</p><p>コルーチンを再開するには、スタックから<code>*nresults</code>のyieldされた値を削除し、<code>yield</code>の結果として渡される値をプッシュしてから、<a href="#lua_resume"><code>lua_resume</code></a>を呼び出します。</p><p>パラメータ<code>from</code>は<code>L</code>を再開するコルーチンを表します。そのようなコルーチンがない場合、このパラメータは<code>NULL</code>にすることができます。</p><hr /><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>有効なインデックス<code>idx</code>とスタックの一番上の要素の間でスタック要素を回転させます。要素は、正の<code>n</code>の場合は一番上の方向に<code>n</code>の位置だけ、または負の<code>n</code>の場合は一番下の方向に<code>-n</code>の位置だけ回転します。<code>n</code>の絶対値は、回転されるスライスのサイズを超えてはなりません。疑似インデックスは実際のスタック位置ではないため、この関数を疑似インデックスで呼び出すことはできません。</p><hr /><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>与えられたステートのアロケータ関数を、ユーザーデータ<code>ud</code>を使用して<code>f</code>に変更します。</p><hr /><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p><code>t[k] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスの値であり、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。 Luaの場合と同様に、この関数は「newindex」イベントのメタメソッドをトリガーする可能性があります（<a href="#2.4">§2.4</a>を参照）。</p><hr /><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>スタックから値をポップし、グローバル変数<code>name</code>の新しい値として設定します。</p><hr /><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
</p><pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p><code>t[n] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスの値であり、<code>v</code>はスタックの一番上の値です。</p><p>この関数はスタックから値をポップします。 Luaの場合と同様に、この関数は「newindex」イベントのメタメソッドをトリガーする可能性があります（<a href="#2.4">§2.4</a>を参照）。</p><hr /><h3><a name="lua_setiuservalue"><code>lua_setiuservalue</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setiuservalue (lua_State *L, int index, int n);</pre>

<p>スタックから値をポップし、与えられたインデックスにあるフルユーザーデータに関連付けられた新しい<code>n</code>番目のユーザー値として設定します。ユーザーデータにその値がない場合は0を返します。</p><hr /><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, –]</span>
</p><pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>スタックからテーブルまたは<b>nil</b>をポップし、その値を、指定されたインデックスの値の新しいメタテーブルとして設定します（<b>nil</b>はメタテーブルがないことを意味します）。</p><p>（歴史的な理由から、この関数は<code>int</code>を返しますが、現在は常に1です。）</p><hr /><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
</p><pre>void lua_settable (lua_State *L, int index);</pre>

<p><code>t[k] = v</code>と同等の処理を行います。ここで、<code>t</code>は与えられたインデックスの値、<code>v</code>はスタックの一番上の値、<code>k</code>は一番上の値のすぐ下の値です。</p><p>この関数は、キーと値の両方をスタックからポップします。 Luaの場合と同様に、この関数は「newindex」イベントのメタメソッドをトリガーする可能性があります（<a href="#2.4">§2.4</a>を参照）。</p><hr /><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
</p><pre>void lua_settop (lua_State *L, int index);</pre>

<p>任意のインデックス、または0を受け入れ、スタックの一番上をこのインデックスに設定します。新しい一番上が古いものよりも大きい場合、新しい要素は<b>nil</b>で埋められます。<code>index</code>が0の場合、すべてのスタック要素が削除されます。</p><p>この関数は、スタックから閉じられるとマークされたインデックスを削除するときに、任意のコードを実行できます。</p><hr /><h3><a name="lua_setwarnf"><code>lua_setwarnf</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);</pre>

<p>Luaが警告を発行するために使用する警告関数を設定します（<a href="#lua_WarnFunction"><code>lua_WarnFunction</code></a>を参照）。<code>ud</code>パラメータは、警告関数に渡される値<code>ud</code>を設定します。</p><hr /><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>スレッド、および（スレッドを介して間接的に）Luaインタープリターの全体の状態を指す不透明な構造体。 Luaライブラリは完全に再入可能です。グローバル変数はありません。ステートに関するすべての情報は、この構造体を介してアクセスできます。</p><p>この構造体へのポインタは、Luaステートを最初から作成する<a href="#lua_newstate"><code>lua_newstate</code></a>を除く、ライブラリ内のすべての関数への最初の引数として渡す必要があります。</p><hr /><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_status (lua_State *L);</pre>

<p>スレッド<code>L</code>のステータスを返します。</p><p>ステータスは、通常のスレッドの場合は<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>、スレッドがエラーで<a href="#lua_resume"><code>lua_resume</code></a>の実行を終了した場合はエラーコード、スレッドが中断されている場合は<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>になります。</p><p><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>ステータスのスレッドでのみ関数を呼び出すことができます。<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>（新しいコルーチンを開始する）または<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>（コルーチンを再開する）ステータスのスレッドを再開できます。</p><hr /><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, –]</span>
</p><pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>ゼロ終端文字列<code>s</code>を数値に変換し、その数値をスタックにプッシュし、文字列の合計サイズ、つまりその長さ+1を返します。変換は、Luaの字句規則に従って、整数または浮動小数点数になる場合があります（<a href="#3.1">§3.1</a>を参照）。文字列には、先頭と末尾の空白と符号が含まれている場合があります。文字列が有効な数値でない場合は、0を返し、何もプッシュしません（結果はブール値として使用でき、変換が成功した場合はtrueになります）。</p><hr /><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>与えられたインデックスにあるLua値をCのブール値（0または1）に変換します。 Luaのすべてのテストと同様に、<a href="#lua_toboolean"><code>lua_toboolean</code></a>は、<b>false</b>および<b>nil</b>とは異なるLua値に対してtrueを返し、それ以外の場合はfalseを返します。（実際のブール値のみを受け入れる場合は、<a href="#lua_isboolean"><code>lua_isboolean</code></a>を使用して値の型をテストします。）</p><hr /><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>与えられたインデックスの値C関数に変換します。その値はC関数である必要があります。それ以外の場合は、<code>NULL</code>を返します。</p><hr /><h3><a name="lua_toclose"><code>lua_toclose</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>void lua_toclose (lua_State *L, int index);</pre>

<p>スタックの指定されたインデックスを、閉じられるスロットとしてマークします（<a href="#3.3.8">§3.3.8</a>を参照）。 Luaの閉じられる変数と同様に、スタックのそのスロットの値は、スコープ外になると閉じられます。ここで、C関数のコンテキストでは、スコープ外になるとは、実行中の関数がLuaに戻るか、エラーが発生するか、<a href="#lua_settop"><code>lua_settop</code></a>または<a href="#lua_pop"><code>lua_pop</code></a>を使用してスロットがスタックから削除されるか、<a href="#lua_closeslot"><code>lua_closeslot</code></a>が呼び出されることを意味します。閉じられるとマークされたスロットは、<a href="#lua_closeslot"><code>lua_closeslot</code></a>によって事前に非アクティブ化されない限り、<a href="#lua_settop"><code>lua_settop</code></a>または<a href="#lua_pop"><code>lua_pop</code></a>以外のAPIの他の関数によってスタックから削除しないでください。</p><p>この関数は、アクティブな閉じられるスロットと同じか下にあるインデックスに対して呼び出さないでください。</p><p>エラーの場合も通常の戻りの場合も、<code>__close</code>メタメソッドが実行されるまでに、Cスタックはすでに巻き戻されているため、呼び出し関数で宣言された自動C変数（例：バッファ）はスコープ外になることに注意してください。</p><hr /><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p><code>isnum</code>が<code>NULL</code>に等しい<a href="#lua_tointegerx"><code>lua_tointegerx</code></a>と同等です。</p><hr /><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>指定されたインデックスにある Lua の値を、符号付き整数型 <a href="#lua_Integer"><code>lua_Integer</code></a> に変換します。Lua の値は整数であるか、整数に変換可能な数値または文字列である必要があります（<a href="#3.4.3">§3.4.3</a>を参照）。それ以外の場合、<code>lua_tointegerx</code> は 0 を返します。</p><p><code>isnum</code> が <code>NULL</code> でない場合、操作が成功したかどうかを示すブール値が、その参照先に代入されます。</p><hr /><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>指定されたインデックスにある Lua の値を C 文字列に変換します。<code>len</code> が <code>NULL</code> でない場合、<code>*len</code> に文字列の長さが設定されます。Lua の値は文字列または数値である必要があります。それ以外の場合、関数は <code>NULL</code> を返します。値が数値の場合、<code>lua_tolstring</code> は<em>スタック内の実際の値も文字列に変更します</em>。（この変更は、テーブルトラバース中に <code>lua_tolstring</code> がキーに適用されると、<a href="#lua_next"><code>lua_next</code></a> を混乱させます。）</p><p>
<code>lua_tolstring</code> は Lua の状態内の文字列へのポインタを返します（<a href="#4.1.3">§4.1.3</a>を参照）。この文字列は常に最後の文字の後にゼロ ('<code>\0</code>') がありますが（C のように）、本体には他のゼロを含めることができます。</p><hr /><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p><code>isnum</code> が <code>NULL</code> である <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> と同等です。</p><hr /><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>指定されたインデックスにある Lua の値を C 型 <a href="#lua_Number"><code>lua_Number</code></a> に変換します（<a href="#lua_Number"><code>lua_Number</code></a>を参照）。Lua の値は数値であるか、数値に変換可能な文字列である必要があります（<a href="#3.4.3">§3.4.3</a>を参照）。それ以外の場合、<a href="#lua_tonumberx"><code>lua_tonumberx</code></a> は 0 を返します。</p><p><code>isnum</code> が <code>NULL</code> でない場合、操作が成功したかどうかを示すブール値が、その参照先に代入されます。</p><hr /><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>指定されたインデックスにある値を汎用 C ポインタ (<code>void*</code>) に変換します。値は userdata、テーブル、スレッド、文字列、または関数である可能性があります。それ以外の場合、<code>lua_topointer</code> は <code>NULL</code> を返します。異なるオブジェクトは異なるポインタを提供します。ポインタを元の値に戻す方法はありません。</p><p>通常、この関数はハッシュとデバッグ情報にのみ使用されます。</p><hr /><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
</p><pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p><code>len</code> が <code>NULL</code> である <a href="#lua_tolstring"><code>lua_tolstring</code></a> と同等です。</p><hr /><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>指定されたインデックスにある値を Lua スレッド (<code>lua_State*</code> として表現) に変換します。この値はスレッドである必要があります。それ以外の場合、関数は <code>NULL</code> を返します。</p><hr /><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>指定されたインデックスの値が完全な userdata の場合、そのメモリーブロックアドレスを返します。値が light userdata の場合、その値 (ポインタ) を返します。それ以外の場合は、<code>NULL</code> を返します。</p><hr /><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_type (lua_State *L, int index);</pre>

<p>指定された有効なインデックスにある値の型を返します。または、無効ではあるが許容可能なインデックスの場合は <code>LUA_TNONE</code> を返します。<a href="#lua_type"><code>lua_type</code></a> によって返される型は、<code>lua.h</code> で定義された次の定数によってコード化されます。 <a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>, <a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>, <a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>, <a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>, <a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>, <a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>, <a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>, および <a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>。</p><hr /><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p><a href="#lua_type"><code>lua_type</code></a> によって返された値のいずれかである必要がある値 <code>tp</code> によってエンコードされた型の名前を返します。</p><hr /><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p><a href="#lua_Integer"><code>lua_Integer</code></a> の符号なしバージョン。</p><hr /><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_upvalueindex (int i);</pre>

<p>実行中の関数の <code>i</code> 番目のアップバリューを表す疑似インデックスを返します（<a href="#4.2">§4.2</a>を参照）。<code>i</code> は <em>[1,256]</em> の範囲内である必要があります。</p><hr /><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Number lua_version (lua_State *L);</pre>

<p>このコアのバージョン番号を返します。</p><hr /><h3><a name="lua_WarnFunction"><code>lua_WarnFunction</code></a></h3>
<pre>typedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);</pre>

<p>Lua によって警告を生成するために呼び出される警告関数の型です。最初のパラメータは、<a href="#lua_setwarnf"><code>lua_setwarnf</code></a> によって設定された不透明なポインタです。2番目のパラメータは警告メッセージです。3番目のパラメータは、メッセージを次の呼び出しのメッセージで継続する必要があるかどうかを示すブール値です。</p><p>警告の詳細については、<a href="#pdf-warn"><code>warn</code></a> を参照してください。</p><hr /><h3><a name="lua_warning"><code>lua_warning</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_warning (lua_State *L, const char *msg, int tocont);</pre>

<p>指定されたメッセージで警告を発行します。<code>tocont</code> が true の呼び出しでのメッセージは、この関数の別の呼び出しで継続する必要があります。</p><p>警告の詳細については、<a href="#pdf-warn"><code>warn</code></a> を参照してください。</p><hr /><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p><a href="#lua_dump"><code>lua_dump</code></a> によって使用されるライター関数の型です。<a href="#lua_dump"><code>lua_dump</code></a> がチャンクの別の部分を生成するたびに、ライターを呼び出し、書き込まれるバッファ (<code>p</code>)、そのサイズ (<code>sz</code>)、および <a href="#lua_dump"><code>lua_dump</code></a> に提供された <code>ud</code> パラメータを渡します。</p><p>ライターはエラーコードを返します。0 はエラーがないことを意味します。それ以外の値はエラーを意味し、<a href="#lua_dump"><code>lua_dump</code></a> がライターを再度呼び出すのを停止します。</p><hr /><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, –]</span>
</p><pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>同じ状態の異なるスレッド間で値を交換します。</p><p>この関数は、スタック <code>from</code> から <code>n</code> 個の値をポップし、スタック <code>to</code> にプッシュします。</p><hr /><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>この関数は <a href="#lua_yieldk"><code>lua_yieldk</code></a> と同等ですが、継続がありません (<a href="#4.5">§4.5</a> を参照)。したがって、スレッドが再開されると、<code>lua_yield</code> を呼び出す関数を呼び出した関数が続行されます。予期しない事態を避けるために、この関数は末尾呼び出しでのみ呼び出す必要があります。</p><hr /><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
</p><pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>コルーチン（スレッド）を譲ります。</p><p>C 関数が <a href="#lua_yieldk"><code>lua_yieldk</code></a> を呼び出すと、実行中のコルーチンはその実行を中断し、このコルーチンを開始した <a href="#lua_resume"><code>lua_resume</code></a> の呼び出しが戻ります。パラメータ <code>nresults</code> は、<a href="#lua_resume"><code>lua_resume</code></a> の結果として渡されるスタックからの値の数です。</p><p>コルーチンが再び再開されると、Lua は与えられた継続関数 <code>k</code> を呼び出して、譲った C 関数の実行を継続します (<a href="#4.5">§4.5</a> を参照)。この継続関数は、前の関数と同じスタックを、<code>n</code> 個の結果を削除し、<a href="#lua_resume"><code>lua_resume</code></a> に渡された引数に置き換えて受け取ります。さらに、継続関数は、<a href="#lua_yieldk"><code>lua_yieldk</code></a> に渡された値 <code>ctx</code> を受け取ります。</p><p>通常、この関数は戻りません。コルーチンが最終的に再開すると、継続関数の実行を続行します。ただし、1つの特別なケースがあります。それは、この関数がラインまたはカウントフックの中から呼び出された場合です（<a href="#4.7">§4.7</a> を参照）。その場合、<code>lua_yieldk</code> は継続なしで（おそらく <a href="#lua_yield"><code>lua_yield</code></a> の形式で）および結果なしで呼び出す必要があり、フックは呼び出し後すぐに戻る必要があります。Lua は譲り、コルーチンが再び再開すると、フックをトリガーした (Lua) 関数の通常の実行を続行します。</p><p>継続関数を持たない保留中の C 呼び出しがあるスレッド（<em>C 呼び出し境界</em>と呼ばれる）から呼び出された場合、または再開内で実行されていないスレッド（通常はメインスレッド）から呼び出された場合、この関数はエラーを発生させる可能性があります。</p><h2>4.7 – <a name="4.7">デバッグインターフェース</a></h2>

<p>Lua には組み込みのデバッグ機能はありません。代わりに、関数と<em>フック</em>による特別なインターフェースを提供します。このインターフェースを使用すると、さまざまな種類のデバッガ、プロファイラ、およびインタープリタからの「内部情報」を必要とするその他のツールを構築できます。</p><hr /><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  size_t srclen;              /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  unsigned short ftransfer;   /* (r) index of first value transferred */
  unsigned short ntransfer;   /* (r) number of transferred values */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>関数またはアクティベーションレコードに関するさまざまな情報を伝達するために使用される構造体。<a href="#lua_getstack"><code>lua_getstack</code></a> は、後で使用するために、この構造体のプライベート部分のみを埋めます。 <a href="#lua_Debug"><code>lua_Debug</code></a> の他のフィールドを有用な情報で埋めるには、適切なパラメータを使用して <a href="#lua_getinfo"><code>lua_getinfo</code></a> を呼び出す必要があります。（具体的には、フィールドを取得するには、フィールドのコメント内の括弧で囲まれた文字を <a href="#lua_getinfo"><code>lua_getinfo</code></a> のパラメータ <code>what</code> に追加する必要があります。）</p><p><a href="#lua_Debug"><code>lua_Debug</code></a> のフィールドには次の意味があります</p><ul>

<li><b><code>source</code>: </b> 関数を作成したチャンクのソース。<code>source</code> が '<code>@</code>' で始まる場合、関数がファイル内で定義されたことを意味し、ファイル名は '<code>@</code>' の後に続きます。<code>source</code> が '<code>=</code>' で始まる場合、そのコンテンツの残りはユーザーに依存する方法でソースを記述します。それ以外の場合、関数は文字列で定義され、<code>source</code> はその文字列です。</li>

<li><b><code>srclen</code>: </b> 文字列 <code>source</code> の長さ。</li>

<li><b><code>short_src</code>: </b> エラーメッセージで使用される <code>source</code> の「印刷可能な」バージョン。</li>

<li><b><code>linedefined</code>: </b> 関数の定義が始まる行番号。</li>

<li><b><code>lastlinedefined</code>: </b> 関数の定義が終わる行番号。</li>

<li><b><code>what</code>: </b> 関数が Lua 関数の場合は文字列 <code>"Lua"</code>、C 関数の場合は <code>"C"</code>、チャンクのメイン部分の場合は <code>"main"</code>。</li>

<li><b><code>currentline</code>: </b> 与えられた関数が実行されている現在の行。行情報がない場合、<code>currentline</code> は -1 に設定されます。</li>

<li><b><code>name</code>: </b> 与えられた関数の適切な名前。Lua の関数はファーストクラスの値であるため、固定された名前はありません。一部の関数は複数のグローバル変数の値になることがあり、他の関数はテーブルフィールドにのみ格納できます。 <code>lua_getinfo</code> 関数は、関数がどのように呼び出されたかを調べて適切な名前を見つけます。名前が見つからない場合、<code>name</code> は <code>NULL</code> に設定されます。</li>

<li><b><code>namewhat</code>: </b> <code>name</code> フィールドを説明します。 <code>namewhat</code> の値は、関数がどのように呼び出されたかに応じて、<code>"global"</code>、<code>"local"</code>、<code>"method"</code>、<code>"field"</code>、<code>"upvalue"</code>、または <code>""</code>（空文字列）のいずれかになります。（Lua は他のオプションが適用されないと思われる場合、空文字列を使用します。）</li>

<li><b><code>istailcall</code>: </b> この関数の呼び出しが末尾呼び出しによって呼び出された場合は true。この場合、このレベルの呼び出し元はスタックにありません。</li>

<li><b><code>nups</code>: </b> 関数のアップバリューの数。</li>

<li><b><code>nparams</code>: </b> 関数のパラメータの数 (C 関数の場合は常に 0)。</li>

<li><b><code>isvararg</code>: </b> 関数が可変長引数関数の場合 true (C 関数の場合は常に true)。</li>

<li><b><code>ftransfer</code>: </b> 「転送」される最初の値、つまり呼び出しのパラメータまたは戻り値のスタック内のインデックス。(他の値は連続したインデックスにあります。) このインデックスを使用すると、<a href="#lua_getlocal"><code>lua_getlocal</code></a> および <a href="#lua_setlocal"><code>lua_setlocal</code></a> を介してこれらの値にアクセスして変更できます。このフィールドは、呼び出しフック中に最初のパラメータを示す場合、または返される最初の値を示す戻りフック中にのみ意味があります。（呼び出しフックの場合、この値は常に 1 です。）</li>

<li><b><code>ntransfer</code>: </b> 転送される値の数 (前の項目を参照)。(Lua 関数の呼び出しの場合、この値は常に <code>nparams</code> と等しくなります。)</li>

</ul>




<hr /><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>現在のフック関数を返します。</p><hr /><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookcount (lua_State *L);</pre>

<p>現在のフックカウントを返します。</p><hr /><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookmask (lua_State *L);</pre>

<p>現在のフックマスクを返します。</p><hr /><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
</p><pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>特定の関数または関数の呼び出しに関する情報を取得します。</p><p>関数の呼び出しに関する情報を取得するには、パラメータ<code>ar</code>は、以前の<a href="#lua_getstack"><code>lua_getstack</code></a>の呼び出しによって入力されたか、フックへの引数として渡された有効なアクティベーションレコードでなければなりません（<a href="#lua_Hook"><code>lua_Hook</code></a>を参照）。</p><p>関数に関する情報を取得するには、その関数をスタックにプッシュし、<code>what</code>文字列を文字'<code>&gt;</code>'で開始します。（この場合、<code>lua_getinfo</code>はスタックのトップから関数をポップします。）たとえば、関数<code>f</code>が定義された行を知るには、次のコードを記述できます。</p><pre>     lua_Debug ar;
     lua_getglobal(L, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>文字列<code>what</code>の各文字は、構造体<code>ar</code>のいくつかのフィールドを埋めるか、スタックにプッシュする値を選択します。（これらの文字は、構造体<a href="#lua_Debug"><code>lua_Debug</code></a>の宣言でも、各フィールドに続くコメントの括弧内にドキュメント化されています。）</p><ul>

<li><b>'<code>f</code>'：</b> 指定されたレベルで実行中の関数をスタックにプッシュします。</li>

<li><b>'<code>l</code>'：</b> フィールド<code>currentline</code>を埋めます。</li>

<li><b>'<code>n</code>'：</b> フィールド<code>name</code>および<code>namewhat</code>を埋めます。</li>

<li><b>'<code>r</code>'：</b> フィールド<code>ftransfer</code>および<code>ntransfer</code>を埋めます。</li>

<li><b>'<code>S</code>'：</b> フィールド<code>source</code>、<code>short_src</code>、<code>linedefined</code>、<code>lastlinedefined</code>、および<code>what</code>を埋めます。</li>

<li><b>'<code>t</code>'：</b> フィールド<code>istailcall</code>を埋めます。</li>

<li><b>'<code>u</code>'：</b> フィールド<code>nups</code>、<code>nparams</code>、および<code>isvararg</code>を埋めます。</li>

<li><b>'<code>L</code>'：</b> インデックスが、関連付けられたコードを持つ関数の行、つまりブレークポイントを設定できる行であるテーブルをスタックにプッシュします。（コードのない行には、空行とコメントが含まれます。）このオプションをオプション'<code>f</code>'とともに指定すると、そのテーブルは関数の後にプッシュされます。これは、メモリエラーが発生する可能性のある唯一のオプションです。</li>

</ul>

<p>この関数は、<code>what</code>に無効なオプションがあることを示すために0を返します。それでも、有効なオプションは正しく処理されます。</p><hr /><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>指定されたアクティベーションレコードまたは指定された関数のローカル変数または一時的な値に関する情報を取得します。</p><p>最初の場合、パラメータ<code>ar</code>は、以前の<a href="#lua_getstack"><code>lua_getstack</code></a>の呼び出しによって入力されたか、フックへの引数として渡された有効なアクティベーションレコードでなければなりません（<a href="#lua_Hook"><code>lua_Hook</code></a>を参照）。インデックス<code>n</code>は、検査するローカル変数を指定します。変数インデックスと名前の詳細については、<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>を参照してください。</p><p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a>は、変数の値をスタックにプッシュし、その名前を返します。</p><p>2番目のケースでは、<code>ar</code>は<code>NULL</code>でなければならず、検査する関数はスタックの最上位になければなりません。この場合、Lua関数のパラメータのみが表示され（アクティブな変数の情報がないため）、スタックには値がプッシュされません。</p><p>インデックスがアクティブなローカル変数の数よりも大きい場合は、<code>NULL</code>を返します（何もプッシュしません）。</p><hr /><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>インタープリターのランタイムスタックに関する情報を取得します。</p><p>この関数は、指定されたレベルで実行中の関数の*アクティベーションレコード*の識別を使用して<a href="#lua_Debug"><code>lua_Debug</code></a>構造体の一部を埋めます。レベル0は現在実行中の関数であり、レベル*n+1*はレベル*n*を呼び出した関数です（スタックにカウントされない末尾呼び出しを除く）。スタックの深さよりも大きいレベルで呼び出されると、<a href="#lua_getstack"><code>lua_getstack</code></a>は0を返します。それ以外の場合は1を返します。</p><hr /><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>インデックス<code>funcindex</code>にあるクロージャの<code>n</code>番目のアップバリューに関する情報を取得します。アップバリューの値をスタックにプッシュし、その名前を返します。インデックス<code>n</code>がアップバリューの数よりも大きい場合は、<code>NULL</code>を返します（何もプッシュしません）。</p><p>アップバリューの詳細については、<a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a>を参照してください。</p><hr /><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>デバッグフック関数の型。</p><p>フックが呼び出されるたびに、その<code>ar</code>引数のフィールド<code>event</code>には、フックをトリガーした特定のイベントが設定されます。Luaは、これらのイベントを次の定数で識別します：<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>、<a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>、<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>、<a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>、および<a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>。さらに、行イベントの場合、フィールド<code>currentline</code>も設定されます。<code>ar</code>の他のフィールドの値を取得するには、フックは<a href="#lua_getinfo"><code>lua_getinfo</code></a>を呼び出す必要があります。</p><p>呼び出しイベントの場合、<code>event</code>は通常の値である<code>LUA_HOOKCALL</code>、または末尾呼び出しの場合は<code>LUA_HOOKTAILCALL</code>にすることができます。この場合、対応する戻りイベントはありません。</p><p>Luaがフックを実行している間、フックへの他の呼び出しは無効になります。したがって、フックがLuaを呼び出して関数またはチャンクを実行する場合、この実行はフックへの呼び出しなしで発生します。</p><p>フック関数は継続を持つことができません。つまり、nullでない<code>k</code>で<a href="#lua_yieldk"><code>lua_yieldk</code></a>、<a href="#lua_pcallk"><code>lua_pcallk</code></a>、または<a href="#lua_callk"><code>lua_callk</code></a>を呼び出すことはできません。</p><p>フック関数は、次の条件でyieldできます。カウントイベントと行イベントのみがyieldできます。yieldするには、フック関数は、<code>nresults</code>がゼロ（つまり、値がない）である<a href="#lua_yield"><code>lua_yield</code></a>を呼び出して実行を終了する必要があります。</p><hr /><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>デバッグフック関数を設定します。</p><p>引数<code>f</code>はフック関数です。<code>mask</code>は、フックが呼び出されるイベントを指定します。これは、定数<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>、<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>、<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>、および<a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>のビットごとのORで形成されます。<code>count</code>引数は、マスクに<code>LUA_MASKCOUNT</code>が含まれている場合にのみ意味があります。各イベントについて、フックは以下で説明するように呼び出されます。</p><ul>

<li><b>呼び出しフック：</b> インタープリターが関数を呼び出すときに呼び出されます。フックは、Luaが新しい関数に入った直後に呼び出されます。</li>

<li><b>戻りフック：</b> インタープリターが関数から戻るときに呼び出されます。フックは、Luaが関数を離れる直前に呼び出されます。</li>

<li><b>行フック：</b> インタープリターが新しいコード行の実行を開始しようとしているとき、またはコード内で（同じ行にでも）戻るときに呼び出されます。このイベントは、LuaがLua関数を実行している間のみ発生します。</li>

<li><b>カウントフック：</b> インタープリターが<code>count</code>命令を実行するたびに呼び出されます。このイベントは、LuaがLua関数を実行している間のみ発生します。</li>

</ul>

<p>フックは、<code>mask</code>をゼロに設定することで無効になります。</p><hr /><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>指定されたアクティベーションレコードのローカル変数の値を設定します。スタックの最上位の値を変数に割り当て、その名前を返します。また、スタックから値をポップします。</p><p>インデックスがアクティブなローカル変数の数よりも大きい場合は、<code>NULL</code>を返します（何もポップしません）。</p><p>パラメータ<code>ar</code>および<code>n</code>は、関数<a href="#lua_getlocal"><code>lua_getlocal</code></a>と同じです。</p><hr /><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>クロージャのアップバリューの値を設定します。スタックの最上位の値をアップバリューに割り当て、その名前を返します。また、スタックから値をポップします。</p><p>インデックス<code>n</code>がアップバリューの数よりも大きい場合は、<code>NULL</code>を返します（何もポップしません）。</p><p>パラメータ<code>funcindex</code>および<code>n</code>は、関数<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>と同じです。</p><hr /><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>インデックス<code>funcindex</code>にあるクロージャの<code>n</code>番目のアップバリューの一意の識別子を返します。</p><p>これらの固有の識別子により、プログラムは異なるクロージャがアップバリューを共有しているかどうかを確認できます。アップバリューを共有する（つまり、同じ外部ローカル変数にアクセスする）Luaクロージャは、それらのアップバリューインデックスに対して同一のIDを返します。</p><p>パラメータ<code>funcindex</code>および<code>n</code>は、関数<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>と同じですが、<code>n</code>はアップバリューの数よりも大きくすることはできません。</p><hr /><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>インデックス<code>funcindex1</code>にあるLuaクロージャの<code>n1</code>番目のアップバリューを、インデックス<code>funcindex2</code>にあるLuaクロージャの<code>n2</code>番目のアップバリューを参照するようにします。</p>
</body>
</html>
