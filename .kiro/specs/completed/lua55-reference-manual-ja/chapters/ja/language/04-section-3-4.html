<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 - Section 3.4</title>
</head>
<body>
<h2>3.4 – <a name="3.4">式</a></h2>



<p>Lua の基本的な式は次のとおりです。</p><pre>	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= ‘<b>...</b>’
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’
</pre>

<p>数値とリテラル文字列については<a href="#3.1">§3.1</a>で、変数については<a href="#3.2">§3.2</a>で、関数定義については<a href="#3.4.11">§3.4.11</a>で、関数呼び出しについては<a href="#3.4.10">§3.4.10</a>で、テーブルコンストラクターについては<a href="#3.4.9">§3.4.9</a>で説明されています。3つのドット('<code>...</code>')で示される可変長引数式は、可変長引数関数の内部でのみ直接使用できます。これについては<a href="#3.4.11">§3.4.11</a>で説明されています。</p><p>二項演算子には、算術演算子（<a href="#3.4.1">§3.4.1</a>を参照）、ビット演算子（<a href="#3.4.2">§3.4.2</a>を参照）、関係演算子（<a href="#3.4.4">§3.4.4</a>を参照）、論理演算子（<a href="#3.4.5">§3.4.5</a>を参照）、および連結演算子（<a href="#3.4.6">§3.4.6</a>を参照）が含まれます。単項演算子には、単項マイナス（<a href="#3.4.1">§3.4.1</a>を参照）、単項ビット単位 NOT（<a href="#3.4.2">§3.4.2</a>を参照）、単項論理 <b>not</b>（<a href="#3.4.5">§3.4.5</a>を参照）、および単項<em>長さ演算子</em>（<a href="#3.4.7">§3.4.7</a>を参照）が含まれます。</p><h3>3.4.1 – <a name="3.4.1">算術演算子</a></h3><p>Lua は次の算術演算子をサポートしています。</p><ul>
<li><b><code>+</code>: </b>加算</li>
<li><b><code>-</code>: </b>減算</li>
<li><b><code>*</code>: </b>乗算</li>
<li><b><code>/</code>: </b>浮動小数点除算</li>
<li><b><code>//</code>: </b>床関数除算</li>
<li><b><code>%</code>: </b>剰余</li>
<li><b><code>^</code>: </b>べき乗</li>
<li><b><code>-</code>: </b>単項マイナス</li>
</ul>

<p>べき乗と浮動小数点除算を除いて、算術演算子は次のように動作します。両方のオペランドが整数の場合、演算は整数に対して実行され、結果は整数になります。それ以外の場合、両方のオペランドが数値の場合、それらは浮動小数点数に変換され、浮動小数点演算のマシンルール（通常は IEEE 754 標準）に従って演算が実行され、結果は浮動小数点数になります。（文字列ライブラリは算術演算で文字列を数値に強制変換します。詳細については<a href="#3.4.3">§3.4.3</a>を参照してください。）</p><p>べき乗と浮動小数点除算（<code>/</code>）は、常にオペランドを浮動小数点数に変換し、結果は常に浮動小数点数になります。べき乗は ISO&nbsp;C 関数 <code>pow</code> を使用するため、整数以外の指数にも対応できます。</p><p>床関数除算（<code>//</code>）は、商を負の無限大方向に丸める除算であり、オペランドの除算の床を返します。</p><p>剰余は、商を負の無限大方向（床関数除算）に丸める除算の余りとして定義されます。</p><p>整数演算でオーバーフローが発生した場合、すべての演算は<em>ラップアラウンド</em>します。</p><h3>3.4.2 – <a name="3.4.2">ビット演算子</a></h3><p>Lua は次のビット演算子をサポートしています。</p><ul>
<li><b><code>&amp;</code>: </b>ビット単位 AND</li>
<li><b><code>|</code>: </b>ビット単位 OR</li>
<li><b><code>~</code>: </b>ビット単位排他的 OR</li>
<li><b><code>&gt;&gt;</code>: </b>右シフト</li>
<li><b><code>&lt;&lt;</code>: </b>左シフト</li>
<li><b><code>~</code>: </b>単項ビット単位 NOT</li>
</ul>

<p>すべてのビット単位演算は、オペランドを整数に変換し（<a href="#3.4.3">§3.4.3</a>を参照）、それらの整数のすべてのビットで演算を行い、整数を返します。</p><p>右シフトと左シフトの両方で、空いているビットはゼロで埋められます。負の変位は反対方向にシフトします。整数のビット数以上の絶対値を持つ変位は、ゼロになります（すべてのビットがシフトアウトされるため）。</p><h3>3.4.3 – <a name="3.4.3">強制型変換と変換</a></h3><p>Lua は、実行時にいくつかの型と表現の間で自動変換を行います。ビット単位演算子は、常に浮動小数点オペランドを整数に変換します。べき乗と浮動小数点除算は、常に整数オペランドを浮動小数点数に変換します。混合数値（整数と浮動小数点数）に適用される他のすべての算術演算は、整数オペランドを浮動小数点数に変換します。C API は、必要に応じて整数を浮動小数点数に、浮動小数点数を整数に変換します。さらに、文字列連結は、文字列に加えて数値を引数として受け入れます。</p><p>整数から浮動小数点数への変換では、整数値が浮動小数点数として正確に表現できる場合、それが結果となります。それ以外の場合、変換は、最も近い大きい値または最も近い小さい表現可能な値を取得します。この種の変換は決して失敗しません。</p><p>浮動小数点数から整数への変換では、浮動小数点数が整数として正確に表現できるかどうか（つまり、浮動小数点数が整数値を持ち、整数の表現範囲内にあるかどうか）をチェックします。そうである場合、その表現が結果になります。それ以外の場合、変換は失敗します。</p><p>Lua のいくつかの場所では、必要に応じて文字列を数値に強制変換します。特に、文字列ライブラリは、すべての算術演算で文字列を数値に強制変換しようとするメタメソッドを設定します。変換が失敗した場合、ライブラリは他のオペランドのメタメソッド（存在する場合）を呼び出すか、エラーを発生させます。ビット単位演算子は、この強制変換を行わないことに注意してください。</p><p>文字列から数値への暗黙的な強制変換に依存しないことは常に良い習慣です。これらは常に適用されるわけではないためです。特に、<code>"1"==1</code> は false であり、<code>"1"&lt;1</code> はエラーを発生させます（<a href="#3.4.4">§3.4.4</a>を参照）。これらの強制変換は主に互換性のために存在し、将来のバージョンの言語で削除される可能性があります。</p><p>文字列は、その構文と Lua レクサーのルールに従って、整数または浮動小数点数に変換されます。文字列には、先頭と末尾の空白と符号が含まれる場合もあります。文字列から数値へのすべての変換は、基数文字としてドットと現在のロケールマークの両方を受け入れます。（ただし、Lua レクサーはドットのみを受け入れます。）文字列が有効な数値でない場合、変換は失敗します。必要に応じて、この最初のステップの結果は、浮動小数点数と整数間の変換に関する前のルールに従って、特定の数値サブタイプに変換されます。</p><p>数値から文字列への変換では、指定されていない人間が読める形式を使用します。数値を特定の方法で文字列に変換するには、関数<a href="#pdf-string.format"><code>string.format</code></a>を使用してください。</p><h3>3.4.4 – <a name="3.4.4">関係演算子</a></h3><p>Lua は次の関係演算子をサポートしています。</p><ul>
<li><b><code>==</code>: </b>等しい</li>
<li><b><code>~=</code>: </b>等しくない</li>
<li><b><code>&lt;</code>: </b>より小さい</li>
<li><b><code>&gt;</code>: </b>より大きい</li>
<li><b><code>&lt;=</code>: </b>以下</li>
<li><b><code>&gt;=</code>: </b>以上</li>
</ul><p>これらの演算子は常に <b>false</b> または <b>true</b> を返します。</p><p>等価性（<code>==</code>）は、最初にオペランドの型を比較します。型が異なる場合、結果は <b>false</b> です。それ以外の場合、オペランドの値が比較されます。文字列は、バイト内容が同じ場合に等しくなります。数値は、数学的に同じ値を表す場合に等しくなります。</p><p>テーブル、ユーザーデータ、およびスレッドは参照によって比較されます。2つのオブジェクトが等しいと見なされるのは、同じオブジェクトである場合のみです。新しいオブジェクト（テーブル、ユーザーデータ、またはスレッド）を作成するたびに、この新しいオブジェクトは、以前に存在したオブジェクトとは異なります。関数は常にそれ自身と等しくなります。検出可能な違い（動作の違い、定義の違い）を持つ関数は常に異なります。異なる時点で作成されたが、検出可能な違いがない関数は、等しいと分類される場合とされない場合があります（内部キャッシュの詳細によって異なります）。</p><p><code>__eq</code>メタメソッドを使用すると、Lua がテーブルとユーザーデータを比較する方法を変更できます（<a href="#2.4">§2.4</a>を参照）。</p><p>等価性比較では、文字列を数値に、またはその逆に変換しません。したがって、<code>"0"==0</code>は<b>false</b>と評価され、<code>t[0]</code>と<code>t["0"]</code>はテーブル内の異なるエントリを表します。</p><p>演算子<code>~=</code>は、等価性（<code>==</code>）の否定です。</p><p>順序演算子は次のように動作します。両方の引数が数値の場合、それらはサブタイプに関係なく、数学的な値に従って比較されます。それ以外の場合、両方の引数が文字列である場合、それらの値は現在のロケールに従って比較されます。それ以外の場合、Lua は <code>__lt</code> または <code>__le</code> メタメソッドを呼び出そうとします（<a href="#2.4">§2.4</a>を参照）。比較 <code>a &gt; b</code> は <code>b &lt; a</code> に変換され、<code>a &gt;= b</code> は <code>b &lt;= a</code> に変換されます。</p><p>IEEE 754 標準に従い、特殊値 NaN は、それ自身を含め、どの値よりも小さい、等しい、または大きいとは見なされません。</p><h3>3.4.5 – <a name="3.4.5">論理演算子</a></h3><p>Lua の論理演算子は、<b>and</b>、<b>or</b>、および <b>not</b> です。制御構造（<a href="#3.3.4">§3.3.4</a>を参照）と同様に、すべての論理演算子は、<b>false</b> と <b>nil</b> の両方を false とみなし、その他を true とみなします。</p><p>否定演算子 <b>not</b> は、常に <b>false</b> または <b>true</b> を返します。論理積演算子 <b>and</b> は、この値が <b>false</b> または <b>nil</b> である場合は最初の引数を返し、それ以外の場合は <b>and</b> は2番目の引数を返します。論理和演算子 <b>or</b> は、この値が <b>nil</b> および <b>false</b> と異なる場合は最初の引数を返し、それ以外の場合は <b>or</b> は2番目の引数を返します。<b>and</b> と <b>or</b> の両方で短絡評価が使用されます。つまり、2番目のオペランドは必要な場合にのみ評価されます。以下にいくつかの例を示します。</p><pre>     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre>




<h3>3.4.6 – <a name="3.4.6">連結</a></h3><p>Lua の文字列連結演算子は、2つのドット('<code>..</code>')で示されます。両方のオペランドが文字列または数値の場合、数値は指定されていない形式で文字列に変換されます（<a href="#3.4.3">§3.4.3</a>を参照）。それ以外の場合、<code>__concat</code>メタメソッドが呼び出されます（<a href="#2.4">§2.4</a>を参照）。</p><h3>3.4.7 – <a name="3.4.7">長さ演算子</a></h3>

<p>長さ演算子は、単項プレフィックス演算子 <code>#</code> で示されます。</p><p>文字列の長さは、そのバイト数です。（つまり、各文字が1バイトの場合の文字列長の通常の意味です。）</p><p>テーブルに適用された長さ演算子は、そのテーブルの境界を返します。テーブル <code>t</code> の<em>境界</em>は、次の条件を満たす任意の非負の整数です。</p><pre>     (border == 0 or t[border] ~= nil) and
     (t[border + 1] == nil or border == math.maxinteger)
</pre><p>言葉で言えば、境界とは、テーブル内に存在する正の整数インデックスであり、それに続いて存在しないインデックスが続く場合と、2つの制限ケースがあります。インデックス 1 が存在しない場合はゼロ、そのインデックスが存在する場合は整数の最大値です。正の整数ではないキーは、境界に干渉しないことに注意してください。</p><p>境界が1つしかないテーブルは、<em>シーケンス</em>と呼ばれます。たとえば、テーブル <code>{10, 20, 30, 40, 50}</code> は境界（5）が1つしかないため、シーケンスです。テーブル <code>{10, 20, 30, nil, 50}</code> には2つの境界（3と5）があるため、シーケンスではありません。（インデックス 4 の <b>nil</b> は<em>穴</em>と呼ばれます。）テーブル <code>{nil, 20, 30, nil, nil, 60, nil}</code> には3つの境界（0、3、および 6）があるため、これもシーケンスではありません。テーブル <code>{}</code> は境界 0 のシーケンスです。</p><p><code>t</code> がシーケンスの場合、<code>#t</code> はその唯一の境界を返し、これはシーケンスの長さという直感的な概念に対応します。<code>t</code> がシーケンスでない場合、<code>#t</code> はその境界のいずれかを返す可能性があります。（どの境界が返されるかは、テーブルの内部表現の詳細に依存し、テーブルがどのようにデータが格納されたか、および数値ではないキーのメモリアドレスに依存します。）</p><p>テーブルの長さの計算は、最悪の場合でも <em>O(log n)</em> の時間が保証されています。ここで、<em>n</em> はテーブル内の最大の整数キーです。</p><p>プログラムは、<code>__len</code> メタメソッド（<a href="#2.4">§2.4</a> を参照）を使用して、文字列以外の任意の値に対する長さ演算子の動作を変更できます。</p><h3>3.4.8 – <a name="3.4.8">優先順位</a></h3><p>Lua における演算子の優先順位は、以下の表に従い、低いものから高いものの順に示します。</p><pre>     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>通常どおり、式での優先順位を変更するために括弧を使用できます。連結演算子 (<code>..</code>) とべき乗演算子 (<code>^</code>) は右結合です。その他のすべての二項演算子は左結合です。</p><h3>3.4.9 – <a name="3.4.9">テーブルコンストラクタ</a></h3><p>テーブルコンストラクタは、テーブルを作成する式です。コンストラクタが評価されるたびに、新しいテーブルが作成されます。コンストラクタは、空のテーブルを作成したり、テーブルを作成してそのフィールドの一部を初期化したりするために使用できます。コンストラクタの一般的な構文は次のとおりです。</p><pre>	tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp
	fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’
</pre>

<p><code>[exp1] = exp2</code> の形式の各フィールドは、キーが <code>exp1</code> で値が <code>exp2</code> のエントリを新しいテーブルに追加します。<code>name = exp</code> の形式のフィールドは、<code>["name"] = exp</code> と同等です。<code>exp</code> の形式のフィールドは、<code>[i] = exp</code> と同等です。ここで、<code>i</code> は 1 から始まる連続した整数です。その他の形式のフィールドは、このカウントに影響しません。たとえば、</p><pre>     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>は、次のものと同等です。</p><pre>     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>コンストラクタ内での代入の順序は未定義です。（この順序は、キーが繰り返されている場合にのみ重要になります。）</p><p>リスト内の最後のフィールドが <code>exp</code> の形式であり、その式が複数結果の式である場合、この式によって返されるすべての値がリストに連続して入力されます（<a href="#3.4.12">§3.4.12</a> を参照）。</p><p>フィールドリストには、機械生成されたコードの便宜のために、オプションの末尾の区切り記号を含めることができます。</p><h3>3.4.10 – <a name="3.4.10">関数呼び出し</a></h3><p>Lua での関数呼び出しの構文は次のとおりです。</p><pre>	functioncall ::= prefixexp args
</pre><p>関数呼び出しでは、最初に prefixexp と args が評価されます。prefixexp の値の型が <em>function</em> である場合、この関数は指定された引数で呼び出されます。それ以外の場合、prefixexp の <code>__call</code> メタメソッドが存在すればそれが呼び出されます。その最初の引数は prefixexp の値であり、その後に元の呼び出し引数が続きます（<a href="#2.4">§2.4</a> を参照）。</p><p>次の形式</p><pre>	functioncall ::= prefixexp ‘<b>:</b>’ Name args
</pre><p>は、メソッドをエミュレートするために使用できます。<code>v:name(<em>args</em>)</code> の呼び出しは、<code>v.name(v,<em>args</em>)</code> のシンタックスシュガーです。ただし、<code>v</code> は一度だけ評価されます。</p><p>引数の構文は次のとおりです。</p><pre>	args ::= ‘<b>(</b>’ [explist] ‘<b>)</b>’
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>すべての引数式は、呼び出し前に評価されます。<code>f{<em>fields</em>}</code> の形式の呼び出しは、<code>f({<em>fields</em>})</code> のシンタックスシュガーです。つまり、引数リストは単一の新しいテーブルです。<code>f'<em>string</em>'</code> (または <code>f"<em>string</em>"</code> または <code>f[[<em>string</em>]]</code>) の形式の呼び出しは、<code>f('<em>string</em>')</code> のシンタックスシュガーです。つまり、引数リストは単一のリテラル文字列です。</p><p>閉じられる変数のスコープ内にない <code>return <em>functioncall</em></code> の形式の呼び出しは、<em>末尾呼び出し</em>と呼ばれます。Lua は、<em>適切な末尾呼び出し</em>（または<em>適切な末尾再帰</em>）を実装しています。末尾呼び出しでは、呼び出される関数は呼び出し元の関数のスタックエントリを再利用します。したがって、プログラムが実行できるネストされた末尾呼び出しの数に制限はありません。ただし、末尾呼び出しは、呼び出し元の関数に関するデバッグ情報を消去します。末尾呼び出しは、<b>return</b> が引数として単一の関数呼び出しを持ち、閉じられる変数のスコープ外にある特定の構文でのみ発生することに注意してください。この構文により、呼び出し元の関数は、介入アクションなしに、呼び出された関数の戻り値を正確に返します。したがって、次の例はどれも末尾呼び出しではありません。</p><pre>     return (f(x))        -- results adjusted to 1
     return 2 * f(x)      -- result multiplied by 2
     return x, f(x)       -- additional results
     f(x); return         -- results discarded
     return x or f(x)     -- results adjusted to 1
</pre>




<h3>3.4.11 – <a name="3.4.11">関数定義</a></h3>

<p>関数定義の構文は次のとおりです。</p><pre>	functiondef ::= <b>function</b> funcbody
	funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b>
</pre>

<p>次のシンタックスシュガーは、関数定義を簡略化します。</p><pre>	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]
</pre><p>文</p><pre>     function f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     f = function () <em>body</em> end
</pre><p>文</p><pre>     function t.a.b.c.f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     t.a.b.c.f = function () <em>body</em> end
</pre><p>文</p><pre>     local function f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     local f; f = function () <em>body</em> end
</pre><p>ではなく、</p><pre>     local f = function () <em>body</em> end
</pre><p>（これは、関数の本体に <code>f</code> への参照が含まれている場合にのみ違いが生じます。）</p><p>関数定義は、型が <em>function</em> の実行可能な式です。Lua がチャンクをプリコンパイルするとき、その関数本体はすべてプリコンパイルされますが、まだ作成されていません。その後、Lua が関数定義を実行するたびに、関数は<em>インスタンス化</em>（または<em>クローズ</em>）されます。この関数インスタンス、または<em>クロージャ</em>は、式の最終的な値です。</p><p>パラメータは、引数値で初期化されるローカル変数として機能します。</p><pre>	parlist ::= namelist [‘<b>,</b>’ ‘<b>...</b>’] | ‘<b>...</b>’
</pre><p>Lua 関数が呼び出されると、関数が<em>可変長引数関数</em>でない限り、引数リストをパラメータリストの長さに調整します（<a href="#3.4.12">§3.4.12</a> を参照）。可変長引数関数は、パラメータリストの最後に3つのドット（<code>...</code>）で示されます。可変長引数関数は、引数リストを調整しません。代わりに、すべての追加引数を収集し、3つのドットとしても記述される<em>可変長引数式</em>を介して関数に提供します。この式の値は、複数結果を持つ関数と同様に、すべての実際の追加引数のリストです（<a href="#3.4.12">§3.4.12</a> を参照）。</p><p>例として、次の定義を検討してください。</p><pre>     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>次に、引数からパラメータと可変長引数式への次のマッピングがあります。</p><pre>     CALL             PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>結果は、<b>return</b> ステートメント（<a href="#3.3.4">§3.3.4</a> を参照）を使用して返されます。制御が <b>return</b> ステートメントに遭遇せずに関数の終わりに到達した場合、関数は結果なしで返されます。</p><p>関数が返すことができる値の数には、システムに依存する制限があります。この制限は、1000 より大きいことが保証されています。</p><p><em>コロン</em>構文は、関数に暗黙的な追加のパラメータ <code>self</code> を追加することで、<em>メソッド</em>をエミュレートするために使用されます。したがって、文</p><pre>     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>は、次のシンタックスシュガーです。</p><pre>     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>




<h3>3.4.12 – <a name="3.4.12">式のリスト、複数の結果、および調整</a></h3>

<p>関数呼び出しと可変長引数式の両方が、複数の値を返す可能性があります。これらの式は、<em>複数結果の式</em>と呼ばれます。</p><p>複数結果の式が式のリストの最後の要素として使用される場合、式からのすべての結果が式のリストによって生成された値のリストに追加されます。式のリストを予期する場所に単一の式がある場合、その（シングルトン）リストの最後の式になることに注意してください。</p><p>これらは、Lua が式のリストを予期する場所です。</p><ul>

<li><b>return</b> ステートメント。たとえば、<code>return e1, e2, e3</code> （<a href="#3.3.4">§3.3.4</a> を参照）。</li>

<li>テーブルコンストラクタ。たとえば、<code>{e1, e2, e3}</code> （<a href="#3.4.9">§3.4.9</a> を参照）。</li>

<li>関数呼び出しの引数。たとえば、<code>foo(e1, e2, e3)</code> （<a href="#3.4.10">§3.4.10</a> を参照）。</li>

<li>複数代入。たとえば、<code>a , b, c = e1, e2, e3</code> （<a href="#3.3.3">§3.3.3</a> を参照）。</li>

<li>ローカル宣言。たとえば、<code>local a , b, c = e1, e2, e3</code> （<a href="#3.3.7">§3.3.7</a> を参照）。</li>

<li>汎用 <b>for</b> ループでの初期値。たとえば、<code>for k in e1, e2, e3 do ... end</code> （<a href="#3.3.5">§3.3.5</a> を参照）。</li>

</ul><p>最後の4つのケースでは、式のリストからの値のリストを特定の長さに<em>調整</em>する必要があります。つまり、可変長引数関数ではない関数への呼び出しのパラメータ数（<a href="#3.4.11">§3.4.11</a> を参照）、複数代入またはローカル宣言の変数の数、および汎用 <b>for</b> ループの場合は正確に4つの値です。<em>調整</em>は、次の規則に従います。必要な値よりも多くの値がある場合、余分な値は破棄されます。必要な値よりも少ない値がある場合、リストは <b>nil</b> で拡張されます。式のリストが複数結果の式で終わる場合、調整の前に、その式からのすべての結果が値のリストに入力されます。</p><p>複数結果の式が、最後の要素ではない式のリストで使用されている場合、または構文が単一の式を予期する場所で使用されている場合、Lua はその式の結果リストを1つの要素に調整します。特定の場合として、構文は括弧で囲まれた式の中に単一の式があることを予期します。したがって、複数結果の式の周囲に括弧を追加すると、正確に1つの結果が生成されます。</p><p>構文が単一の式を予期する場所で可変長引数式を使用する必要はほとんどありません。（通常、可変長引数部分の前に通常のパラメータを追加して、そのパラメータを使用する方が簡単です。）そのような必要がある場合は、可変長引数式を単一の変数に割り当てて、その変数を代わりに使用することをお勧めします。</p><p>複数結果の式の使用例を次に示します。すべての場合において、構成が「n番目の結果」を必要とし、そのような結果がない場合は、<b>nil</b> が使用されます。</p><pre>     print(x, f())      -- prints x and all results from f().
     print(x, (f()))    -- prints x and the first result from f().
     print(f(), x)      -- prints the first result from f() and x.
     print(1 + f())     -- prints 1 added to the first result from f().
     local x = ...      -- x gets the first vararg argument.
     x,y = ...          -- x gets the first vararg argument,
                        -- y gets the second vararg argument.
     x,y,z = w, f()     -- x gets w, y gets the first result from f(),
                        -- z gets the second result from f().
     x,y,z = f()        -- x gets the first result from f(),
                        -- y gets the second result from f(),
                        -- z gets the third result from f().
     x,y,z = f(), g()   -- x gets the first result from f(),
                        -- y gets the first result from g(),
                        -- z gets the second result from g().
     x,y,z = (f())      -- x gets the first result from f(), y and z get nil.
     return f()         -- returns all results from f().
     return x, ...      -- returns x and all received vararg arguments.
     return x,y,f()     -- returns x, y, and all results from f().
     {f()}              -- creates a list with all results from f().
     {...}              -- creates a list with all vararg arguments.
     {f(), 5}           -- creates a list with the first result from f() and 5.
</pre>







</body>
</html>
