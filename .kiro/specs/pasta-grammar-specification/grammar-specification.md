# Pasta DSL 文法仕様書

このドキュメントは、Pasta スクリプト言語の完全な文法定義です。設計フェーズで詳細化され、実装フェーズで参照されます。

---

## 1. 文法モデルの基本原則

### 1.1 行指向文法
Pasta スクリプトは**行指向文法**です。行頭の数文字により行属性が確定します。

**構文**:
```pest
sakura_command ::= "\"" ~ identifier ~ bracket_content?
identifier ::= [a-zA-Z0-9_]+  /* 数字開始も許容 */
bracket_content ::= "[" ~ content ~ "]"
```
├─ グローバルラベル (＊ 或いは *)
│  ├─ 単語定義行 (＠)
│  └─ Rune コードブロック
├─ グローバル単語定義 (＠)
└─ コメント行 (＃)
```

### 1.3 式の制約（設計方針）

**現在の方針**: Pasta DSL では**式（Expression）を記述できません**。

#### 制約の理由
1. **シンプルな文法**: DSL を宣言的に保ち、学習コストを低減
2. **複雑なロジックは Rune で**: 演算・条件判定が必要な場合は Rune ブロックで関数を定義
3. **関数呼び出しベース**: DSL からは関数を呼び出す形式で値を取得

#### 許可されない構文例
```pasta
# ❌ 式は書けない
＄result ： 10 + 20 * 3
＄flag ： ＄x > 5 && ＄y < 10
Alice：私のスコアは ＠score + 100 です
```

#### 許可される構文例
````pasta
# ✅ リテラル値
＄score ： 100

# ✅ 関数呼び出し
＄result ： ＠calculate()

# ✅ 単語参照
＄value ： ＠word_name

# ✅ Rune ブロックで複雑な演算
```rune
fn calculate(ctx) {
    let result = 10 + 20 * 3;
    result
}
```
＄result ： ＠calculate()
````

**将来の拡張**: 演算子は将来の式サポートのために予約されています（2.7参照）。現時点では使用できませんが、将来的に段階的な式サポートを検討する可能性があります。

---

## 2. キーワード・マーカー定義

### 2.1 基本要素

#### 改行（NEWLINE）
```pest
改行 ::= "\r\n" | "\n" | "\r"
```

**セマンティクス**:
- 行の終わりを明示する
- 行指向文法では改行により行属性が確定する
- すべての行要素は改行で終わる

#### 空白（WHITE_SPACE 文字クラス）
Pasta では空白をトークンとして扱う可能性があるため、Pest の `WHITE_SPACE` 文字クラスを使用します。ただし、Pasta は行指向文法であるため、改行文字（`\r`, `\n`）は空白から除外します。

**重要**: これは Pest の WHITESPACE ルール（トークン自動スキップ）ではなく、明示的に処理される文字クラスです。

**構成** (改行を除外):
- 半角スペース：` `（U+0020）
- タブ：`\t`（U+0009）
- 全角スペース：`　`（U+3000）
- その他 Unicode 空白：U+00A0, U+1680, U+2000-U+200A, U+202F, U+205F

**セマンティクス**:
- 空白が許可される文脈において、1つ以上の連続白文字（改行を除く）はすべて消費されて、1つの「空白」トークンとして扱われます
- 改行は意図的に除外され、行の区切り文字として機能します
- 空白は有効なトークン区切り文字であり、Pest の自動スキップ対象ではありません

#### コロン（Colon）
```pest
コロン ::= "：" | ":"
```

**セマンティクス**: キー・値ペア形式（key ： value）の汎用区切り文字

**設計原則**: コロンは**キー：バリュー関係**を表す場合にのみ使用します。比較・フィルター条件には比較演算子（＝、＞、＜など）を使用します。

**用途**:
- 変数代入：`＄var_name ： value`
- 単語定義：`＠word_name ： value1 value2`
- 属性定義：`＆key ： value`
- アクション行：`actor ： action`
- 引数リスト（関数呼び出し）：`＠func（arg1：value1　arg2：value2）`

#### 識別子（Identifier）
```pest
識別子 ::= { XID_START ~ XID_CONTINUE* }
```

**XID_START**: Unicode Identifier Start
- ASCII: `a-z`, `A-Z`, `_`
- 日本語: 平仮名、カタカナ、漢字、ハングル等

**XID_CONTINUE**: Unicode Identifier Continue
- XID_START の全て + ASCII digits + 結合記号

**制約**:
- 予約パターン `__*__` は未使用（システム予約）
- 例：`__start__`, `__word_test__`

**切り出し規則（最長一致）**:
- 空白による区切りが無い場合、識別子は「識別子に含まれない文字」が現れるまでを最長一致で切り出す
- 例：`＠挨拶、みんな！` → 識別子は「挨拶」、以降は通常テキスト「、みんな！」

#### インデント（Indent）
```pest
インデント ::= WHITE_SPACE+
```

**セマンティクス**: 行頭に存在する1つ以上の連続した空白文字。行がグローバルレベルか下層レベルかを区別します。

**重要**: インデントの有無のみが判定基準です。
- インデント深さの判定は**不要**。深さを測定・比較する必要はありません
- 単純な「有（any positive indent）/ 無（no indent）」のバイナリ判定で十分

**用途**:
- インデントなし = グローバルレベル（グローバルラベル、グローバル単語定義など）
- インデントあり（深さ問わず） = 下層レベル（グローバルラベル直下のすべての行）

**定義の参照**: [2.1 空白（WHITE_SPACE 文字クラス）](#空白white_space-文字クラス)に定義されるWHITE_SPACE文字クラスを使用。

**例**:
```
＊会話               ← インデントなし（グローバルレベル）
  ＆author：Alice    ← インデントあり（下層レベル）
  ・選択肢1         ← インデントあり（下層レベル）
  Alice：おはよう    ← インデントあり（下層レベル）
```

---

### 2.2 ラベル・マーカー

#### グローバルラベル（Global Label Marker）
```
グローバルラベルマーカー ::= "＊" | "*"
使用例: ＊会話 或いは *conversation
```

#### ローカルラベル（Local Label Marker）
```
ローカルラベルマーカー ::= "・" | "-"
使用例: ・選択肢1 或いは -choice1
```

#### 属性（Attribute Marker）
```
属性マーカー ::= "＆" | "&"
使用例: ＆author：Alice
```

---

### 2.3 変数・関数

#### 単語登録・参照・呼び出し（At Marker）
```
マーカー ::= "＠" | "@"
```

**3つの用法**:

| 用法 | 構文 | 説明 |
|------|------|------|
| 単語登録 | `＠word_name：value1　value2` | グローバル単語辞書に登録 |
| 単語参照 | `＠word_name` | 登録済み単語値を参照 |
| 単語参照（動的） | `＠＄var_name` | 変数値を単語名として間接参照 |
| 関数呼び出し | `＠func_name()` | 関数を呼び出し（引数なし） |
| 関数呼び出し（引数付き） | `＠func_name（arg1：val1　arg2：val2）` | 名前付き引数で呼び出し |

#### 変数宣言・代入（Dollar Marker）
```
マーカー ::= "＄" | "$"
使用例: ＄my_var ： 10
```

#### 変数スコープ修飾子
```
スコープ修飾 ::= グローバルラベルマーカー
使用例: ＄＊global_var  （グローバル変数）
       ＄local_var      （ローカル変数）
```

---

### 2.4 制御フロー

#### Call マーカー
```
Callマーカー ::= "＞" | ">"
```

**セマンティクス**: 指定ラベルを呼び出し、実行後に戻る

**構文**:
```
＞call_target [＆filter1＝value1＆filter2＝value2...] [arg_list]
```

詳細は [4. Call の詳細仕様](#4-call-の詳細仕様) を参照

---

### 2.5 音声・会話

#### Sakura スクリプト エスケープ
```
エスケープ ::= "\"
```

**重要**: Sakura スクリプトは半角ベースの記法です。エスケープ文字は厳密に半角バックスラッシュ（\）のみを使用します。

詳細は [5. Sakura スクリプト仕様](#5-sakura-スクリプト仕様) を参照

---

### 2.6 Rune コードブロック

#### ブロック開始
```
開始マーカー ::= "```" | "```rune"
```

**重要**: rune 接尾辞は任意。接尾辞を付ける場合、許可される値は「rune」のみ。

#### ブロック終了
```
終了マーカー ::= "```"
```

**セマンティクス**: 複数行にわたり Rune VM へ直接実行されるコード

**インデント**: Rune ブロックはインデント不要です。構造上は直前のグローバルラベルに属します（インデントの有無に関わらずグローバルラベル配下として扱われます）。

**処理モデル**:
- **パーサー層（Pest）**: Runeブロックの内容は透過的に処理されます。開始マーカー `\`\`\`` または `\`\`\`rune` と終了マーカー `\`\`\`` の間をそのまま抽出するのみで、内部の文法は検証しません。
- **トランスパイラー層**: 抽出されたRuneコード文字列が、「**Rune関数定義のみからなる正式なコード**」として成立することを検証・コンパイルします。ステートメント（変数宣言、代入、制御フローなど）は許可されません。
- **許可される内容**: 関数定義（`fn ...`）のみ。例：`fn on_event() { ... }`, `fn update_state() { ... }`
- **許可されない内容**: `let x = 10;` のような変数宣言、直接的なステートメント、トップレベルの式など。
- **エラーハンドリング**: Rune文法に誤りがある場合、または関数定義以外のコードが含まれる場合、**トランスパイラー層以降でコンパイルエラーが発生**します。パーサー層ではエラーとなりません。

**例**:
````pasta
＊会話
```rune
fn on_init() {
  ctx.flag("talked", true);
}
fn on_event() {
  for i in 0..10 {
    yield ctx.event("loop", i);
  }
}
```
````

または：
````pasta
＊会話
```
fn update_state() {
  ctx.score = ctx.score + 1;
}
```
````

---

### 2.7 演算子

**設計原則**: すべての演算子は全角・半角の両方の形式を許容します。両者は同等に扱われます。

**重要**: 演算子は**将来予約**です。現時点では、Pasta DSL 内で式を記述できません（1.3参照）。演算子は将来の式サポートのために定義されていますが、現在は使用できません。

#### 算術演算子

| 演算 | 全角 | 半角 | 備考 |
|------|------|------|------|
| 加算 | 「＋」 | 「+」 | |
| 減算 | 「－」 | 「-」 | 数値の負号と区別注意 |
| 乗算 | 「＊」「×」 | 「*」 | 「＊」はラベルマーカーと同じ文字 |
| 除算 | 「／」「÷」 | 「/」 | |
| 剰余 | 「％」 | 「%」 | |

#### 比較演算子

**セマンティクス**: 全角・半角は同等に扱われます。

| 演算 | 全角 | 半角 | 備考 |
|------|------|------|------|
| 等値 | 「＝＝」 | 「==」 | |
| 不等 | 「！＝」 | 「!=」 | |
| より小さい | 「＜」 | 「<」 | |
| より大きい | 「＞」 | 「>」 | Call マーカーと区別注意 |
| より小さいまたは等しい | 「＜＝」 | 「<=」 | |
| より大きいまたは等しい | 「＞＝」 | 「>=」 | |

#### 括弧

| 種類 | 全角 | 半角 |
|------|------|------|
| 左括弧 | 「（」 | 「(」 |
| 右括弧 | 「）」 | 「)」 |

---

### 2.8 リテラル・文字列

#### 日本語文字列
```pest
日本語文字列 ::= "「" ~ content ~ "」"
例: 「こんにちは」
```

#### 英語文字列
```pest
英語文字列 ::= "\"" ~ content ~ "\""
例: "Hello"
```

**エスケープ**: バックスラッシュ `\` でエスケープ可能
- `\n` → 改行
- `\\` → バックスラッシュ
- `\"` → ダブルクォート

#### 数値リテラル
```pest
数値 ::= ["-" | "－"] ~ 数字+ ~ ["." | "．" ~ 数字+]?

例:
  10
  -5
  3.14
  -2.5
```

**数字**: ASCII 数字（0-9）または全角数字（０-９）

---

### 2.9 単語値の区切り文字

#### 区切り文字
```pest
区切り ::= WHITE_SPACE+
```

**セマンティクス**: 単語定義の値リストを区切る。1つ以上の連続した空白文字。

**定義の参照**: [2.1 空白（WHITE_SPACE 文字クラス）](#空白white_space-文字クラス)に定義されるWHITE_SPACE文字クラスを使用。

**例**:
```pasta
＠fruits：apple　banana　orange
＠numbers：1　2　3
＠items：value1  value2	value3
```

注：全角スペース「　」、半角スペース「 」、タブ「\t」など、いずれの空白文字でも区切り文字として機能します。

---

## 2.10 コメント

#### コメント行
```pest
コメント ::= "#" | "＃" ~ content ~ NEWLINE
```

**セマンティクス**: 行末までコメント（処理されない）

**例**:
```pasta
# これはコメント
＃全角シャープでもOK
```

---

## 3. 行とブロック構造

### 2.11.1 行（Line）の定義

Pasta は行指向文法です。各行は改行（NEWLINE）で終わり、行頭の文字（マーカー）により行の型が決定されます。

**行の構成**:
```pest
行 ::= [インデント] マーカー 内容 NEWLINE
または
行 ::= [インデント] 内容 NEWLINE  （属性行、発言行など）
```

### 2.11.2 行の種類

インデントの有無で、行の構造を二分類します。

#### インデント不要の行構造（行頭にインデントなし）

| 行種 | マーカー | 説明 | 例 |
|------|---------|------|-----|
| グローバルラベル | `＊` または `*` | グローバルブロックを開始 | `＊会話` |
| グローバル単語定義 | `＠` または `@` | ファイル全体で参照可能な単語定義 | `＠fruits：apple　banana` |
| Rune ブロック | ``` ``` または ```rune``` | グローバルラベルに属する複数行コード（インデント不要） | ` ```rune ... ``` ` |
| コメント | `#` または `＃` | コメント（処理されない） | `# これはコメント` |

#### インデントが必要な行構造（行頭にインデントあり）

| 行種 | マーカー | 説明 | 例 |
|------|---------|------|-----|
| ローカルラベル | `・` または `-` | グローバルラベル配下のローカルブロック開始 | `  ・選択肢1` |
| 属性定義 | `＆` または `&` | ラベルにメタデータを付与 | `  ＆author：Alice` |
| 発言行 | （マーカーなし） | キャラクター発言 | `  Alice：こんにちは` |
| Call | `＞` または `>` | ラベルを呼び出す | `  ＞ラベル名` |
| 変数代入 | `＄` または `$` | 変数を宣言・代入 | `  ＄my_var ： 10` |
| ローカル単語定義 | `＠` または `@` | 親ラベル内で参照可能な単語定義 | `  ＠fruits：apple　banana` |

注記: コメント行はインデントあり・なしの両方で許容されます（意味解釈は常に「コメント」）。

### 2.11.3 ブロック構造

Pasta スクリプトは階層的なブロック構造を持ちます。

#### グローバルブロック構造

```
グローバルブロック
  ├─ グローバル単語行（＠）*
  └─ グローバルラベルブロック（＊）+
```

**セマンティクス**:
- グローバル単語定義（0個以上）と グローバルラベルブロック（1個以上）で構成
- ファイルレベルのスコープを形成

#### グローバルラベルブロック構造

```
＊グローバル名
  ＆属性行 *
  [暗黙ローカル開始ブロック(__start__)]
  ・ローカルラベルブロック *
```

**構成要素**:
1. **グローバルラベル行**: `＊グローバル名`（宣言）
2. **属性行**: ０個以上の `＆key：value` （グローバルラベル全体のメタデータ）
3. **暗黙ローカル開始ブロック**: Rune ブロック、発言行、制御フロー行、変数代入行を格納可能（ローカルラベル宣言なし）
4. **ローカルブロック**: ０個以上の明示的ローカルラベルブロック（`・ローカルラベル`）

**暗黙ローカル開始ブロック（`__start__`）**:
- ローカルラベル名が `__start__` に相当する特別なブロック
- ローカルラベル宣言行は不要（暗黙的に開始）
- Call でグローバルラベルを呼び出す際に、`__start__` ブロックが実行される
- Rune ブロックはここに格納可能

#### ローカルブロック構造

```
・ローカル名
  [属性行 *]
  (変数代入行 | 会話行 | Call行)*
```

**構成要素**:
1. **ローカルラベル行**: `・ローカル名`（宣言）
2. **属性行**: ０個以上の `＆key：value` （ローカルラベル全体のメタデータ）
3. **コンテンツ行**: ０個以上の以下のいずれか
   - 変数代入行（`＄`）
   - アクション行（actor：action）
   - Call 行（`＞`）

**セマンティクス**:
- ローカルラベルの実行本体を構成
- Call 行は実行後に当ローカルブロック内で処理を継続

#### Rune ブロックの配置

Rune ブロックは暗黙ローカル開始ブロック（`__start__`）内に配置されます。

````pasta
＊グローバル名
  ```rune
  fn on_event() {
    for i in 0..10 {
      yield ctx.event("loop", i);
    }
  }
  ```
  Alice：こんにちは
````

**処理順序**:
- グローバルラベルが Call の対象になると、暗黙 `__start__` が実行される
- 暗黙 `__start__` 内の Rune ブロック（存在する場合）が最初に実行
- その後、同一ブロック内の発言行、Call 行が順に実行

**制約**:
- Rune ブロックはインデント不要（配置上は直前のグローバルラベル配下）
- **関数定義のみ許可**：Rune ブロック内には `fn ...` で始まる関数定義のみを記述可能。変数宣言（`let`）やトップレベルのステートメントは許可されません
- 複数の Rune ブロックが暗黙 `__start__` 内に存在する場合、上から順に関数が定義される
- パーサーは内部を解釈しません。**トランスパイラーが関数定義のみの正式なコード**として検証し、文法エラーまたは関数定義以外のコードが検出された場合、トランスパイラー層で報告されます

#### 例

**例1: 属性 + 暗黙ローカルスタート + Rune関数定義**
```
＊会話
  ＆author：Alice
  ```rune
  fn initialize() {
    ctx.flag("talked", true);
  }
  ```
  こんにちは
```

**例2: 属性 + ローカルラベルブロック**
```
＊選択肢
  ＆genre：choice
  ・選択肢1
    Alice：選択肢1を選びました
  ・選択肢2
    Alice：選択肢2を選びました
```

**例3: 暗黙スタート + 明示ローカルラベル**
```
＊複合シーン
  Alice：シーンが開始されました
  ・分岐A
    Bob：Aを選びました
  ・分岐B
    Bob：Bを選びました
```

### 2.11.4 インデント（Indentation）

インデントは行の属するレベルを示します。

**インデント規則**:
- インデントなし = グローバルレベル（グローバルラベル、グローバル単語定義など）
- インデントあり = 下層レベル（グローバルラベル直下のすべての行：ローカルラベル、属性行、発言行など）
- 例外: Rune ブロックはインデント不要だが、構造上は直前のグローバルラベルに属する

**重要**:
- インデント深さの判定は**不要**です
- パーサーは「行頭に空白があるか・ないか」のバイナリチェックのみで十分
- インデント深さを測定・比較・検証する必要はありません

**例**:
```
＊会話               ← インデントなし（グローバルレベル）
  ＆author：Alice    ← インデントあり（下層レベル）
  ・選択肢1         ← インデントあり（下層レベル）
  Alice：こんにちは ← インデントあり（下層レベル）

＠fruits：apple orange ← インデントなし（グローバルレベル）
```

---

## 4. Call の詳細仕様

### 4.1 Call ターゲットの形式

Call は以下の3パターンのターゲット形式をサポート：

#### パターン1: グローバルラベル参照
```
call_target ::= グローバルラベルマーカー ~ ラベル名
例: ＊会話
   *conversation
```

**セマンティクス**: 指定名で始まるグローバルラベルの `__start__` を呼び出す

#### パターン2: ローカルラベル参照
```
call_target ::= ラベル名
例: 選択肢1
   choice1
```

**セマンティクス**: 現在のグローバルラベル内の指定ローカルラベルを呼び出す

#### パターン3: 動的ターゲット
```
call_target ::= 変数マーカー ~ 変数名
例: ＄target_label
   $dynamic_choice
```

**セマンティクス**: 変数の値をラベル名として解決

#### 4.1.5 前方一致によるターゲット解決

Call/単語検索において、ターゲットの候補列挙は**前方一致**で行われます。

**例**:
以下のグローバルラベルがあるとき：
```
＊挨拶朝
＊挨拶昼
```

- `＞挨拶` では「挨拶朝」「挨拶昼」の両方が候補
- `＞挨拶朝` では「挨拶朝」のみが候補

**設計原則**: パーサーレベルではターゲット文字列を単に抽出するのみ。候補の列挙とランダム選択の詳細な挙動については、トランスパイラー・ランタイム層の実装に委ねられます。

---

### 4.2 フィルター（属性フィルター）

**構文**:
```pest
filter_list ::= ("＆" ~ key ~ 比較演算子 ~ value)+
現在: ＆key＝value
将来: ＆score＞50　＆level＜10　など比較演算子ベースに拡張予定
```

**例**:
```pasta
＞ラベル名＆author＝Alice＆genre＝comedy
＠単語名＆category＝food＆season＝summer
```

**セマンティクス**: ターゲット選択時に属性で絞り込み（将来予約）

**適用範囲**: Callだけでなく、会話文内の単語呼び出し（＠）でも同様に使用可能。基本的な記述ルールは共通。

**設計原則**: フィルターは比較・条件判定のため、コロンではなく比較演算子（＝、＞、＜など）を使用

**現在**: フィルター機能は将来用に宣言; 現在は無視

---

### 4.3 引数リスト

**構文**:
```pest
arg_list ::= "（" ~ argument* ~ "）"
argument ::= 名前付き引数
名前付き引数 ::= name ~ "：" ~ value
区切り文字 ::= 空白（"　" | "\t" | " "）
```

**例**:
```pasta
＠関数呼び出し（引数１：値１　引数２：値２）
＠calculate（x：10　y：20）
```

**実装状態**:
- ASTレベルでの解釈は対応
- トランスパイラー層以降の実装は順次対応予定

---

## 5. Sakura スクリプト仕様

### 5.1 概要
Sakura スクリプトは、会話テキスト内に埋め込まれる制御コマンド。バックスラッシュでエスケープされます。

### 5.2 エスケープ文字
```
エスケープ ::= "\"
```

**重要**: 厳密に半角バックスラッシュ（\）のみ。全角は不可。

### 5.3 Sakura コマンドの形式

**構文**:
```
sakura_command ::= "\" ~ identifier ~ bracket_content?
identifier ::= [a-zA-Z0-9_]+  /* 数字開始も許容 */
bracket_content ::= "[" ~ content ~ "]"
```

**説明**: バックスラッシュに続いて半角文字の変数識別子（数字で始まることも許容）、その後に角括弧`[]`で囲まれた要素が0個または1個

**例**:
```text
\s[0]          ← 識別子 s + 括弧あり
\w8            ← 識別子 w8 + 括弧なし
\n             ← 識別子 n + 括弧なし
\![raise]      ← 識別子 ! + 括弧あり（記号も識別子に含む）
\_w[50]        ← 識別子 _w + 括弧あり
```

### 5.4 文字種

**Sakura 文字**:
- 半角: `a-z`, `A-Z`
- 全角: `ａ-ｚ`, `Ａ-Ｚ`

**Sakura 数字**:
- 半角: `0-9`
- 全角: `０-９`

**括弧**:
- 半角: `[`, `]`
- 全角: `［`, `］`

### 5.5 使用例

```
Alice：こんにちは\w8。\n返事してください。
Bob：\![happy]了解しました。
```

---

## 6. リテラル型

### 6.1 概要
変数、関数引数、属性値で使用可能な型。

### 6.2 型変換ルール

リテラル値は以下の優先順位で型変換される：

1. **bool型**: `true` / `false` → bool
2. **String型（引用符あり）**: `「...」`で囲まれている → String
3. **f64型**: 小数点が含まれる数値 → f64
4. **i64型**: 小数点が無い数値 → i64
5. **String型（その他）**: 上記以外 → String

**空白の扱い**:
- 引用符`「」`で囲まれている場合: 空白も文字列の一部
- 引用符なしの場合: 空白は区切り文字として認識され、文字列に含まれない

**例**:
```
true           → bool
false          → bool
「こんにちは」   → String (空白含む)
Hello          → String
3.14           → f64
42             → i64
hello world    → String "hello" と String "world" (2つの値)
「hello world」 → String "hello world" (1つの値)
```

---

## 7. アクション行（Action Line）

### 7.1 基本構文
```
actor ： action [NEWLINE continuation_line*]
```

### 7.2 Actor（アクター）
**形式**: コロン前のテキスト（任意の非改行文字）

**説明**: アクター名を指定。会話テキストだけでなく、Sakuraスクリプトによる表情指定など、アクション全般を制御。

**例**:
```
Alice：...
キャラクターA：...
```

### 7.3 Action（アクション）

アクション内容は通常テキストと**インライン要素**の組み合わせで構成される。

#### インライン要素

アクション行内に埋め込み可能な要素：

| 要素 | 構文 | 説明 |
|------|------|------|
| 通常テキスト | `こんにちは` | 任意の文字列 |
| 単語参照 | `＠word_name` | 登録済み単語からランダム選択 |
| 単語参照（動的） | `＠＄var_name` | 変数値を単語名として参照 |
| 変数参照 | `＄var_name` | 変数値を展開 |
| 関数呼び出し | `＠func_name()` | Rune関数を呼び出し |
| 関数呼び出し（引数） | `＠func（x：10）` | 名前付き引数で呼び出し |
| Sakura スクリプト | `\n`, `\w8`, `\s[0]` | 表情・タイミング制御 |

**例**:
```
Alice：こんにちは、＄player_nameさん！\w8
Bob：今日の天気は＠weather_wordsですね\n
Carol：＠greet（time：morning）
```

**重要**: 変数宣言（`＄var：value`）は専用の変数宣言行で行う。アクション内では変数参照（`＄var`）のみ可能。

#### インライン要素の区切り文字

**目的**: アクション内のインライン要素（＠、＄）の終端と区切りの扱いを定義する。

##### 空白による区切り

インライン要素の識別子認識において、空白は**トークン区切り**として利用できる。

```
＠挨拶　みんな！         → 単語参照「挨拶」+ 通常テキスト「みんな！」
＠挨拶　　　　みんな！   → 同じ出力（空白数は無関係）
＄name　さん            → 変数参照「name」+ 通常テキスト「さん」
```

**ルール**:
- 空白はトークン区切りとして認識され、空白数に関わらず1トークンとして扱う
- トークン区切りの空白は出力に含まれない
- 空白がない場合は最長一致で識別子を切り出す（識別子に含まれない文字が現れるまで）

##### 空白なしの場合（最長一致）

空白で区切られない場合、識別子（前述の「識別子（Identifier）」定義に従う）として認識できない文字が現れるまでを**最長一致**で切り出す。

```
＠挨拶、みんな！   → インライン単語「＠挨拶」 + 通常テキスト「、みんな！」
＄name!          → 変数参照「＄name」 + 通常テキスト「!」
＠weather_wordsですね → 最長一致により識別子「＠weather_wordsですね」として扱われる（意図しない吸収の例）
※ 正しく分割したい場合は区切りを入れる：
  - 空白で分割: 「＠weather_words　ですね」
  - 非識別子記号で分割: 「＠weather_words、ですね」（読点「、」は識別子に含まれない）
```

**備考**: インライン要素の一覧は 7.3 を参照。行継続のルールは 7.4 を参照。

---

### 7.4 行継続
複数行にわたるアクション：

```pasta
Alice：長い台詞は
  複数行に分けて
  記述できます
```

**構文**:
```pest
continuation_line ::= INDENT ~ !(statement_marker) ~ content
statement_marker ::= "＄" | "＠" | "＞" | "＆" | "＊" | "・"
```

**セマンティクス**: インデント付き行は前行の続きとして連結

**制約**: 継続行は行マーカー（＄＠＞＆＊・）で始めてはならない。これらで始まる場合は別の行種として解釈される。

---

## 7.5 改行

### 7.5.1 概要
アクション行のテキスト内における改行の取り扱いを定義する。

### 7.5.2 正規の改行（Sakura）
- Sakura スクリプトの `\n` は常に「改行」として解釈する（5.3 参照）。
- 出力時に改行文字として挿入される。

### 7.5.3 糖衣構文（継続行内の空行）
- 7.4 で定義される「行継続」領域において、インデントのみで内容のない行（空白だけ、または純粋な空行）を「改行」として解釈する。
- 連続する空行は、その数に応じた連続改行として出力される。

**文法追加**:
```pest
continuation_line_newline ::= INDENT ~ NEWLINE
```

**セマンティクス**:
- `continuation_line_newline` は 1 改行として動作する。
- 空白（INDENT）は出力には含まれない（2.1 の原則継承）。

**例**:
```pasta
Alice：１行目。
  １行目の続き。
  
  ２行目。
```
→ 出力は「１行目。\n２行目。」（空行が 1 改行として解釈）

### 7.5.4 非継続領域の空行
- 継続行以外（インデントなしの空行、ラベル直後の空行など）は、改行としては解釈しない。レイアウト目的の空白として無視する。

**備考**:
- 詳細な整形やタイミング制御は Sakura スクリプトのコマンド（例：`\w`）を推奨。
- 改行仕様は 7.4（行継続）と併せて適用される。

---

## 8. 属性（Attribute）

### 8.1 構文
```
属性行 ::= インデント ~ "＆" ~ key ~ "：" ~ value ~ NEWLINE
```

### 8.2 配置ルール

属性行は**ラベル定義の直後にのみ配置可能**：

- **グローバルラベルの直後**: グローバルラベルに属性を付与
- **ローカルラベルの直後**: ローカルラベルに属性を付与
- **複数配置可能**: 同じラベルに複数の属性を連続して記述

**例**:
```
＊グローバルラベル
  ＆author：Alice
  ＆genre：comedy
  ・ローカルラベル
    ＆priority：high
    ＆difficulty：3
    Alice：台詞内容
```

**セマンティクス**: 直前のラベルにメタデータを付与

**制約**: 属性行はラベル行の直後以外には配置できない。アクション行や変数代入行の後に属性行を置くことは文法エラー。

### 8.3 ファイルレベル属性（将来予約）

**構文**:
```
file_level_attribute ::= "＆" ~ key ~ "：" ~ value ~ NEWLINE
```

**配置ルール**: ファイル冒頭、すべてのグローバルラベル宣言より前に、インデントなしで配置

**セマンティクス**: ファイルレベル属性は、当該ファイル内のすべてのグローバルラベルに自動的に継承される

**例**:
```
＆警報レベル：レッド

＊会話１
  ＆温度：暑い

＊会話２
  ＆温度：寒い
```

**結果**:
- グローバルラベル「会話１」: `＆警報レベル：レッド　＆温度：暑い`
- グローバルラベル「会話２」: `＆警報レベル：レッド　＆温度：寒い`

**実装状態**: 将来予約機能。現在は構文のみ許容し、セマンティクス実装は順次対応予定。

---

## 9. 変数・スコープ

### 9.1 変数型

#### グローバル変数
```
宣言: ＄＊var_name ： value
参照: ＄＊var_name
```

**スコープ**: ファイル全体

#### ローカル変数
```
宣言: ＄var_name ： value
参照: ＄var_name
```

**スコープ**: 親ローカルラベル内

### 9.2 変数代入の制約

**重要**: 変数代入では**式を使用できません**（1.3参照）。代入可能な値は以下のみです：

#### 許可される値の型

| 値の種類 | 構文例 | 説明 |
|---------|--------|------|
| リテラル値 | `＄score ： 100` | 数値、文字列リテラル |
| 単語参照 | `＄value ： ＠word_name` | 登録済み単語の参照 |
| 変数参照 | `＄new_var ： ＄old_var` | 他の変数の値をコピー |
| 関数呼び出し | `＄result ： ＠calculate()` | Rune 関数の戻り値 |
| 関数呼び出し（引数付き） | `＄sum ： ＠add（x：10　y：20）` | 名前付き引数で呼び出し |

#### 許可されない構文例
```pasta
# ❌ 式は使用できない
＄result ： 10 + 20
＄flag ： ＄x > 5
＄value ： (＄a + ＄b) * 2
```

#### 代替方法：Rune 関数を使用
```pasta
```rune
fn add(ctx, x, y) {
    x + y
}

fn is_greater(ctx, x, threshold) {
    x > threshold
}
```

＄result ： ＀add（x：10　y：20）
＄flag ： ＠is_greater（x：＠score　threshold：5）
```

---

## 10. 単語定義（Word Definition）

### 10.1 グローバル単語定義
```
＠word_name ： value1　value2　...
```

**セマンティクス**: ファイル全体で参照可能な辞書エントリ

### 10.2 ローカル単語定義
```
  ＠word_name ： value1　value2　...
```

**セマンティクス**: 親ラベル内で参照可能

### 10.3 単語参照

**構文**:
```
会話行内: ＠word_name
Rune コード内: pasta::word_lookup(ctx, "word_name")
```

**スコープ解決ルール**:
- 単語参照にスコープ修飾子は不要
- `＠word_name` で、現在のグローバルラベルスコープ内のローカル単語 + グローバル単語の全候補から検索
- 異なるグローバルラベルスコープでは、同じ単語名でも異なる結果を返す可能性がある（ローカル単語が異なるため）

**動的単語参照**:
- `＠＄var_name` 形式で、変数値を単語名として間接参照可能
- セマンティクス：`＄var_name` で取得した値を単語名として `＠単語検索` を実行
- **実装状態**：文法定義済み、実装は将来予定

**制限（v1）**:
- 多段階参照（例：`＠＠word`、`＠＠＠word`）は未採用・非対応。
- 必要な場合は関数呼び出し（例：`＠resolve(word：... )`）で代替可能。

**制限（v1）**:
- 多段階参照（例：`＠＠word`、`＠＠＠word`）は未採用・非対応。
- 必要な場合は関数呼び出し（例：`＠resolve(word：... )`）で代替可能。

---

## 11. 未確定事項・検討中の仕様

 
### 11.2 インライン単語参照の多段階解決（将来仕様）
- 現時点では v1 では未採用・非対応。
- 複雑性が高いため、必要な場合は関数呼び出しで代替可能。
- 将来仕様として再検討候補に残す。

### 11.2 インライン単語参照の多段階解決（将来仕様）
- 現時点では v1 では未採用・非対応。
- 複雑性が高いため、必要な場合は関数呼び出しで代替可能。
- 将来仕様として再検討候補に残す。

### 11.3 チェーントーク
- [ ] Call 時に別トークへ移行する機能は実装済みか？（Jump は仕様から廃止済み）
- [ ] 「＠chain」「＞chain」のような形式をサポートするか？
- **確認済みか**: 要件定義作成時に調査予定

### 11.4 ローカルラベルのパラメータ
```
  ・choice1 ＄$param1 ＄$param2
```
- [ ] パラメータ渡しの正確な形式と型チェック
- [ ] デフォルト値のサポート有無

### 11.5 フィルター機能の詳細
- [ ] 複数フィルター OR / AND 結合方法
- [ ] 将来の拡張予約だが、初期版での対応範囲

---

## 12. 参考資料

- `src/parser/pasta.pest` - PEG 文法定義
- `GRAMMAR.md` - ユーザー向けドキュメント（改訂予定）
- `pest-grammar-alignment-analysis.md` - 現状分析資料

---

**更新履歴**:

| 日付 | 版 | 変更 |
|------|-----|------|
| 2025-12-18 | 1.0 | 初版作成（ひな形） |

