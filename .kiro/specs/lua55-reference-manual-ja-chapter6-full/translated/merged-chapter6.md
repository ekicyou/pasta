# 6 – 標準ライブラリ

標準Luaライブラリは、C APIを通じてCで実装された便利な関数を提供します。これらの関数の一部は言語に必須のサービスを提供します（例：[`type`](#type-v) と [`getmetatable`](#getmetatable-object)）。その他は外部サービスへのアクセスを提供します（例：I/O）。また、Lua自体で実装できるものもありますが、さまざまな理由からCでの実装が望ましいものです（例：[`table.sort`](#tablesort-list--comp)）。

すべてのライブラリは公式C APIを通じて実装され、別々のCモジュールとして提供されます。特に明記されない限り、これらのライブラリ関数は引数の数を期待されるパラメータに調整しません。例えば、`foo(arg)` として文書化された関数は、引数なしで呼び出すべきではありません。

表記 **fail** は、ある種の失敗を表す偽の値を意味します。（現在、**fail** は **nil** と等しいですが、将来のバージョンで変わる可能性があります。推奨事項は、`(status == nil)` の代わりに `(not status)` でこれらの関数の成功を常にテストすることです。）

現在、Luaには以下の標準ライブラリがあります：

- 基本ライブラリ（[§6.2](#62--基本関数)）
- コルーチンライブラリ（[§6.3](#63--コルーチン操作)）
- パッケージライブラリ（[§6.4](#64--モジュール)）
- 文字列操作（[§6.5](#65--文字列操作)）
- 基本的なUTF-8サポート（[§6.6](#66--utf-8サポート)）
- テーブル操作（[§6.7](#67--テーブル操作)）
- 数学関数（[§6.8](#68--数学関数)）（sin、log など）
- 入出力（[§6.9](#69--入出力機能)）
- オペレーティングシステム機能（[§6.10](#610--オペレーティングシステム機能)）
- デバッグ機能（[§6.11](#611--デバッグライブラリ)）

基本ライブラリとパッケージライブラリを除いて、各ライブラリはすべての関数をグローバルテーブルのフィールドとして、またはそのオブジェクトのメソッドとして提供します。
## 6.1 – Cコードでのライブラリロード

Cホストプログラムは、スクリプトで標準ライブラリを使用したい場合、明示的にそれらをステートにロードする必要があります。そのために、ホストプログラムは関数 [`luaL_openlibs`](#lual_openlibs) を呼び出すことができます。あるいは、[`luaL_openselectedlibs`](#lual_openselectedlibs) を使用して、どのライブラリを開くかを選択することもできます。両方の関数はヘッダファイル `lualib.h` で宣言されています。

スタンドアロンインタプリタ `lua`（[§7](07-standalone.md) 参照）は、すべての標準ライブラリを既に開いています。

---

### luaL_openlibs

```c
[-0, +0, e]
void luaL_openlibs (lua_State *L);
```

指定されたステートにすべての標準Luaライブラリを開きます。

---

### luaL_openselectedlibs

```c
[-0, +0, e]
void luaL_openselectedlibs (lua_State *L, int load, int preload);
```

選択された標準ライブラリをステート `L` に開く（ロードする）およびプリロードします。（*プリロード*とは、ライブラリローダーをテーブル [`package.preload`](#pdf-packagepreload) に追加することを意味し、これによりプログラムは後でそのライブラリを require できるようになります。[`require`](#pdf-require) 自体は *package* ライブラリによって提供されることに注意してください。プログラムがそのライブラリをロードしない場合、何も require することができません。）

整数 `load` はどのライブラリをロードするかを選択します。整数 `preload` は、ロードされなかったものの中からどのライブラリをプリロードするかを選択します。両方とも、以下の定数のビット単位ORで形成されるマスクです：

| 定数 | 説明 |
|------|------|
| **`LUA_GLIBK`** | 基本ライブラリ |
| **`LUA_LOADLIBK`** | パッケージライブラリ |
| **`LUA_COLIBK`** | コルーチンライブラリ |
| **`LUA_STRLIBK`** | 文字列ライブラリ |
| **`LUA_UTF8LIBK`** | UTF-8ライブラリ |
| **`LUA_TABLIBK`** | テーブルライブラリ |
| **`LUA_MATHLIBK`** | 数学ライブラリ |
| **`LUA_IOLIBK`** | I/Oライブラリ |
| **`LUA_OSLIBK`** | オペレーティングシステムライブラリ |
| **`LUA_DBLIBK`** | デバッグライブラリ |
## 6.2 – 基本関数（パートA: assert-error）

基本ライブラリはLuaにコア関数を提供します。アプリケーションにこのライブラリを含めない場合は、その機能の一部について実装を提供する必要があるかどうかを慎重に確認してください。

---

### assert (v [, message])

引数 `v` の値が偽（すなわち **nil** または **false**）の場合、エラーを発生させます。そうでなければ、すべての引数を返します。エラーの場合、`message` がエラーオブジェクトになります。省略された場合、デフォルトは "`assertion failed!`" です。

---

### collectgarbage ([opt [, arg]])

この関数はガベージコレクタへの汎用インターフェースです。最初の引数 `opt` に応じて異なる機能を実行します：

- **`"collect"`**: 完全なガベージコレクションサイクルを実行します。これがデフォルトオプションです。

- **`"stop"`**: ガベージコレクタの自動実行を停止します。コレクタは再起動の呼び出しがあるまで、明示的に呼び出されたときのみ実行されます。

- **`"restart"`**: ガベージコレクタの自動実行を再開します。

- **`"count"`**: Luaが使用中の総メモリをキロバイト単位で返します。値には小数部があり、1024を掛けるとLuaが使用している正確なバイト数になります。

- **`"step"`**: ガベージコレクションのステップを実行します。このオプションには追加の引数として、ステップサイズを示す整数を続けることができます。

  サイズが正の `n` の場合、コレクタは `n` バイトの新規メモリが割り当てられたかのように動作します。サイズがゼロの場合、コレクタは基本ステップを実行します。インクリメンタルモードでは、基本ステップは現在のステップサイズに対応します。ジェネレーショナルモードでは、基本ステップは完全なマイナーコレクションを実行するか、コレクタがスケジュールしていればインクリメンタルステップを実行します。

  インクリメンタルモードでは、ステップがコレクションサイクルを終了した場合、関数は **true** を返します。ジェネレーショナルモードでは、ステップがメジャーコレクションを終了した場合、関数は **true** を返します。

- **`"isrunning"`**: コレクタが実行中（つまり停止していない）かどうかを示すブール値を返します。

- **`"incremental"`**: コレクタモードをインクリメンタルに変更し、以前のモードを返します。

- **`"generational"`**: コレクタモードをジェネレーショナルに変更し、以前のモードを返します。

- **`"param"`**: コレクタのパラメータの値を変更および/または取得します。このオプションには1つまたは2つの追加引数が必要です：変更または取得するパラメータの名前（文字列）と、そのパラメータのオプションの新しい値（範囲 *[0,100000]* の整数）。最初の引数は以下のいずれかの値でなければなりません：

  | パラメータ名 | 説明 |
  |-------------|------|
  | `"minormul"` | マイナー乗数 |
  | `"majorminor"` | メジャー-マイナー乗数 |
  | `"minormajor"` | マイナー-メジャー乗数 |
  | `"pause"` | ガベージコレクタの休止値 |
  | `"stepmul"` | ステップ乗数 |
  | `"stepsize"` | ステップサイズ |

  呼び出しは常にパラメータの以前の値を返します。呼び出しが新しい値を与えない場合、値は変更されません。

  Luaはこれらの値を圧縮形式で保存するため、以前の値として返される値は、最後に設定された値と正確に一致しない場合があります。

ガベージコレクションとこれらのオプションの一部についての詳細は、[§2.5](02-basic-concepts.md#25--ガベージコレクション) を参照してください。

この関数はファイナライザから呼び出すべきではありません。

---

### dofile ([filename])

指定されたファイルを開き、その内容をLuaチャンクとして実行し、チャンクが返すすべての値を返します。引数なしで呼び出された場合、`dofile` は標準入力（`stdin`）の内容を実行します。エラーの場合、`dofile` はエラーを呼び出し元に伝播します。（つまり、`dofile` は保護モードで実行されません。）

---

### error (message [, level])

`message` をエラーオブジェクトとしてエラーを発生させます（[§2.3](02-basic-concepts.md#23--エラー処理) 参照）。この関数は決してリターンしません。

通常、`error` はメッセージが文字列の場合、メッセージの先頭にエラー位置に関する情報を追加します。`level` 引数はエラー位置の取得方法を指定します。レベル1（デフォルト）では、エラー位置は `error` 関数が呼び出された場所です。レベル2では、`error` を呼び出した関数が呼び出された場所を指します。以下同様です。レベル0を渡すと、エラー位置情報のメッセージへの追加を回避します。
## 6.2 – 基本関数（パートB: _G-loadfile）

---

### _G

グローバル環境を保持するグローバル変数（関数ではありません）（[§2.2](02-basic-concepts.md#22--環境とグローバル環境) 参照）。Lua自体はこの変数を使用しません。この値を変更しても環境に影響せず、その逆も同様です。

---

### getmetatable (object)

`object` がメタテーブルを持たない場合、**nil** を返します。そうでなければ、オブジェクトのメタテーブルに `__metatable` フィールドがある場合、関連付けられた値を返します。そうでなければ、与えられたオブジェクトのメタテーブルを返します。

---

### ipairs (t)

以下の構文が

```lua
for i,v in ipairs(t) do body end
```

キー・値ペア (`1,t[1]`), (`2,t[2]`), ... を最初の存在しないインデックスまで反復するように、3つの値（イテレータ関数、値 `t`、0）を返します。

---

### load (chunk [, chunkname [, mode [, env]]])

チャンクをロードします。

`chunk` が文字列の場合、チャンクはこの文字列です。`chunk` が関数の場合、`load` はチャンクの断片を取得するために繰り返し呼び出します。`chunk` への各呼び出しは、以前の結果と連結する文字列を返す必要があります。空文字列、**nil**、または値なしのリターンはチャンクの終了を示します。

構文エラーがなければ、`load` はコンパイルされたチャンクを関数として返します。そうでなければ、**fail** とエラーメッセージを返します。

メインチャンクをロードする場合、結果の関数は常に正確に1つのアップバリュー、`_ENV` 変数を持ちます（[§2.2](02-basic-concepts.md#22--環境とグローバル環境) 参照）。しかし、関数から作成されたバイナリチャンクをロードする場合（[`string.dump`](#pdf-stringdump) 参照）、結果の関数は任意の数のアップバリューを持つことができ、最初のアップバリューが `_ENV` 変数である保証はありません。（非メイン関数は `_ENV` アップバリューを持たないこともあります。）

いずれにせよ、結果の関数がアップバリューを持つ場合、そのパラメータが指定されていれば最初のアップバリューは `env` の値に設定され、そうでなければグローバル環境の値に設定されます。他のアップバリューは **nil** で初期化されます。すべてのアップバリューはフレッシュであり、他の関数と共有されません。

`chunkname` はエラーメッセージとデバッグ情報のチャンク名として使用されます（[§4.7](04-the-application-program-interface.md#47--デバッグインターフェース) 参照）。省略された場合、`chunk` が文字列ならば `chunk` がデフォルトになり、そうでなければ "`=(load)`" がデフォルトになります。

文字列 `mode` はチャンクがテキストかバイナリ（つまりプリコンパイルされたチャンク）かを制御します。"`b`"（バイナリチャンクのみ）、"`t`"（テキストチャンクのみ）、または "`bt`"（バイナリとテキストの両方）のいずれかです。デフォルトは "`bt`" です。

Luaはバイナリチャンクの整合性をチェックしません。悪意を持って作成されたバイナリチャンクはインタプリタをクラッシュさせる可能性があります。`mode` パラメータを使用してバイナリチャンクのロードを防ぐことができます。

---

### loadfile ([filename [, mode [, env]]])

[`load`](#load-chunk--chunkname--mode--env) に似ていますが、チャンクをファイル `filename` から取得します。ファイル名が指定されない場合は標準入力から取得します。
## 6.2 – 基本関数（パートC: next-rawset）

---

### next (table [, index])

プログラムがテーブルのすべてのフィールドを走査できるようにします。最初の引数はテーブルで、2番目の引数はこのテーブル内のインデックスです。`next` の呼び出しは、テーブルの次のインデックスとその関連付けられた値を返します。2番目の引数として **nil** で呼び出された場合、`next` は初期インデックスとその関連付けられた値を返します。最後のインデックスで呼び出された場合、または空のテーブルで **nil** で呼び出された場合、`next` は **nil** を返します。2番目の引数が省略された場合、**nil** として解釈されます。特に、`next(t)` を使用してテーブルが空かどうかをチェックできます。

インデックスが列挙される順序は、*数値インデックスであっても*指定されていません。（テーブルを数値順に走査するには、数値 **for** を使用してください。）

走査中にテーブルの存在しないフィールドに値を代入すべきではありません。ただし、既存のフィールドを変更することはできます。特に、既存のフィールドを nil に設定することができます。

---

### pairs (t)

`t` がメタメソッド `__pairs` を持つ場合、`t` を引数として呼び出し、呼び出しからの最初の4つの結果を返します。

そうでなければ、[`next`](#next-table--index) 関数、テーブル `t`、さらに2つの **nil** 値を返し、以下の構文が

```lua
for k,v in pairs(t) do body end
```

テーブル `t` のすべてのキー・値ペアを反復するようにします。

走査中にテーブルを変更する際の注意事項については、関数 [`next`](#next-table--index) を参照してください。

---

### pcall (f [, arg1, ···])

与えられた引数で関数 `f` を*保護モード*で呼び出します。これは、`f` 内のエラーが伝播されないことを意味します。代わりに、`pcall` はエラーをキャッチしてステータスコードを返します。最初の結果はステータスコード（ブール値）で、呼び出しがエラーなく成功した場合は **true** です。その場合、`pcall` はこの最初の結果の後に呼び出しからのすべての結果も返します。エラーの場合、`pcall` は **false** とエラーオブジェクトを返します。`pcall` によってキャッチされたエラーはメッセージハンドラを呼び出さないことに注意してください。

---

### print (···)

任意の数の引数を受け取り、[`tostring`](#tostring-v) と同じルールに従って各引数を文字列に変換し、その値を `stdout` に出力します。

関数 `print` はフォーマットされた出力を目的としておらず、例えばデバッグ用に値を素早く表示する方法としてのみ意図されています。出力を完全に制御するには、[`string.format`](#pdf-stringformat) と [`io.write`](#pdf-iowrite) を使用してください。

---

### rawequal (v1, v2)

`__eq` メタメソッドを呼び出さずに、`v1` が `v2` と等しいかどうかをチェックします。ブール値を返します。

---

### rawget (table, index)

`__index` メタ値を使用せずに、`table[index]` の実際の値を取得します。`table` はテーブルでなければなりません。`index` は任意の値です。

---

### rawlen (v)

`__len` メタメソッドを呼び出さずに、オブジェクト `v` の長さを返します。`v` はテーブルまたは文字列でなければなりません。整数を返します。

---

### rawset (table, index, value)

`__newindex` メタ値を使用せずに、`table[index]` の実際の値を `value` に設定します。`table` はテーブルでなければならず、`index` は **nil** と NaN 以外の任意の値で、`value` は任意のLua値です。

この関数は `table` を返します。
## 6.2 – 基本関数（パートD: select-type）

---

### select (index, ···)

`index` が数値の場合、引数番号 `index` より後のすべての引数を返します。負の数は末尾からインデックスします（-1 は最後の引数）。そうでなければ、`index` は文字列 `"#"` でなければならず、`select` は受け取った追加引数の総数を返します。

---

### setmetatable (table, metatable)

与えられたテーブルにメタテーブルを設定します。`metatable` が **nil** の場合、与えられたテーブルのメタテーブルを削除します。元のメタテーブルに `__metatable` フィールドがある場合、エラーを発生させます。

この関数は `table` を返します。

Luaコードから他の型のメタテーブルを変更するには、デバッグライブラリ（[§6.11](#611--デバッグライブラリ)）を使用する必要があります。

---

### tonumber (e [, base])

`base` なしで呼び出された場合、`tonumber` は引数を数値に変換しようとします。引数が既に数値であるか、数値に変換可能な文字列である場合、`tonumber` はこの数値を返します。そうでなければ、**fail** を返します。

文字列の変換は、Luaの字句規則（[§3.1](03-the-language.md#31--字句規則) 参照）に従って、整数または浮動小数点数になります。文字列は先頭と末尾にスペースと符号を持つことができます。

`base` で呼び出された場合、`e` はその基数での整数数値として解釈される文字列でなければなりません。基数は2から36までの任意の整数です。10を超える基数では、文字 '`A`'（大文字または小文字）は 10 を表し、'`B`' は 11 を表し、以下同様に '`Z`' が 35 を表します。文字列 `e` が与えられた基数での有効な数値でない場合、関数は **fail** を返します。

---

### tostring (v)

任意の型の値を受け取り、人間が読める形式の文字列に変換します。

`v` のメタテーブルに `__tostring` フィールドがある場合、`tostring` は `v` を引数として対応する値を呼び出し、呼び出しの結果をその結果として使用します。そうでなければ、`v` のメタテーブルに文字列値を持つ `__name` フィールドがある場合、`tostring` はその文字列を最終結果に使用することがあります。

数値の変換方法を完全に制御するには、[`string.format`](#pdf-stringformat) を使用してください。

---

### type (v)

唯一の引数の型を文字列としてエンコードして返します。この関数の可能な結果は：
- `"nil"`（文字列であり、値 **nil** ではありません）
- `"number"`
- `"string"`
- `"boolean"`
- `"table"`
- `"function"`
- `"thread"`
- `"userdata"`
## 6.2 – 基本関数（パートE: _VERSION-xpcall）

---

### _VERSION

実行中のLuaバージョンを含む文字列を保持するグローバル変数（関数ではありません）。この変数の現在の値は "`Lua 5.5`" です。

---

### warn (msg1, ···)

すべての引数（文字列であるべき）を連結したメッセージで警告を発します。

慣例により、'`@`' で始まる1つの部分からなるメッセージは*制御メッセージ*を意図しており、これは警告システム自体へのメッセージです。特に、Luaの標準警告関数は制御メッセージ "`@off`"（警告の発行を停止）と "`@on`"（警告の発行を（再）開始）を認識します。不明な制御メッセージは無視されます。

---

### xpcall (f, msgh [, arg1, ···])

この関数は [`pcall`](#pcall-f--arg1-) に似ていますが、新しいメッセージハンドラ `msgh` を設定する点が異なります。
## 6.3 – コルーチン操作

このライブラリはコルーチンを操作するための操作を構成し、テーブル `coroutine` の中にあります。コルーチンの一般的な説明については [§2.6](02-basic-concepts.md#26--コルーチン) を参照してください。

---

### coroutine.close ([co])

コルーチン `co` を閉じます。つまり、保留中のすべての to-be-closed 変数を閉じ、コルーチンを dead 状態にします。`co` のデフォルトは実行中のコルーチンです。

与えられたコルーチンは dead、suspended、または実行中のコルーチンでなければなりません。実行中のコルーチンの場合、この関数はリターンしません。代わりに、コルーチンを（再）開始した resume がリターンします。

他のコルーチンの場合、エラーが発生した場合（コルーチンを停止させた元のエラー、またはクローズメソッドでのエラー）、この関数は **false** とエラーオブジェクトを返します。そうでなければ **true** を返します。

---

### coroutine.create (f)

ボディ `f` を持つ新しいコルーチンを作成します。`f` は関数でなければなりません。この新しいコルーチン、型 `"thread"` を持つオブジェクトを返します。

---

### coroutine.isyieldable ([co])

コルーチン `co` が yield できる場合 **true** を返します。`co` のデフォルトは実行中のコルーチンです。

コルーチンは、メインスレッドではなく、yield 不可能な C 関数の中にない場合に yield 可能です。

---

### coroutine.resume (co [, val1, ···])

コルーチン `co` の実行を開始または継続します。コルーチンを最初に resume するとき、そのボディの実行を開始します。値 `val1`, ... はボディ関数への引数として渡されます。コルーチンが yield している場合、`resume` はそれを再開します。値 `val1`, ... は yield からの結果として渡されます。

コルーチンがエラーなく実行された場合、`resume` は **true** と、`yield` に渡された値（コルーチンが yield したとき）またはボディ関数によって返された値（コルーチンが終了したとき）を返します。エラーがある場合、`resume` は **false** とエラーメッセージを返します。

---

### coroutine.running ()

実行中のコルーチンとブール値を返します。実行中のコルーチンがメインの場合 **true** です。

---

### coroutine.status (co)

コルーチン `co` のステータスを文字列として返します：

| ステータス | 説明 |
|-----------|------|
| `"running"` | コルーチンが実行中（つまり、`status` を呼び出したもの） |
| `"suspended"` | コルーチンが `yield` の呼び出しで中断中、またはまだ実行を開始していない |
| `"normal"` | コルーチンはアクティブだが実行中ではない（つまり、別のコルーチンを resume した） |
| `"dead"` | コルーチンがボディ関数を終了した、またはエラーで停止した |

---

### coroutine.wrap (f)

ボディ `f` を持つ新しいコルーチンを作成します。`f` は関数でなければなりません。呼び出されるたびにコルーチンを resume する関数を返します。この関数に渡された引数は `resume` への追加引数として動作します。関数は `resume` によって返される値と同じ値を返しますが、最初のブール値は除きます。エラーの場合、関数はコルーチンを閉じてエラーを伝播します。

---

### coroutine.yield (···)

呼び出し側コルーチンの実行を中断します。`yield` への引数は `resume` への追加結果として渡されます。
## 6.4 – モジュール（パートA: require-package.loadlib）

パッケージライブラリはLuaでモジュールをロードするための基本機能を提供します。グローバル環境に直接1つの関数をエクスポートします：[`require`](#require-modname)。それ以外はすべてテーブル `package` にエクスポートされます。

---

### require (modname)

与えられたモジュールをロードします。関数は最初に [`package.loaded`](#packageloaded) テーブルを調べて、`modname` が既にロードされているかどうかを判断します。ロードされている場合、`require` は `package.loaded[modname]` に格納されている値を返します。（この場合に2番目の結果がないことは、この呼び出しがモジュールをロードする必要がなかったことを示します。）そうでなければ、モジュールの*ローダー*を見つけようとします。

ローダーを見つけるために、`require` はテーブル [`package.searchers`](#packagesearchers) によってガイドされます。このテーブルの各項目は、特定の方法でモジュールを検索する検索関数です。このテーブルを変更することで、`require` がモジュールを探す方法を変更できます。以下の説明は [`package.searchers`](#packagesearchers) のデフォルト設定に基づいています。

最初に `require` は `package.preload[modname]` をクエリします。値がある場合、この値（関数でなければならない）がローダーです。そうでなければ、`require` は [`package.path`](#packagepath) に格納されているパスを使用してLuaローダーを検索します。それも失敗した場合、[`package.cpath`](#packagecpath) に格納されているパスを使用してCローダーを検索します。それも失敗した場合、*all-in-one* ローダーを試みます（[`package.searchers`](#packagesearchers) 参照）。

ローダーが見つかると、`require` は2つの引数でローダーを呼び出します：`modname` と追加の値、*ローダーデータ*で、これもサーチャーによって返されます。ローダーデータはモジュールにとって有用な任意の値です。デフォルトのサーチャーでは、ローダーがどこで見つかったかを示します。（例えば、ローダーがファイルから来た場合、この追加の値はファイルパスです。）ローダーが非 nil 値を返した場合、`require` は返された値を `package.loaded[modname]` に割り当てます。ローダーが非 nil 値を返さず、`package.loaded[modname]` に値を割り当てていない場合、`require` はこのエントリに **true** を割り当てます。いずれの場合も、`require` は `package.loaded[modname]` の最終値を返します。その値に加えて、`require` はサーチャーによって返されたローダーデータを2番目の結果として返し、これは `require` がモジュールをどのように見つけたかを示します。

モジュールのロードまたは実行でエラーがある場合、またはモジュールのローダーが見つからない場合、`require` はエラーを発生させます。

---

### package.config

パッケージのコンパイル時設定を記述する文字列。この文字列は一連の行です：

| 行 | 説明 | デフォルト |
|----|------|-----------|
| 1行目 | ディレクトリ区切り文字列 | Windowsは '`\`'、他は '`/`' |
| 2行目 | パス内のテンプレートを区切る文字 | '`;`' |
| 3行目 | テンプレート内の置換ポイントを示す文字列 | '`?`' |
| 4行目 | Windowsでパス内で実行ファイルのディレクトリに置換される文字列 | '`!`' |
| 5行目 | `luaopen_` 関数名を構築する際にそれ以降のすべてのテキストを無視するマーク | '`-`' |

---

### package.cpath

[`require`](#require-modname) がCローダーを検索するために使用するパスを持つ文字列。

Luaは、Luaパス [`package.path`](#packagepath) を初期化するのと同じ方法でCパス [`package.cpath`](#packagecpath) を初期化します。環境変数 `LUA_CPATH_5_5`、または環境変数 `LUA_CPATH`、または `luaconf.h` で定義されたデフォルトパスを使用します。

---

### package.loaded

どのモジュールが既にロードされているかを制御するために [`require`](#require-modname) が使用するテーブル。モジュール `modname` を require し、`package.loaded[modname]` が偽でない場合、[`require`](#require-modname) は単にそこに格納されている値を返します。

この変数は実際のテーブルへの参照に過ぎません。この変数への代入は [`require`](#require-modname) が使用するテーブルを変更しません。実際のテーブルはCレジストリ（[§4.3](04-the-application-program-interface.md#43--レジストリ) 参照）に格納され、キー `LUA_LOADED_TABLE`（文字列）でインデックスされます。

---

### package.loadlib (libname, funcname)

ホストプログラムをCライブラリ `libname` と動的にリンクします。

`funcname` が "`*`" の場合、ライブラリとリンクするだけで、ライブラリによってエクスポートされたシンボルを他の動的にリンクされたライブラリで使用可能にします。そうでなければ、ライブラリ内の関数 `funcname` を探し、この関数をC関数として返します。したがって、`funcname` は [`lua_CFunction`](04-the-application-program-interface.md#lua_cfunction) プロトタイプに従う必要があります。

これは低レベル関数です。パッケージとモジュールシステムを完全にバイパスします。[`require`](#require-modname) とは異なり、パス検索を行わず、自動的に拡張子を追加しません。`libname` は、必要に応じてパスと拡張子を含む、Cライブラリの完全なファイル名でなければなりません。`funcname` は、Cライブラリによってエクスポートされた正確な名前でなければなりません（使用されるCコンパイラとリンカに依存する場合があります）。

この機能はISO Cではサポートされていません。そのため、`loadlib` はいくつかのプラットフォームでのみ利用可能です：Linux、Windows、Mac OS X、Solaris、BSD、およびその他の `dlfcn` 標準をサポートするUnixシステム。

この関数は本質的に安全ではありません。Luaがシステム内の任意の読み取り可能な動的ライブラリ内の任意の関数を呼び出すことを許可するからです。（Luaは関数が適切なプロトタイプを持ち、適切なプロトコルを尊重すると仮定して任意の関数を呼び出します（[`lua_CFunction`](04-the-application-program-interface.md#lua_cfunction) 参照）。したがって、任意の動的ライブラリ内の任意の関数を呼び出すと、アクセス違反になることがほとんどです。）
## 6.4 – モジュール（パートB: package.path-package.searchpath）

---

### package.path

[`require`](#require-modname) がLuaローダーを検索するために使用するパスを持つ文字列。

起動時に、Luaはこの変数を環境変数 `LUA_PATH_5_5`、または環境変数 `LUA_PATH`、またはこれらの環境変数が定義されていない場合は `luaconf.h` で定義されたデフォルトパスの値で初期化します。環境変数の値の中の "`;;" `" はデフォルトパスに置き換えられます。

---

### package.preload

特定のモジュールのローダーを格納するテーブル（[`require`](#require-modname) 参照）。

この変数は実際のテーブルへの参照に過ぎません。この変数への代入は [`require`](#require-modname) が使用するテーブルを変更しません。実際のテーブルはCレジストリ（[§4.3](04-the-application-program-interface.md#43--レジストリ) 参照）に格納され、キー `LUA_PRELOAD_TABLE`（文字列）でインデックスされます。

---

### package.searchers

モジュールを見つける方法を制御するために [`require`](#require-modname) が使用するテーブル。

このテーブルの各エントリは*サーチャー関数*です。モジュールを探すとき、[`require`](#require-modname) はモジュール名（[`require`](#require-modname) に与えられた引数）を唯一の引数として、これらのサーチャーを昇順で呼び出します。サーチャーがモジュールを見つけた場合、別の関数、モジュール*ローダー*と、追加の値*ローダーデータ*を返します。これはそのローダーに渡され、[`require`](#require-modname) によって2番目の結果として返されます。モジュールが見つからない場合、理由を説明する文字列を返します（何も言うことがなければ **nil**）。

Luaはこのテーブルを4つのサーチャー関数で初期化します：

1. **最初のサーチャー**: [`package.preload`](#packagepreload) テーブルでローダーを探します。

2. **2番目のサーチャー**: [`package.path`](#packagepath) に格納されているパスを使用して、Luaライブラリとしてローダーを探します。検索は関数 [`package.searchpath`](#packagesearchpath-name-path--sep--rep) で説明されているように行われます。

3. **3番目のサーチャー**: 変数 [`package.cpath`](#packagecpath) で与えられたパスを使用して、Cライブラリとしてローダーを探します。ここでも、検索は関数 [`package.searchpath`](#packagesearchpath-name-path--sep--rep) で説明されているように行われます。
   
   例えば、Cパスが文字列
   ```
   "./?.so;./?.dll;/usr/local/?/init.so"
   ```
   の場合、モジュール `foo` のサーチャーはファイル `./foo.so`、`./foo.dll`、`/usr/local/foo/init.so` をその順序で開こうとします。
   
   Cライブラリを見つけると、このサーチャーはまず動的リンク機能を使用してアプリケーションをライブラリにリンクします。次に、ローダーとして使用するC関数をライブラリ内で見つけようとします。このC関数の名前は文字列 "`luaopen_`" にモジュール名のコピーを連結したもので、各ドットはアンダースコアに置き換えられます。さらに、モジュール名にハイフンがある場合、最初のハイフン以降（ハイフンを含む）の接尾辞は削除されます。例えば、モジュール名が `a.b.c-v2.1` の場合、関数名は `luaopen_a_b_c` になります。

4. **4番目のサーチャー**: *all-in-one ローダー*を試みます。与えられたモジュールのルート名のライブラリをCパスで検索します。例えば、`a.b.c` を require する場合、`a` のCライブラリを検索します。見つかった場合、サブモジュールのオープン関数を探します。この例では、`luaopen_a_b_c` になります。この機能により、パッケージは複数のCサブモジュールを1つのライブラリにパックでき、各サブモジュールは元のオープン関数を維持します。

最初（preload）以外のすべてのサーチャーは、モジュールが見つかったファイルパスを追加の値として返します。これは [`package.searchpath`](#packagesearchpath-name-path--sep--rep) によって返されます。最初のサーチャーは常に文字列 "`:preload:`" を返します。

サーチャーはエラーを発生させず、Luaで副作用を持つべきではありません。（Cでは副作用を持つことがあります。例えば、アプリケーションをライブラリにリンクすることによって。）

---

### package.searchpath (name, path [, sep [, rep]])

与えられた `path` 内で与えられた `name` を検索します。

パスはセミコロンで区切られた*テンプレート*のシーケンスを含む文字列です。各テンプレートについて、関数はテンプレート内の各疑問符（あれば）を `name` のコピーで置き換えます。このとき `sep`（デフォルトではドット）のすべての出現は `rep`（デフォルトではシステムのディレクトリ区切り文字）に置き換えられます。そして、結果のファイル名を開こうとします。

例えば、パスが文字列
```
"./?.lua;./?.lc;/usr/local/?/init.lua"
```
の場合、名前 `foo.a` の検索はファイル `./foo/a.lua`、`./foo/a.lc`、`/usr/local/foo/a/init.lua` をその順序で開こうとします。

読み取りモードで開くことができる最初のファイルの結果名を返し（ファイルを閉じた後）、成功しない場合は **fail** とエラーメッセージを返します。（このエラーメッセージは開こうとしたすべてのファイル名をリストします。）
## 6.5 – 文字列操作（パートA: string.byte-string.find）

このライブラリは、部分文字列の検索と抽出、パターンマッチングなど、文字列操作のための汎用関数を提供します。Luaで文字列をインデックスするとき、最初の文字は位置 1 にあります（C のように 0 ではありません）。インデックスは負の値が許可され、文字列の末尾から後方にインデックスすると解釈されます。したがって、最後の文字は位置 -1 にあります。

文字列ライブラリはすべての関数をテーブル `string` の中に提供します。また、文字列にメタテーブルを設定し、`__index` フィールドが `string` テーブルを指すようにします。したがって、オブジェクト指向スタイルで文字列関数を使用できます。例えば、`string.byte(s,i)` は `s:byte(i)` と書くことができます。

文字列ライブラリは1バイト文字エンコーディングを想定しています。

---

### string.byte (s [, i [, j]])

文字 `s[i]`、`s[i+1]`、...、`s[j]` の内部数値コードを返します。`i` のデフォルト値は 1 です。`j` のデフォルト値は `i` です。これらのインデックスは関数 [`string.sub`](#stringsub-s-i--j) と同じルールに従って修正されます。

数値コードはプラットフォーム間で必ずしも移植可能ではありません。

---

### string.char (···)

0個以上の整数を受け取ります。引数の数と等しい長さの文字列を返し、各文字は対応する引数と等しい内部数値コードを持ちます。

数値コードはプラットフォーム間で必ずしも移植可能ではありません。

---

### string.dump (function [, strip])

与えられた関数のバイナリ表現（*バイナリチャンク*）を含む文字列を返します。これにより、この文字列に対する後の [`load`](#pdf-load) は関数のコピーを返します（ただし、新しいアップバリューを持ちます）。`strip` が真の値の場合、バイナリ表現はスペースを節約するために関数に関するすべてのデバッグ情報を含まないかもしれません。

アップバリューを持つ関数は、アップバリューの数のみが保存されます。（再）ロードされると、それらのアップバリューはフレッシュなインスタンスを受け取ります。（これらのアップバリューがどのように初期化されるかの詳細については [`load`](#pdf-load) 関数を参照してください。デバッグライブラリを使用して、ニーズに適した方法で関数のアップバリューをシリアライズおよび再ロードできます。）

---

### string.find (s, pattern [, init [, plain]])

文字列 `s` 内で `pattern`（[§6.5.1](#651--パターン) 参照）の最初のマッチを探します。マッチを見つけた場合、`find` はこの出現が始まる `s` のインデックスと終わるインデックスを返します。そうでなければ、**fail** を返します。3番目のオプションの数値引数 `init` は検索を開始する場所を指定します。デフォルト値は 1 で、負の値も可能です。4番目のオプション引数 `plain` として **true** を指定すると、パターンマッチング機能がオフになり、関数は単純な「部分文字列検索」操作を行い、`pattern` 内の文字はマジックとして扱われません。

パターンにキャプチャがある場合、マッチが成功すると、キャプチャされた値も2つのインデックスの後に返されます。
## 6.5 – 文字列操作（パートB: string.format-string.len）

---

### string.format (formatstring, ···)

最初の引数で与えられた説明に従って、可変数の引数をフォーマットしたバージョンを返します。最初の引数は文字列でなければなりません。フォーマット文字列は ISO C 関数 `sprintf` と同じルールに従います。

受け入れられる変換指定子は：`A`, `a`, `c`, `d`, `E`, `e`, `f`, `G`, `g`, `i`, `o`, `p`, `s`, `u`, `X`, `x`, `%`、およびCにはない指定子 `q` です。

受け入れられるフラグは：'`-`', '`+`', '`#`', '`0`', '` `'（スペース）です。幅と精度の両方は、存在する場合、2桁に制限されます。

**指定子 `q`**: ブール値、nil、数値、文字列を、結果がLuaソースコードで有効な定数になるようにフォーマットします。ブール値と nil は明らかな方法（`true`, `false`, `nil`）で書かれます。浮動小数点数は完全な精度を保持するために16進数で書かれます。文字列はダブルクォートの間に書かれ、Luaインタプリタによって安全に読み戻せるよう、必要に応じてエスケープシーケンスを使用します。

例：
```lua
string.format('%q', 'a string with "quotes" and \n new line')
```
は以下の文字列を生成する可能性があります：
```
"a string with \"quotes\" and \
 new line"
```

この指定子は修飾子（フラグ、幅、精度）をサポートしません。

**数値指定子**: `A`, `a`, `E`, `e`, `f`, `G`, `g` はすべて引数として数値を期待します。`c`, `d`, `i`, `o`, `u`, `X`, `x` は整数を期待します。LuaがC89コンパイラでコンパイルされている場合、指定子 `A` と `a`（16進浮動小数点数）は修飾子をサポートしません。

**指定子 `s`**: 文字列を期待します。引数が文字列でない場合、[`tostring`](#pdf-tostring) と同じルールに従って文字列に変換されます。指定子に修飾子がある場合、対応する文字列引数は埋め込みゼロを含んではいけません。

**指定子 `p`**: [`lua_topointer`](04-the-application-program-interface.md#lua_topointer) によって返されるポインタをフォーマットします。これにより、テーブル、ユーザーデータ、スレッド、文字列、関数に対する一意の文字列識別子が得られます。他の値（数値、nil、ブール値）については、この指定子はポインタ `NULL` を表す文字列になります。

---

### string.gmatch (s, pattern [, init])

呼び出されるたびに、文字列 `s` 上の `pattern`（[§6.5.1](#651--パターン) 参照）からの次のキャプチャを返すイテレータ関数を返します。`pattern` がキャプチャを指定しない場合、各呼び出しでマッチ全体が生成されます。3番目のオプションの数値引数 `init` は検索を開始する場所を指定します。デフォルト値は 1 で、負の値も可能です。

例として、以下のループは文字列 `s` からすべての単語を反復し、1行に1つずつ出力します：

```lua
s = "hello world from Lua"
for w in string.gmatch(s, "%a+") do
  print(w)
end
```

次の例は、与えられた文字列からすべての `key=value` ペアをテーブルに収集します：

```lua
t = {}
s = "from=world, to=Lua"
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
  t[k] = v
end
```

この関数では、パターンの先頭にあるキャレット '`^`' はアンカーとして機能しません。これは反復を妨げるためです。

---

### string.gsub (s, pattern, repl [, n])

`s` のコピーを返し、`pattern`（[§6.5.1](#651--パターン) 参照）のすべての出現（または指定された場合は最初の `n` 個）が `repl` で指定された置換文字列に置き換えられます。`repl` は文字列、テーブル、または関数です。`gsub` は2番目の値として、発生したマッチの総数も返します。名前 `gsub` は *Global SUBstitution* に由来します。

**repl が文字列の場合**: その値が置換に使用されます。文字 `%` はエスケープ文字として機能します：`repl` 内の `%d`（d は 1 から 9）の形式のシーケンスは d 番目のキャプチャされた部分文字列の値を表し、シーケンス `%0` はマッチ全体を表し、シーケンス `%%` は単一の `%` を表します。

**repl がテーブルの場合**: 最初のキャプチャをキーとして使用して、マッチごとにテーブルがクエリされます。

**repl が関数の場合**: マッチが発生するたびにこの関数が呼び出され、すべてのキャプチャされた部分文字列が順番に引数として渡されます。

いずれの場合も、パターンがキャプチャを指定しない場合、パターン全体がキャプチャ内にあるかのように動作します。

テーブルクエリまたは関数呼び出しによって返された値が文字列または数値の場合、置換文字列として使用されます。そうでなければ、**false** または **nil** の場合、置換は行われません（つまり、元のマッチが文字列に保持されます）。

例：
```lua
x = string.gsub("hello world", "(%w+)", "%1 %1")
-- x="hello hello world world"

x = string.gsub("hello world", "%w+", "%0 %0", 1)
-- x="hello hello world"

x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
-- x="world hello Lua from"

x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
-- x="home = /home/roberto, user = roberto"

x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
      return load(s)()
    end)
-- x="4+5 = 9"

local t = {name="lua", version="5.5"}
x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
-- x="lua-5.5.tar.gz"
```

---

### string.len (s)

文字列を受け取り、その長さを返します。空文字列 `""` は長さ 0 です。埋め込みゼロもカウントされるので、`"a\000bc\000"` は長さ 5 です。
## 6.5 – 文字列操作（パートC: string.lower-string.rep）

---

### string.lower (s)

文字列を受け取り、すべての大文字が小文字に変更されたこの文字列のコピーを返します。他のすべての文字は変更されません。大文字の定義は現在のロケールに依存します。

---

### string.match (s, pattern [, init])

文字列 `s` 内で `pattern`（[§6.5.1](#651--パターン) 参照）の最初の*マッチ*を探します。見つかった場合、`match` はパターンからのキャプチャを返します。そうでなければ **fail** を返します。`pattern` がキャプチャを指定しない場合、マッチ全体が返されます。3番目のオプションの数値引数 `init` は検索を開始する場所を指定します。デフォルト値は 1 で、負の値も可能です。

---

### string.pack (fmt, v1, v2, ···)

フォーマット文字列 `fmt`（[§6.5.2](#652--packとunpackの書式文字列) 参照）に従って、値 `v1`, `v2` などをバイナリ形式でシリアライズ（パック）したバイナリ文字列を返します。

---

### string.packsize (fmt)

与えられたフォーマットで [`string.pack`](#stringpack-fmt-v1-v2-) から得られる文字列の長さを返します。フォーマット文字列は可変長オプション '`s`' または '`z`' を持つことができません（[§6.5.2](#652--packとunpackの書式文字列) 参照）。

---

### string.rep (s, n [, sep])

文字列 `s` の `n` 個のコピーを文字列 `sep` で区切って連結した文字列を返します。`sep` のデフォルト値は空文字列です（つまり、区切り文字なし）。`n` が正でない場合、空文字列を返します。

（この関数を1回呼び出すだけでマシンのメモリを使い果たすことが非常に簡単であることに注意してください。）
## 6.5 – 文字列操作（パートD: string.reverse-string.upper + パターン + Pack書式）

---

### string.reverse (s)

文字列 `s` を逆順にした文字列を返します。

---

### string.sub (s, i [, j])

`i` で始まり `j` まで続く `s` の部分文字列を返します。`i` と `j` は負の値も可能です。`j` が省略された場合、-1 と等しいと仮定されます（これは文字列の長さと同じです）。特に、呼び出し `string.sub(s,1,j)` は長さ `j` の `s` の接頭辞を返し、`string.sub(s,-i)`（正の `i` の場合）は長さ `i` の `s` の接尾辞を返します。

負のインデックスの変換後、`i` が 1 未満の場合、1 に修正されます。`j` が文字列の長さより大きい場合、その長さに修正されます。これらの修正後、`i` が `j` より大きい場合、関数は空文字列を返します。

---

### string.unpack (fmt, s [, pos])

フォーマット文字列 `fmt`（[§6.5.2](#652--packとunpackの書式文字列) 参照）に従って、文字列 `s`（[`string.pack`](#stringpack-fmt-v1-v2-) 参照）にパックされた値を返します。オプションの `pos` は `s` で読み取りを開始する位置を示します（デフォルトは 1）。読み取った値の後に、この関数は `s` 内の最初の未読バイトのインデックスも返します。

---

### string.upper (s)

文字列を受け取り、すべての小文字が大文字に変更されたこの文字列のコピーを返します。他のすべての文字は変更されません。小文字の定義は現在のロケールに依存します。

---

## 6.5.1 – パターン

Luaのパターンは通常の文字列で記述され、パターンマッチング関数 [`string.find`](#stringfind-s-pattern--init--plain)、[`string.gmatch`](#stringgmatch-s-pattern--init)、[`string.gsub`](#stringgsub-s-pattern-repl--n)、[`string.match`](#stringmatch-s-pattern--init) によってパターンとして解釈されます。このセクションでは、これらの文字列の構文と意味（つまり、何にマッチするか）について説明します。

### 文字クラス

*文字クラス*は文字の集合を表すために使用されます。文字クラスを記述する際には、以下の組み合わせが許可されています：

| パターン | 説明 |
|---------|------|
| **x** | （*x* がマジック文字 `^$()%.[]*+-?` でない場合）文字 *x* 自体を表す |
| **`.`** | （ドット）すべての文字を表す |
| **`%a`** | すべての文字（アルファベット）を表す |
| **`%c`** | すべての制御文字を表す |
| **`%d`** | すべての数字を表す |
| **`%g`** | スペースを除くすべての印刷可能文字を表す |
| **`%l`** | すべての小文字を表す |
| **`%p`** | すべての句読点文字を表す |
| **`%s`** | すべてのスペース文字を表す |
| **`%u`** | すべての大文字を表す |
| **`%w`** | すべての英数字を表す |
| **`%x`** | すべての16進数字を表す |
| **`%x`** | （*x* が任意の非英数字の場合）文字 *x* を表す。これはマジック文字をエスケープする標準的な方法。 |
| **`[set]`** | *set* 内のすべての文字の和集合であるクラスを表す |
| **`[^set]`** | *set* の補集合を表す |

**セットの詳細**: 範囲の終端文字を昇順で '`-`' で区切ることで、文字の範囲を指定できます。上記のすべてのクラス `%x` も *set* 内のコンポーネントとして使用できます。例えば、`[%w_]`（または `[_%w]`）はすべての英数字とアンダースコアを表し、`[0-7]` は8進数字を表し、`[0-7%l%-]` は8進数字と小文字と '`-`' 文字を表します。

閉じ角括弧をセットの最初の文字として配置することで、セット内に含めることができます。ハイフンをセットの最初または最後の文字として配置することで、セット内に含めることができます。

単一文字で表されるすべてのクラス（`%a`, `%c` など）について、対応する大文字はクラスの補集合を表します。例えば、`%S` はすべての非スペース文字を表します。

### パターン項目

*パターン項目*は以下のいずれかです：

| 項目 | 説明 |
|------|------|
| 単一の文字クラス | クラス内の任意の単一文字にマッチ |
| 文字クラス + `*` | クラス内の0個以上の文字のシーケンスにマッチ（最長マッチ） |
| 文字クラス + `+` | クラス内の1個以上の文字のシーケンスにマッチ（最長マッチ） |
| 文字クラス + `-` | クラス内の0個以上の文字のシーケンスにマッチ（最短マッチ） |
| 文字クラス + `?` | クラス内の文字の0回または1回の出現にマッチ |
| `%n` | （n は 1-9）n 番目のキャプチャされた文字列と等しい部分文字列にマッチ |
| `%bxy` | *x* で始まり *y* で終わり、*x* と *y* がバランスしている文字列にマッチ |
| `%f[set]` | *フロンティアパターン*：次の文字が *set* に属し、前の文字が *set* に属さない位置で空文字列にマッチ |

### パターン

*パターン*はパターン項目のシーケンスです。パターンの先頭にあるキャレット '`^`' はマッチを対象文字列の先頭にアンカーします。パターンの末尾にある '`$`' はマッチを対象文字列の末尾にアンカーします。他の位置では、'`^`' と '`$`' は特別な意味を持たず、自身を表します。

### キャプチャ

パターンは括弧で囲まれたサブパターンを含むことができます。これらは*キャプチャ*を記述します。マッチが成功すると、キャプチャにマッチした対象文字列の部分文字列が将来の使用のために格納（*キャプチャ*）されます。キャプチャは左括弧に従って番号付けされます。

例えば、パターン `"(a*(.)%w(%s*))"` では、`"a*(.)%w(%s*)"` にマッチする文字列の部分が最初のキャプチャとして格納され、番号 1 になります。"`.`" にマッチする文字は番号 2 でキャプチャされ、"`%s*`" にマッチする部分は番号 3 になります。

特殊なケースとして、キャプチャ `()` は現在の文字列位置（数値）をキャプチャします。

### 複数マッチ

関数 [`string.gsub`](#stringgsub-s-pattern-repl--n) とイテレータ [`string.gmatch`](#stringgmatch-s-pattern--init) は、対象内の与えられたパターンの複数の出現にマッチします。これらの関数では、新しいマッチは前のマッチの終了後少なくとも1バイト後に終了する場合にのみ有効と見なされます。言い換えれば、パターンマシンは別のマッチの直後に空文字列をマッチとして受け入れません。

---

## 6.5.2 – PackとUnpackの書式文字列

[`string.pack`](#stringpack-fmt-v1-v2-)、[`string.packsize`](#stringpacksize-fmt)、[`string.unpack`](#stringunpack-fmt-s--pos) への最初の引数は書式文字列で、作成または読み取られる構造のレイアウトを記述します。

書式文字列は変換オプションのシーケンスです。変換オプションは以下の通りです：

### エンディアンとアライメント

| オプション | 説明 |
|-----------|------|
| `<` | リトルエンディアンに設定 |
| `>` | ビッグエンディアンに設定 |
| `=` | ネイティブエンディアンに設定 |
| `![n]` | 最大アライメントを `n` に設定（デフォルトはネイティブアライメント） |

### 整数型

| オプション | 説明 |
|-----------|------|
| `b` | 符号付きバイト（`char`） |
| `B` | 符号なしバイト（`char`） |
| `h` | 符号付き `short`（ネイティブサイズ） |
| `H` | 符号なし `short`（ネイティブサイズ） |
| `l` | 符号付き `long`（ネイティブサイズ） |
| `L` | 符号なし `long`（ネイティブサイズ） |
| `j` | `lua_Integer` |
| `J` | `lua_Unsigned` |
| `T` | `size_t`（ネイティブサイズ） |
| `i[n]` | `n` バイトの符号付き `int`（デフォルトはネイティブサイズ） |
| `I[n]` | `n` バイトの符号なし `int`（デフォルトはネイティブサイズ） |

### 浮動小数点型

| オプション | 説明 |
|-----------|------|
| `f` | `float`（ネイティブサイズ） |
| `d` | `double`（ネイティブサイズ） |
| `n` | `lua_Number` |

### 文字列型

| オプション | 説明 |
|-----------|------|
| `cn` | `n` バイトの固定サイズ文字列 |
| `z` | ゼロ終端文字列 |
| `s[n]` | `n` バイトの符号なし整数としてコードされた長さが先行する文字列（デフォルトは `size_t`） |

### パディングとアライメント

| オプション | 説明 |
|-----------|------|
| `x` | 1バイトのパディング |
| `Xop` | オプション `op` に従ってアライメントする空の項目 |
| ` `（スペース） | 無視される |

### 注意事項

- "`[n]`" はオプションの整数を意味します
- オプション "`!n`", "`sn`", "`in`", "`In`" では、`n` は 1 から 16 までの任意の整数
- すべての整数オプションはオーバーフローをチェックします
- 任意の書式文字列は "`!1=`" が前置されたかのように開始します（アライメント 1、ネイティブエンディアン）
- すべてのパディングは [`string.pack`](#stringpack-fmt-v1-v2-) によってゼロで埋められ、[`string.unpack`](#stringunpack-fmt-s--pos) によって無視されます
## 6.6 – UTF-8サポート

このライブラリはUTF-8エンコーディングの基本的なサポートを提供します。すべての関数はテーブル `utf8` の内部に提供されます。このライブラリは、エンコーディングの処理以外のUnicodeサポートは提供しません。文字分類など、文字の意味を必要とする操作はスコープ外です。

特に明記されない限り、パラメータとしてバイト位置を期待するすべての関数は、指定された位置がバイトシーケンスの開始位置か、対象文字列の長さプラス1であると仮定します。文字列ライブラリと同様に、負のインデックスは文字列の末尾からカウントします。

バイトシーケンスを作成する関数は、元のUTF-8仕様で定義されているように、`0x7FFFFFFF` までのすべての値を受け入れます。これは最大6バイトのバイトシーケンスを意味します。

バイトシーケンスを解釈する関数は、有効なシーケンス（正しい形式で、冗長でない）のみを受け入れます。デフォルトでは、有効なUnicodeコードポイントになるバイトシーケンスのみを受け入れ、`10FFFF` より大きい値とサロゲートを拒否します。ブール引数 `lax` が利用可能な場合、これを指定するとこれらのチェックが解除され、`0x7FFFFFFF` までのすべての値が受け入れられます。（正しくない形式と冗長なシーケンスは引き続き拒否されます。）

---

### utf8.char (···)

0個以上の整数を受け取り、それぞれを対応するUTF-8バイトシーケンスに変換し、すべてのシーケンスを連結した文字列を返します。

---

### utf8.charpattern

パターン（関数ではなく文字列）"`[\0-\x7F\xC2-\xFD][\x80-\xBF]*`"（[§6.5.1](#651--パターン) 参照）は、対象が有効なUTF-8文字列であると仮定して、正確に1つのUTF-8バイトシーケンスにマッチします。

---

### utf8.codes (s [, lax])

以下の構文

```lua
for p, c in utf8.codes(s) do body end
```

が文字列 `s` 内のすべてのUTF-8文字に対して反復するような値を返します。`p` は各文字の位置（バイト単位）であり、`c` はコードポイントです。無効なバイトシーケンスに遭遇した場合、エラーを発生させます。

---

### utf8.codepoint (s [, i [, j [, lax]]])

バイト位置 `i` と `j`（両方を含む）の間で開始する `s` 内のすべての文字からコードポイント（整数として）を返します。`i` のデフォルトは 1、`j` のデフォルトは `i` です。無効なバイトシーケンスに遭遇した場合、エラーを発生させます。

---

### utf8.len (s [, i [, j [, lax]]])

位置 `i` と `j`（両方を含む）の間で開始する文字列 `s` 内のUTF-8文字の数を返します。`i` のデフォルトは 1、`j` のデフォルトは -1 です。無効なバイトシーケンスを見つけた場合、**fail** と最初の無効バイトの位置を返します。

---

### utf8.offset (s, n [, i])

`s` の `n` 番目の文字の位置（バイト位置 `i` からカウント）を2つの整数として返します：そのエンコーディングが開始するインデックス（バイト単位）と、終了するインデックス（バイト単位）です。

指定された文字が `s` の終端の直後にある場合、関数はそこに '`\0`' があるかのように振る舞います。指定された文字が対象内にも終端の直後にもない場合、関数は **fail** を返します。

負の `n` は位置 `i` より前の文字を取得します。`n` が非負の場合、`i` のデフォルトは 1 であり、それ以外の場合は `#s + 1` です。したがって、`utf8.offset(s,-n)` は文字列の末尾から `n` 番目の文字のオフセットを取得します。

特殊なケースとして、`n` が 0 の場合、関数は `s` の `i` 番目のバイトを含む文字のエンコーディングの開始と終了を返します。

この関数は `s` が有効なUTF-8文字列であると仮定します。
## 6.7 – テーブル操作

このライブラリはテーブル操作のための汎用関数を提供します。すべての関数はテーブル `table` の内部に提供されます。

操作がテーブルの長さを必要とする場合は常に、長さ演算子に関するすべての注意事項が適用されます（[§3.4.7](#347--長さ演算子) 参照）。すべての関数は、引数として与えられたテーブル内の非数値キーを無視します。

---

### table.concat (list [, sep [, i [, j]]])

すべての要素が文字列または数値であるリストが与えられた場合、文字列 `list[i]..sep..list[i+1] ··· sep..list[j]` を返します。`sep` のデフォルト値は空文字列であり、`i` のデフォルトは 1、`j` のデフォルトは `#list` です。`i` が `j` より大きい場合、空文字列を返します。

---

### table.create (nseq [, nrec])

メモリを事前割り当てして、新しい空のテーブルを作成します。テーブルが持つ要素の数を事前に知っている場合、この事前割り当てはパフォーマンスの向上とメモリの節約に役立つ場合があります。

パラメータ `nseq` は、テーブルがシーケンスとして持つ要素数のヒントです。オプションパラメータ `nrec` は、テーブルが持つその他の要素数のヒントです。デフォルトは 0 です。

---

### table.insert (list, [pos,] value)

要素 `value` を `list` の位置 `pos` に挿入し、要素 `list[pos],list[pos+1],···,list[#list]` を上にシフトします。`pos` のデフォルト値は `#list+1` であるため、呼び出し `table.insert(t,x)` はリスト `t` の末尾に `x` を挿入します。

---

### table.move (a1, f, e, t [,a2])

テーブル `a1` からテーブル `a2` へ要素を移動し、以下の多重代入と同等の処理を行います：`a2[t],··· = a1[f],···,a1[e]`。`a2` のデフォルトは `a1` です。移動先の範囲は移動元の範囲と重なることができます。移動する要素の数はLua整数に収まる必要があります。`f` が `e` より大きい場合、何も移動されません。

移動先テーブル `a2` を返します。

---

### table.pack (···)

すべての引数をキー 1, 2 などに格納し、引数の総数を示すフィールド "`n`" を持つ新しいテーブルを返します。いくつかの引数が **nil** の場合、結果のテーブルはシーケンスでない可能性があることに注意してください。

---

### table.remove (list [, pos])

`list` から位置 `pos` の要素を削除し、削除された要素の値を返します。`pos` が 1 から `#list` までの整数の場合、要素 `list[pos+1],list[pos+2],···,list[#list]` を下にシフトし、要素 `list[#list]` を消去します。インデックス `pos` は、`#list` が 0 の場合は 0、または `#list + 1` も指定できます。

`pos` のデフォルト値は `#list` であるため、呼び出し `table.remove(l)` はリスト `l` の最後の要素を削除します。

---

### table.sort (list [, comp])

リストの要素を指定された順序で*その場で*ソートします。`list[1]` から `list[#list]` まで。`comp` が与えられた場合、2つのリスト要素を受け取り、最初の要素が最終的な順序で2番目の要素より前に来る必要がある場合に true を返す関数でなければなりません。ソート後、`i <= j` は `not comp(list[j],list[i])` を意味します。`comp` が与えられていない場合、代わりに標準Lua演算子 `<` が使用されます。

`comp` 関数は一貫した順序を定義する必要があります。より形式的には、関数は厳密な弱順序を定義する必要があります。（弱順序は全順序に類似していますが、比較目的で異なる要素を等しいと見なすことができます。）

ソートアルゴリズムは安定ではありません：指定された順序で等しいと見なされる異なる要素は、ソートによって相対的な位置が変わる可能性があります。

---

### table.unpack (list [, i [, j]])

指定されたリストから要素を返します。この関数は以下と同等です：

```lua
return list[i], list[i+1], ···, list[j]
```

デフォルトでは、`i` は 1、`j` は `#list` です。
## 6.8 – 数学関数

このライブラリは基本的な数学関数を提供します。すべての関数と定数はテーブル `math` の内部に提供されます。注釈 "`integer/float`" が付いた関数は、整数引数に対して整数結果を、非整数引数に対して浮動小数点結果を返します。丸め関数 [`math.ceil`](#mathceil-x)、[`math.floor`](#mathfloor-x)、[`math.modf`](#mathmodf-x) は、結果が整数の範囲内に収まる場合は整数を、そうでなければ浮動小数点数を返します。

---

### math.abs (x)

`x` と `-x` の最大値を返します。（integer/float）

---

### math.acos (x)

`x` の逆余弦（ラジアン単位）を返します。

---

### math.asin (x)

`x` の逆正弦（ラジアン単位）を返します。

---

### math.atan (y [, x])

`y/x` の逆正接（ラジアン単位）を返します。両方の引数の符号を使用して結果の象限を決定します。`x` がゼロの場合も正しく処理します。

`x` のデフォルト値は 1 であるため、呼び出し `math.atan(y)` は `y` の逆正接を返します。

---

### math.ceil (x)

`x` 以上の最小の整数値を返します。

---

### math.cos (x)

`x`（ラジアン単位と仮定）の余弦を返します。
## 6.8 – 数学関数（パートB: deg-huge）

---

### math.deg (x)

角度 `x` をラジアンから度に変換します。

---

### math.exp (x)

値 *e^x* を返します（`e` は自然対数の底）。

---

### math.floor (x)

`x` 以下の最大の整数値を返します。

---

### math.fmod (x, y)

商をゼロに向かって丸める `x` を `y` で割った剰余を返します。（integer/float）

---

### math.frexp (x)

*x = m·2^e* となる2つの数 `m` と `e` を返します。`e` は整数です。`x` がゼロ、NaN、+inf、または -inf の場合、`m` は `x` に等しくなります。それ以外の場合、`m` の絶対値は範囲 *[0.5, 1)* 内にあります。

---

### math.huge

浮動小数点値 `HUGE_VAL`。他のどの数値よりも大きい値です。
## 6.8 – 数学関数（パートC: ldexp-mininteger）

---

### math.ldexp (m, e)

*m·2^e* を返します。`e` は整数です。

---

### math.log (x [, base])

指定された底での `x` の対数を返します。`base` のデフォルトは *e* です（したがって、関数は `x` の自然対数を返します）。

---

### math.max (x, ···)

Lua演算子 `<` に従って、最大値を持つ引数を返します。

---

### math.maxinteger

整数の最大値を持つ整数。

---

### math.min (x, ···)

Lua演算子 `<` に従って、最小値を持つ引数を返します。

---

### math.mininteger

整数の最小値を持つ整数。
## 6.8 – 数学関数（パートD: modf-randomseed）

---

### math.modf (x)

`x` の整数部と小数部を返します。2番目の結果は常に浮動小数点数です。

---

### math.pi

*π* の値。

---

### math.rad (x)

角度 `x` を度からラジアンに変換します。

---

### math.random ([m [, n]])

引数なしで呼び出された場合、範囲 *[0, 1)* で一様分布を持つ疑似乱数浮動小数点数を返します。2つの整数 `m` と `n` で呼び出された場合、`math.random` は範囲 *[m, n]* で一様分布を持つ疑似乱数整数を返します。正の `n` に対する呼び出し `math.random(n)` は `math.random(1,n)` と等価です。呼び出し `math.random(0)` はすべてのビットが（疑似）ランダムな整数を生成します。

この関数は `xoshiro256**` アルゴリズムを使用して疑似乱数64ビット整数を生成します。これは引数 0 での呼び出しの結果です。その他の結果（範囲と浮動小数点数）はこれらの整数からバイアスなく抽出されます。

Luaは引数なしで [`math.randomseed`](#mathrandomseed-x--y) を呼び出したのと同等の方法で疑似乱数生成器を初期化するため、`math.random` はプログラムが実行されるたびに異なる結果のシーケンスを生成するはずです。

---

### math.randomseed ([x [, y]])

少なくとも1つの引数で呼び出された場合、整数パラメータ `x` と `y` は*シード*に結合され、疑似乱数生成器を再初期化するために使用されます。同じシードは同じ数値のシーケンスを生成します。`y` のデフォルトはゼロです。

引数なしで呼び出された場合、Luaはランダム性に対する弱い試みでシードを生成します。

この関数は実際に使用された2つのシードコンポーネントを返すため、それらを再度設定するとシーケンスが繰り返されます。

初期状態に必要なレベルのランダム性を確保するため（または逆に、プログラムをデバッグするときなど、決定論的なシーケンスを持つため）、明示的な引数で [`math.randomseed`](#mathrandomseed-x--y) を呼び出す必要があります。
## 6.8 – 数学関数（パートE: sin-ult）

---

### math.sin (x)

`x`（ラジアン単位と仮定）の正弦を返します。

---

### math.sqrt (x)

`x` の平方根を返します。（式 `x^0.5` を使用してもこの値を計算できます。）

---

### math.tan (x)

`x`（ラジアン単位と仮定）の正接を返します。

---

### math.tointeger (x)

値 `x` が整数に変換可能な場合、その整数を返します。そうでなければ、**fail** を返します。

---

### math.type (x)

`x` が整数の場合 "`integer`" を、浮動小数点数の場合 "`float`" を、`x` が数値でない場合は **fail** を返します。

---

### math.ult (m, n)

整数 `m` が整数 `n` より小さいかどうかを、符号なし整数として比較した場合にブール値を返します。`m` が `n` より小さい場合のみ **true** を返します。
## 6.9 – 入出力機能

I/Oライブラリはファイル操作のために2つの異なるスタイルを提供します。最初のスタイルは暗黙のファイルハンドルを使用します。つまり、デフォルトの入力ファイルとデフォルトの出力ファイルを設定する操作があり、すべての入出力操作はこれらのデフォルトファイルに対して行われます。2番目のスタイルは明示的なファイルハンドルを使用します。

暗黙のファイルハンドルを使用する場合、すべての操作はテーブル `io` によって提供されます。明示的なファイルハンドルを使用する場合、操作 [`io.open`](#ioopen-filename--mode) がファイルハンドルを返し、すべての操作はファイルハンドルのメソッドとして提供されます。

ファイルハンドルのメタテーブルは、呼び出されたときにファイルを閉じようとする `__gc` と `__close` のメタメソッドを提供します。

テーブル `io` は、Cから通常の意味を持つ3つの事前定義されたファイルハンドルも提供します：`io.stdin`、`io.stdout`、`io.stderr`。I/Oライブラリはこれらのファイルを閉じることはありません。

特に明記されない限り、すべてのI/O関数は失敗時に **fail** を返し、2番目の結果としてエラーメッセージ、3番目の結果としてシステム依存のエラーコードを返し、成功時には何らかの false でない値を返します。非POSIXシステムでは、エラー時のエラーメッセージとエラーコードの計算は、グローバルC変数 `errno` に依存するため、スレッドセーフでない場合があります。

---

### io.close ([file])

`file:close()` と等価です。`file` が指定されていない場合、デフォルトの出力ファイルを閉じます。

---

### io.flush ()

`io.output():flush()` と等価です。

---

### io.input ([file])

ファイル名で呼び出された場合、指定されたファイルを（テキストモードで）開き、そのハンドルをデフォルトの入力ファイルとして設定します。ファイルハンドルで呼び出された場合、単にこのファイルハンドルをデフォルトの入力ファイルとして設定します。引数なしで呼び出された場合、現在のデフォルトの入力ファイルを返します。

エラーの場合、この関数はエラーコードを返す代わりにエラーを発生させます。

---

### io.lines ([filename, ···])

指定されたファイル名を読み取りモードで開き、開かれたファイルに対して `file:lines(···)` のように動作するイテレータ関数を返します。イテレータ関数が値を読み取れなかった場合、自動的にファイルを閉じます。イテレータ関数に加えて、`io.lines` は3つの他の値を返します：2つの **nil** 値をプレースホルダーとして、および作成されたファイルハンドル。したがって、汎用 **for** ループで使用する場合、ループがエラーまたは **break** によって中断された場合もファイルは閉じられます。

呼び出し `io.lines()`（ファイル名なし）は `io.input():lines("l")` と等価です。つまり、デフォルトの入力ファイルの行に対して反復します。この場合、イテレータはループが終了してもファイルを閉じません。

ファイルを開く際のエラーの場合、この関数はエラーコードを返す代わりにエラーを発生させます。
## 6.9 – 入出力機能（パートB: io.open-io.read）

---

### io.open (filename [, mode])

この関数は、文字列 `mode` で指定されたモードでファイルを開きます。成功した場合、新しいファイルハンドルを返します。

`mode` 文字列は以下のいずれかです：

| モード | 説明 |
|--------|------|
| `"r"` | 読み取りモード（デフォルト） |
| `"w"` | 書き込みモード |
| `"a"` | 追記モード |
| `"r+"` | 更新モード、以前のデータはすべて保持 |
| `"w+"` | 更新モード、以前のデータはすべて消去 |
| `"a+"` | 追記更新モード、以前のデータは保持、書き込みはファイルの末尾のみ許可 |

`mode` 文字列は末尾に '`b`' を持つこともでき、一部のシステムではバイナリモードでファイルを開くために必要です。

---

### io.output ([file])

[`io.input`](#ioinput-file) と同様ですが、デフォルトの出力ファイルに対して操作します。

---

### io.popen (prog [, mode])

この関数はシステム依存であり、すべてのプラットフォームで利用可能ではありません。

プログラム `prog` を別のプロセスで開始し、このプログラムからデータを読み取る（`mode` が `"r"` の場合、デフォルト）またはこのプログラムにデータを書き込む（`mode` が `"w"` の場合）ために使用できるファイルハンドルを返します。

---

### io.read (···)

`io.input():read(···)` と等価です。
## 6.9 – 入出力機能（パートC: io.stderr-io.write）

---

### io.stderr

事前定義された標準エラー出力ファイルハンドル。Cの `stderr` と同じ意味を持ちます。

---

### io.stdin

事前定義された標準入力ファイルハンドル。Cの `stdin` と同じ意味を持ちます。

---

### io.stdout

事前定義された標準出力ファイルハンドル。Cの `stdout` と同じ意味を持ちます。

---

### io.tmpfile ()

成功した場合、一時ファイルのハンドルを返します。このファイルは更新モードで開かれ、プログラムが終了すると自動的に削除されます。

---

### io.type (obj)

`obj` が有効なファイルハンドルかどうかを確認します。`obj` が開いているファイルハンドルの場合は文字列 `"file"` を、`obj` が閉じられたファイルハンドルの場合は `"closed file"` を、`obj` がファイルハンドルでない場合は **fail** を返します。

---

### io.write (···)

`io.output():write(···)` と等価です。
## 6.9 – 入出力機能（パートD: file:メソッド）

---

### file:close ()

`file` を閉じます。ファイルはハンドルがガベージコレクションされるときに自動的に閉じられますが、それがいつ起こるかは予測できないことに注意してください。

[`io.popen`](#iopopen-prog--mode) で作成されたファイルハンドルを閉じる場合、[`file:close`](#fileclose-) は [`os.execute`](#osecute-command) が返す値と同じ値を返します。

---

### file:flush ()

書き込まれたデータを `file` に保存します。

---

### file:lines (···)

呼び出されるたびに、指定されたフォーマットに従ってファイルを読み取るイテレータ関数を返します。フォーマットが指定されていない場合、デフォルトとして "`l`" を使用します。例えば、以下の構文

```lua
for c in file:lines(1) do body end
```

は、現在の位置から開始して、ファイルのすべての文字に対して反復します。[`io.lines`](#iolines-filename-) と異なり、この関数はループが終了してもファイルを閉じません。

---

### file:read (···)

指定されたフォーマットに従ってファイル `file` を読み取ります。フォーマットは何を読み取るかを指定します。各フォーマットに対して、関数は読み取った文字を含む文字列または数値を返すか、指定されたフォーマットでデータを読み取れない場合は **fail** を返します。（後者の場合、関数は後続のフォーマットを読み取りません。）引数なしで呼び出された場合、次の行を読み取るデフォルトのフォーマットを使用します。

利用可能なフォーマット：

| フォーマット | 説明 |
|-------------|------|
| `"n"` | 数値を読み取り、Luaの字句規則に従って浮動小数点数または整数として返す。（数値は先頭に空白と符号を持つことができます。）有効な数値の接頭辞となる最長の入力シーケンスを常に読み取ります。その接頭辞が有効な数値を形成しない場合（例：空文字列、"`0x`"、"`3.4e-`"）または長すぎる場合（200文字以上）、破棄されて **fail** を返します。 |
| `"a"` | 現在の位置からファイル全体を読み取ります。ファイル終端で空文字列を返します。このフォーマットは失敗しません。 |
| `"l"` | 次の行を行末をスキップして読み取り、ファイル終端で **fail** を返します。これがデフォルトのフォーマットです。 |
| `"L"` | 次の行を行末文字（存在する場合）を保持して読み取り、ファイル終端で **fail** を返します。 |
| *number* | このバイト数までの文字列を読み取り、ファイル終端で **fail** を返します。`number` が 0 の場合、何も読み取らず空文字列を返すか、ファイル終端で **fail** を返します。 |

フォーマット "`l`" と "`L`" はテキストファイルでのみ使用すべきです。

---

### file:seek ([whence [, offset]])

ファイル位置を、ファイルの先頭から測定して、`offset` に文字列 `whence` で指定された基準を加えた位置に設定および取得します：

| whence | 説明 |
|--------|------|
| `"set"` | 基準は位置 0（ファイルの先頭） |
| `"cur"` | 基準は現在の位置 |
| `"end"` | 基準はファイルの終端 |

成功した場合、`seek` はファイルの先頭からバイト単位で測定した最終的なファイル位置を返します。`seek` が失敗した場合、**fail** とエラーを説明する文字列を返します。

`whence` のデフォルト値は `"cur"`、`offset` のデフォルト値は 0 です。したがって、呼び出し `file:seek()` は現在のファイル位置を変更せずに返します。呼び出し `file:seek("set")` は位置をファイルの先頭に設定し（0 を返します）、呼び出し `file:seek("end")` は位置をファイルの終端に設定し、そのサイズを返します。

---

### file:setvbuf (mode [, size])

ファイルのバッファリングモードを設定します。3つの利用可能なモードがあります：

| モード | 説明 |
|--------|------|
| `"no"` | バッファリングなし |
| `"full"` | 完全バッファリング |
| `"line"` | 行バッファリング |

後者の2つの場合、`size` はバッファのサイズのヒント（バイト単位）です。デフォルトは適切なサイズです。

各モードの具体的な動作は移植性がありません。詳細はプラットフォームの基盤となるISO C関数 `setvbuf` を確認してください。

---

### file:write (···)

各引数の値を `file` に書き込みます。引数は文字列または数値でなければなりません。

成功した場合、この関数は `file` を返します。そうでなければ、4つの値を返します：**fail**、エラーメッセージ、エラーコード、書き込むことができたバイト数。
## 6.10 – オペレーティングシステム機能

このライブラリはテーブル `os` を通じて実装されています。

---

### os.clock ()

基盤となるISO C関数 `clock` が返す値として、プログラムが使用したCPU時間の秒単位の近似値を返します。

---

### os.date ([format [, time]])

指定された文字列 `format` に従ってフォーマットされた日付と時刻を含む文字列またはテーブルを返します。

`time` 引数が存在する場合、これはフォーマットされる時刻です（この値の説明は [`os.time`](#ostime-table) 関数を参照）。それ以外の場合、`date` は現在の時刻をフォーマットします。

`format` が '`!`' で始まる場合、日付は協定世界時でフォーマットされます。このオプションの文字の後、`format` が文字列 "`*t`" の場合、`date` は以下のフィールドを持つテーブルを返します：`year`、`month`（1–12）、`day`（1–31）、`hour`（0–23）、`min`（0–59）、`sec`（0–61、うるう秒のため）、`wday`（曜日、1–7、日曜日が 1）、`yday`（年の日、1–366）、`isdst`（夏時間フラグ、ブール値）。情報が利用できない場合、この最後のフィールドは存在しない可能性があります。

`format` が "`*t`" でない場合、`date` はISO C関数 `strftime` と同じ規則に従ってフォーマットされた文字列として日付を返します。

`format` が省略された場合、デフォルトは "`%c`" であり、現在のロケールを使用して人間が読める日付と時刻の表現を返します。

非POSIXシステムでは、この関数はC関数 `gmtime` とC関数 `localtime` に依存するため、スレッドセーフでない場合があります。

---

### os.difftime (t2, t1)

時刻 `t1` から時刻 `t2` までの差を秒単位で返します（時刻は [`os.time`](#ostime-table) が返す値）。POSIX、Windows、およびその他一部のシステムでは、この値は正確に `t2`−`t1` です。

---

### os.execute ([command])

この関数はISO C関数 `system` と等価です。`command` をオペレーティングシステムのシェルによって実行されるために渡します。最初の結果は、コマンドが正常に終了した場合は **true**、そうでなければ **fail** です。この最初の結果の後、関数は文字列と数値を返します：

| 文字列 | 説明 |
|--------|------|
| `"exit"` | コマンドが正常に終了した場合。続く数値はコマンドの終了ステータス。 |
| `"signal"` | コマンドがシグナルによって終了した場合。続く数値はコマンドを終了させたシグナル。 |

`command` なしで呼び出された場合、`os.execute` はシェルが利用可能かどうかを示すブール値を返します。

---

### os.exit ([code [, close]])

ISO C関数 `exit` を呼び出してホストプログラムを終了します。`code` が **true** の場合、返されるステータスは `EXIT_SUCCESS` です。`code` が **false** の場合、返されるステータスは `EXIT_FAILURE` です。`code` が数値の場合、返されるステータスはその数値です。`code` のデフォルト値は **true** です。

オプションの2番目の引数 `close` が true の場合、関数は終了前にLuaステートを閉じます（[`lua_close`](#lua_close) 参照）。

---

### os.getenv (varname)

プロセス環境変数 `varname` の値を返すか、変数が定義されていない場合は **fail** を返します。
## 6.10 – オペレーティングシステム機能（パートB: getenv-tmpname）

---

### os.remove (filename)

指定された名前のファイル（またはPOSIXシステムでは空のディレクトリ）を削除します。この関数が失敗した場合、**fail** とエラーを説明する文字列およびエラーコードを返します。そうでなければ、true を返します。

---

### os.rename (oldname, newname)

`oldname` という名前のファイルまたはディレクトリを `newname` に名前変更します。この関数が失敗した場合、**fail** とエラーを説明する文字列およびエラーコードを返します。そうでなければ、true を返します。

---

### os.setlocale (locale [, category])

プログラムの現在のロケールを設定します。`locale` はロケールを指定するシステム依存の文字列です。`category` は変更するカテゴリを説明するオプションの文字列です：`"all"`、`"collate"`、`"ctype"`、`"monetary"`、`"numeric"`、または `"time"`。デフォルトのカテゴリは `"all"` です。関数は新しいロケールの名前を返すか、リクエストを処理できない場合は **fail** を返します。

`locale` が空文字列の場合、現在のロケールは実装定義のネイティブロケールに設定されます。`locale` が文字列 "`C`" の場合、現在のロケールは標準Cロケールに設定されます。

最初の引数として **nil** で呼び出された場合、この関数は指定されたカテゴリの現在のロケールの名前のみを返します。

この関数はC関数 `setlocale` に依存するため、スレッドセーフでない場合があります。

---

### os.time ([table])

引数なしで呼び出された場合は現在のローカル時刻を返し、指定されたテーブルで指定されたローカル日付と時刻を表す時刻を返します。このテーブルにはフィールド `year`、`month`、`day` が必要であり、フィールド `hour`（デフォルトは 12）、`min`（デフォルトは 0）、`sec`（デフォルトは 0）、`isdst`（デフォルトは **nil**）を持つことができます。他のフィールドは無視されます。これらのフィールドの説明は [`os.date`](#osdate-format--time) 関数を参照してください。

関数が呼び出されたとき、これらのフィールドの値は有効な範囲内である必要はありません。例えば、`sec` が -10 の場合、他のフィールドで指定された時刻の10秒前を意味します。`hour` が 1000 の場合、他のフィールドで指定された時刻の1000時間後を意味します。

返される値は数値であり、その意味はシステムによって異なります。POSIX、Windows、およびその他一部のシステムでは、この数値は特定の開始時刻（「エポック」）からの秒数をカウントします。他のシステムでは、意味は指定されておらず、`time` が返す数値は [`os.date`](#osdate-format--time) と [`os.difftime`](#osdifftime-t2-t1) への引数としてのみ使用できます。

テーブルで呼び出された場合、`os.time` は [`os.date`](#osdate-format--time) 関数で文書化されているすべてのフィールドを正規化し、呼び出し前と同じ時刻を表しますが、値は有効な範囲内になります。

---

### os.tmpname ()

一時ファイルに使用できるファイル名を含む文字列を返します。ファイルは使用前に明示的に開き、不要になったら明示的に削除する必要があります。

POSIXシステムでは、この関数はセキュリティリスクを避けるため、その名前のファイルも作成します。（名前を取得してからファイルを作成するまでの間に、誰かが間違った権限でファイルを作成する可能性があります。）それでもファイルを使用するには開く必要があり、削除する必要があります（使用しない場合でも）。

可能であれば、プログラムが終了すると自動的にファイルを削除する [`io.tmpfile`](#iotmpfile-) を使用することをお勧めします。
## 6.11 – デバッグライブラリ

このライブラリは、Luaプログラムにデバッグインタフェース（[§4.7](#47--デバッグインタフェース) 参照）の機能を提供します。このライブラリを使用する際は注意が必要です。いくつかの関数はLuaコードに関する基本的な前提に違反し（例えば、関数にローカルな変数は外部からアクセスできない、ユーザーデータのメタテーブルはLuaコードで変更できない、Luaプログラムはクラッシュしないなど）、そのため安全なコードを危険にさらす可能性があります。さらに、このライブラリの一部の関数は遅い場合があります。

このライブラリのすべての関数は `debug` テーブル内に提供されます。スレッド上で動作するすべての関数は、動作対象のスレッドをオプションの最初の引数として持ちます。デフォルトは常に現在のスレッドです。

---

### debug.debug ()

ユーザーとの対話モードに入り、ユーザーが入力する各文字列を実行します。単純なコマンドやその他のデバッグ機能を使用して、ユーザーはグローバル変数とローカル変数を検査し、その値を変更し、式を評価することなどができます。単語 `cont` のみを含む行でこの関数は終了し、呼び出し元が実行を継続します。

`debug.debug` のコマンドは字句的にどの関数内にもネストされていないため、ローカル変数への直接アクセスはないことに注意してください。

---

### debug.gethook ([thread])

スレッドの現在のフック設定を3つの値として返します：現在のフック関数、現在のフックマスク、および [`debug.sethook`](#debugsethook-thread-hook-mask--count) 関数で設定された現在のフックカウント。

アクティブなフックがない場合は **fail** を返します。

---

### debug.getinfo ([thread,] f [, what])

関数に関する情報を含むテーブルを返します。関数を直接与えるか、`f` の値として数値を与えることができます。数値は、指定されたスレッドのコールスタックのレベル `f` で実行されている関数を意味します：レベル 0 は現在の関数（`getinfo` 自身）、レベル 1 は `getinfo` を呼び出した関数（テールコールはスタックにカウントされません）、などとなります。`f` がアクティブな関数の数より大きい数値の場合、`getinfo` は **fail** を返します。

返されるテーブルには [`lua_getinfo`](#lua_getinfo) が返すすべてのフィールドを含めることができ、文字列 `what` がどのフィールドを埋めるかを記述します。`what` のデフォルトは、有効な行のテーブルを除くすべての利用可能な情報を取得します。オプション '`f`' は関数自体を含む `func` という名前のフィールドを追加します。オプション '`L`' は、関数がLua関数の場合、有効な行のテーブルを含む `activelines` という名前のフィールドを追加します。関数にデバッグ情報がない場合、テーブルは空です。

例えば、式 `debug.getinfo(1,"n").name` は、合理的な名前が見つかれば現在の関数の名前を返し、式 `debug.getinfo(print)` は [`print`](#print-) 関数に関するすべての利用可能な情報を含むテーブルを返します。

---

### debug.getlocal ([thread,] f, local)

この関数は、スタックのレベル `f` の関数のインデックス `local` を持つローカル変数の名前と値を返します。この関数は明示的なローカル変数だけでなく、パラメータや一時的な値にもアクセスします。

最初のパラメータまたはローカル変数はインデックス 1 を持ち、コード内で宣言された順序に従い、関数の現在のスコープでアクティブな変数のみをカウントします。コンパイル時定数はコンパイラによって最適化された場合、このリストに表示されない場合があります。負のインデックスは可変引数を参照します。-1 は最初の可変引数です。これらの負のインデックスは可変引数テーブルが最適化された場合にのみ利用可能です。そうでなければ、可変引数は可変引数テーブル内で利用可能です。

関数は指定されたインデックスを持つ変数がない場合は **fail** を返し、範囲外のレベルで呼び出された場合はエラーを発生させます。（レベルが有効かどうかを確認するには [`debug.getinfo`](#debuggetinfo-thread-f--what) を呼び出すことができます。）

'`(`'（開き括弧）で始まる変数名は、既知の名前がない変数を表します（ループ制御変数などの内部変数や、デバッグ情報なしで保存されたチャンクからの変数）。

パラメータ `f` は関数であることもあります。その場合、`getlocal` は関数パラメータの名前のみを返します。
## 6.11 – デバッグライブラリ（パートB: getmetatable-setlocal）

---

### debug.getmetatable (value)

指定された `value` のメタテーブルを返すか、メタテーブルがない場合は **nil** を返します。

---

### debug.getregistry ()

レジストリテーブルを返します（[§4.3](#43--レジストリ) 参照）。

---

### debug.getupvalue (f, up)

この関数は、関数 `f` のインデックス `up` を持つ上位値の名前と値を返します。関数は指定されたインデックスを持つ上位値がない場合は **fail** を返します。

（Lua関数の場合、上位値は関数が使用する外部ローカル変数であり、したがってそのクロージャに含まれます。）

C関数の場合、この関数はすべての上位値の名前として空文字列 `""` を使用します。

変数名 '`?`'（疑問符）は既知の名前がない変数を表します（デバッグ情報なしで保存されたチャンクからの変数）。

---

### debug.getuservalue (u, n)

ユーザーデータ `u` に関連付けられた `n` 番目のユーザー値とブール値を返します。ユーザーデータがその値を持たない場合は **false** を返します。

---

### debug.sethook ([thread,] hook, mask [, count])

指定された関数をデバッグフックとして設定します。文字列 `mask` と数値 `count` は、フックがいつ呼び出されるかを記述します。文字列 mask は以下の文字の任意の組み合わせを持つことができ、それぞれの意味があります：

| マスク | 説明 |
|--------|------|
| `'c'` | Luaが関数を呼び出すたびにフックが呼び出される |
| `'r'` | Luaが関数から戻るたびにフックが呼び出される |
| `'l'` | Luaがコードの新しい行に入るたびにフックが呼び出される |

さらに、`count` がゼロと異なる場合、フックは `count` 命令ごとにも呼び出されます。

引数なしで呼び出された場合、[`debug.sethook`](#debugsethook-thread-hook-mask--count) はフックをオフにします。

フックが呼び出されたとき、その最初のパラメータは呼び出しをトリガーしたイベントを説明する文字列です：`"call"`、`"tail call"`、`"return"`、`"line"`、および `"count"`。行イベントの場合、フックは2番目のパラメータとして新しい行番号も取得します。フック内では、レベル 2 で `getinfo` を呼び出して実行中の関数についての詳細情報を取得できます。（レベル 0 は `getinfo` 関数であり、レベル 1 はフック関数です。）

---

### debug.setlocal ([thread,] level, local, value)

この関数は、値 `value` をスタックのレベル `level` の関数のインデックス `local` を持つローカル変数に代入します。関数は指定されたインデックスを持つローカル変数がない場合は **fail** を返し、範囲外の `level` で呼び出された場合はエラーを発生させます。（レベルが有効かどうかを確認するには `getinfo` を呼び出すことができます。）それ以外の場合、ローカル変数の名前を返します。

変数のインデックスと名前についての詳細は [`debug.getlocal`](#debuggetlocal-thread-f-local) を参照してください。
## 6.11 – デバッグライブラリ（パートC: setmetatable-upvaluejoin）

---

### debug.setmetatable (value, table)

指定された `value` のメタテーブルを指定された `table`（**nil** でも可）に設定します。`value` を返します。

---

### debug.setupvalue (f, up, value)

この関数は、値 `value` を関数 `f` のインデックス `up` を持つ上位値に代入します。関数は指定されたインデックスを持つ上位値がない場合は **fail** を返します。それ以外の場合、上位値の名前を返します。

上位値についての詳細は [`debug.getupvalue`](#debuggetupvalue-f-up) を参照してください。

---

### debug.setuservalue (udata, value, n)

指定された `value` を、指定された `udata` に関連付けられた `n` 番目のユーザー値として設定します。`udata` はフルユーザーデータでなければなりません。

`udata` を返すか、ユーザーデータがその値を持たない場合は **fail** を返します。

---

### debug.traceback ([thread,] [message [, level]])

`message` が存在するが文字列でも **nil** でもない場合、この関数はさらなる処理なしで `message` を返します。それ以外の場合、コールスタックのトレースバックを含む文字列を返します。オプションの `message` 文字列はトレースバックの先頭に追加されます。オプションの `level` 数値は、トレースバックを開始するレベルを示します（デフォルトは 1、`traceback` を呼び出している関数）。

---

### debug.upvalueid (f, n)

指定された関数から番号 `n` の上位値に対する一意の識別子（軽量ユーザーデータとして）を返します。

これらの一意の識別子により、プログラムは異なるクロージャが上位値を共有しているかどうかを確認できます。上位値を共有するLuaクロージャ（つまり、同じ外部ローカル変数にアクセスするクロージャ）は、それらの上位値インデックスに対して同一のIDを返します。

---

### debug.upvaluejoin (f1, n1, f2, n2)

Luaクロージャ `f1` の `n1` 番目の上位値が、Luaクロージャ `f2` の `n2` 番目の上位値を参照するようにします。
