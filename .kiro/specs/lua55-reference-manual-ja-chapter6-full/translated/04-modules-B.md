## 6.4 – モジュール（パートB: package.path-package.searchpath）

---

### package.path

[`require`](#require-modname) がLuaローダーを検索するために使用するパスを持つ文字列。

起動時に、Luaはこの変数を環境変数 `LUA_PATH_5_5`、または環境変数 `LUA_PATH`、またはこれらの環境変数が定義されていない場合は `luaconf.h` で定義されたデフォルトパスの値で初期化します。環境変数の値の中の "`;;" `" はデフォルトパスに置き換えられます。

---

### package.preload

特定のモジュールのローダーを格納するテーブル（[`require`](#require-modname) 参照）。

この変数は実際のテーブルへの参照に過ぎません。この変数への代入は [`require`](#require-modname) が使用するテーブルを変更しません。実際のテーブルはCレジストリ（[§4.3](04-the-application-program-interface.md#43--レジストリ) 参照）に格納され、キー `LUA_PRELOAD_TABLE`（文字列）でインデックスされます。

---

### package.searchers

モジュールを見つける方法を制御するために [`require`](#require-modname) が使用するテーブル。

このテーブルの各エントリは*サーチャー関数*です。モジュールを探すとき、[`require`](#require-modname) はモジュール名（[`require`](#require-modname) に与えられた引数）を唯一の引数として、これらのサーチャーを昇順で呼び出します。サーチャーがモジュールを見つけた場合、別の関数、モジュール*ローダー*と、追加の値*ローダーデータ*を返します。これはそのローダーに渡され、[`require`](#require-modname) によって2番目の結果として返されます。モジュールが見つからない場合、理由を説明する文字列を返します（何も言うことがなければ **nil**）。

Luaはこのテーブルを4つのサーチャー関数で初期化します：

1. **最初のサーチャー**: [`package.preload`](#packagepreload) テーブルでローダーを探します。

2. **2番目のサーチャー**: [`package.path`](#packagepath) に格納されているパスを使用して、Luaライブラリとしてローダーを探します。検索は関数 [`package.searchpath`](#packagesearchpath-name-path--sep--rep) で説明されているように行われます。

3. **3番目のサーチャー**: 変数 [`package.cpath`](#packagecpath) で与えられたパスを使用して、Cライブラリとしてローダーを探します。ここでも、検索は関数 [`package.searchpath`](#packagesearchpath-name-path--sep--rep) で説明されているように行われます。
   
   例えば、Cパスが文字列
   ```
   "./?.so;./?.dll;/usr/local/?/init.so"
   ```
   の場合、モジュール `foo` のサーチャーはファイル `./foo.so`、`./foo.dll`、`/usr/local/foo/init.so` をその順序で開こうとします。
   
   Cライブラリを見つけると、このサーチャーはまず動的リンク機能を使用してアプリケーションをライブラリにリンクします。次に、ローダーとして使用するC関数をライブラリ内で見つけようとします。このC関数の名前は文字列 "`luaopen_`" にモジュール名のコピーを連結したもので、各ドットはアンダースコアに置き換えられます。さらに、モジュール名にハイフンがある場合、最初のハイフン以降（ハイフンを含む）の接尾辞は削除されます。例えば、モジュール名が `a.b.c-v2.1` の場合、関数名は `luaopen_a_b_c` になります。

4. **4番目のサーチャー**: *all-in-one ローダー*を試みます。与えられたモジュールのルート名のライブラリをCパスで検索します。例えば、`a.b.c` を require する場合、`a` のCライブラリを検索します。見つかった場合、サブモジュールのオープン関数を探します。この例では、`luaopen_a_b_c` になります。この機能により、パッケージは複数のCサブモジュールを1つのライブラリにパックでき、各サブモジュールは元のオープン関数を維持します。

最初（preload）以外のすべてのサーチャーは、モジュールが見つかったファイルパスを追加の値として返します。これは [`package.searchpath`](#packagesearchpath-name-path--sep--rep) によって返されます。最初のサーチャーは常に文字列 "`:preload:`" を返します。

サーチャーはエラーを発生させず、Luaで副作用を持つべきではありません。（Cでは副作用を持つことがあります。例えば、アプリケーションをライブラリにリンクすることによって。）

---

### package.searchpath (name, path [, sep [, rep]])

与えられた `path` 内で与えられた `name` を検索します。

パスはセミコロンで区切られた*テンプレート*のシーケンスを含む文字列です。各テンプレートについて、関数はテンプレート内の各疑問符（あれば）を `name` のコピーで置き換えます。このとき `sep`（デフォルトではドット）のすべての出現は `rep`（デフォルトではシステムのディレクトリ区切り文字）に置き換えられます。そして、結果のファイル名を開こうとします。

例えば、パスが文字列
```
"./?.lua;./?.lc;/usr/local/?/init.lua"
```
の場合、名前 `foo.a` の検索はファイル `./foo/a.lua`、`./foo/a.lc`、`/usr/local/foo/a/init.lua` をその順序で開こうとします。

読み取りモードで開くことができる最初のファイルの結果名を返し（ファイルを閉じた後）、成功しない場合は **fail** とエラーメッセージを返します。（このエラーメッセージは開こうとしたすべてのファイル名をリストします。）
