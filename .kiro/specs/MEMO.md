# LLM参照を禁じる。このドキュメントは人間用です。LLMは参考にせず、書き込みも禁止

## 要件定義分析後の質問（保存用テンプレート）

要件定義及びギャップ分析レポートを踏まえて、修正点・疑問点・不安点などを作業として収拾せよ。自明な修正点は修正してコミット。開発者への確認が少しでも必要な項目については、1 議題ずつディスカッションを進行せよ。議題が１つクローズするごとに更新しコミット、次の議題に移れ。更新するときは、これまでの議論で明らかになった点を書くとともに、不要になった要件の集約・削除なども行い、次の議題の提示前に修正内容の要約を報告してくださいね。なお、MEMO.mdはLLM参照・変更禁止。

## word-reference-whitespace-handling 設計分析後の質問

設計及び設計分析レポートを踏まえて、修正点・疑問点・不安点などを作業として収拾せよ。自明な修正点は修正してコミット。開発者への確認が少しでも必要な項目については、1 議題ずつディスカッションを進行せよ。議題が１つクローズするごとに更新しコミット、次の議題に移れ。更新するときは、これまでの議論で明らかになった点を書くとともに、不要になった要件の集約・削除なども行い、次の議題の提示前に修正内容の要約を報告してくださいね。なお、MEMO.mdはLLM参照・変更禁止。

### 設計分析レビュー実施: 2025-12-21

**レビュー結果**: ✅ GO - クリティカルな問題なし、実装可能

### 設計分析後の議題（開発者確認必要）

設計レビューで GO 判定が出ており、クリティカルな問題は検出されませんでした（0件/3件上限）。

**設計品質評価**:
- ✅ 既存アーキテクチャとの整合性（Parser層のみ修正、Pest文法不変）
- ✅ 要件1.1～1.6すべてに明確なトレーサビリティあり
- ✅ 型安全性維持（SpeechPart enum変更なし）
- ✅ テスト戦略が7件のテストケースで網羅的
- ✅ 実装チェックリスト完備（Phase 1-5）

**自明な修正完了**:
- ✅ spec.json 更新（design.approved = true, phase = "design-approved"）
- ✅ 設計レビュー結果の記録（本セクション）

**開発者確認が必要な議題**: なし

設計書は実装に進むための十分な品質を満たしています。要件トレーサビリティ、Mermaidダイアグラム、型安全なインターフェース定義、エッジケース分析、パフォーマンス評価、マイグレーション戦略がすべて明確に記述されており、実装リスクは低いと評価されています。

**次のステップ**: タスク分解フェーズ（`/kiro-spec-tasks word-reference-whitespace-handling`）へ進む

---
## call-unified-scope-resolution 設計分析後の質問

設計及び設計分析レポートを踏まえて、修正点・疑問点・不安点などを作業として収拾せよ。自明な修正点は修正してコミット。開発者への確認が少しでも必要な項目については、1 議題ずつディスカッションを進行せよ。議題が１つクローズするごとに更新しコミット、次の議題に移れ。更新するときは、これまでの議論で明らかになった点を書くとともに、不要になった要件の集約・削除なども行い、次の議題の提示前に修正内容の要約を報告してくださいね。

### 設計分析レビュー実施: 2025-12-21

**レビュー結果**: 🟡 条件付き GO - 検索キー形式の明確化が必要

### 設計分析後の議題（開発者確認必要）

#### 議題1️⃣: 検索キー形式の統一方針決定 ✅ **解決**

**決定内容**: **Option A**（prefix_index 登録時に `:parent:local` 形式に変換）を採用

**理由**: WordTable との完全統一により、実装パターン流用が最も容易

**実装方針**:
- SceneTable.from_scene_registry() で prefix_index 登録時にキー変換
- ローカルシーン: `:parent_sanitized_N:local_sanitized_M` 形式で登録
- グローバルシーン: `name_N::__start__` 形式維持（`:` プレフィックスなし）
- 検索ロジック: WordTable.collect_word_candidates() と同じ2段階検索パターン

**変換ロジック例**:
```rust
// SceneTable::from_scene_registry() 内で
for scene in &labels {
    let search_key = if scene.parent.is_some() {
        // ローカルシーン: fn_name "親_1::子_1" → ":親_1:子_1"
        let parts: Vec<_> = scene.fn_name.split("::").collect();
        format!(":{}", parts.join(":"))
    } else {
        // グローバルシーン: そのまま
        scene.fn_name.clone()
    };
    prefix_index.entry(search_key.as_bytes()).or_insert_with(Vec::new).push(scene.id);
}
```

**反映対象**:
- ✅ design.md: Logical Data Model セクション更新
- ✅ research.md: Decision セクション追加
- ⬜ 実装時: SceneTable::from_scene_registry() 修正

---

## 過去の仕様（参考：削除しない）

### pasta-transpiler-variable-expansion 設計分析後の議題（完了）

実装完了を承認。ステアリングファイルをすべて読み込み、ワークフローに従って完了処理を行ってください。

## pasta XXXX

/kiro-spec-init
pastaスクリプトの説明となるGRAMMAR.mdが、現在の実装仕様から乖離している。現在実装されているpestによる定義から逆算し、文法設計を再度詰めなおしたい。成果物として以下の2つが必要。
1. 正確な文法を説明したもの。pest定義にコメントを付ける形でもよい。
2. GRAMMAR.md。一般向けに文法を説明するもの。


/kiro-spec-init
pasta エンジンに関する仕様。会話行中のインライン要素「＠会話
」について。たとえば「＠＠会話」となっているとき、

1. 最初の「＠会話」の単語解決
2. 解決した単語をキーワードにして単語解決
   の、２段構えの検索になってほしい。理論上は＠＠＠などの３段構え以上も可能と考えて仕様を検討。

## pasta XXXX

/kiro-spec-init
pasta エンジンに関する仕様。会話行中のインライン要素「＠会話」について。たとえば「＠＠会話」となっているとき、

1. 最初の「＠会話」の単語解決
2. 解決した単語をキーワードにして単語解決
   の、２段構えの検索になってほしい。理論上は＠＠＠などの３段構え以上も可能と考えて仕様を検討。

## pasta XXXX

/kiro-spec-init
pasta エンジンに関する仕様。チェイントーク（いったん会話を終了して次のトークに移る）ための IR は定義されているか。例えば「＠チェイン」または「＞チェイン」などとして関数を呼び出して、チェイントーク挿入が実現可能か。なお、すでに実現可能だと要件定義作成時調査で確認できた場合、本仕様は確認のみでクローズとする。要件定義指示の時に調査せよ。

## 確認

## 定型句

要件定義から不明瞭な点を TODO でリストアップし、議題を 1 つずつディスカッション進行して。議題がクローズしたら文書更新してコミット、次の議題へ。

分析結果の指摘点や不明瞭な点・決定が必要な点を TODO 抽出。
また、要件定義の「#### 出力例（リファレンス実装）」や「#### Acceptance Criteria」が、設計を詰めた結果食い違いが出ている。これらについては現在の設計が正だと考えられるため、要件定義の調整を含めてこれらも議題 TODO に含めよ。
自明な修正については議論を行わずに修正クローズ、開発者確認が必要な項目は 1 つずつディスカッション進行して。議題がクリアになったら文書更新してコミット、次の議題へ。議題クリアの判断は都度行って自律的に進めるように。

## セレクター API

### Call/Jump 行の変換

```pasta
  ？天気予報
```

```rune
  for a in pasta::jump(ctx, label, #{}, []) { yield a; }
```

### 利用方法(ctx.pasta API)

```rune
pub mod pasta{
  // Jump関数。Callとやることは同じ。callだけの実装でも可。
  pub fn pasta::jump(ctx, label, filters, args){
    let label = pasta::label_selector(label, filters)
    for a in label(ctx, args) { yield a; }
  }

  // rust側で登録するrune関数。シーンから関数ポインタを返す。
  // global_label: string　      ⇒ グローバルシーン検索キー
  // local_label: Option<string> ⇒ ローカルシーン検索キー
  pub fn label_selector(label){
    let n = select_label_to_id(label, filters);
    match n {
        1 => crate::会話_1::__start__;
        2 => crate::会話_1::選択肢_1;
        3 => crate::会話_1::選択肢_2;
    }
  }

  // rust側で実装するrust関数。シーンとfiltersから関数番号を返す。
  pub fn select_label_to_id(label, filters){
    1   // 現在は常に1を返す。
  }
}
```

### 実現したい検索方法

#### グローバルジャンプの場合

- **label_selector("会話",None)**
  ⇒ "会話" で始まるシーンを前方一致
  ⇒ 末尾が必ず`::__start__`であること。

#### ローカルジャンプの場合

-- **label_selector("会話\_1::選択肢", None)**
⇒ `mod 会話_1`の要素から、"選択肢"で始まるシーンを前方一致

### filters について

API 引数として予約。将来的にはフィルター条件をここに並べる。現在は無視してよいが、パラメーターとしては宣言してほしい。

## LabelRegistry でグローバル、ローカルを統一的に連番管理する方法

### グローバルの連番

("グローバルシーン名", "**start**")でキー

### ローカルの連番

("グローバルシーン名", "ローカルシーン名") でキー

### 同じグローバルシーンが複数あるが？

連番が重複しないことさえ保証すればよいので、実用上は困らない。fn_path が少し長くなる弊害は発生するがそれだけといえばそれだけ。
