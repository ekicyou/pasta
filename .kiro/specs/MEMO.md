# このドキュメントは参考にしないように

## パスタスクリプトの要件整理

### 行指向文法
パスタスクリプトは、行頭の数文字により、行属性が確定する行指向文法である。例外は1つ、「runeコードブロック」については複数行にわたりコードブロックを形成する。

### キーワード
パスタスクリプトにおけるキーワードを定義する。

空白：pestの定義済みルール`WHITE_SPACE`から、`\r``\n`（改行文字）を除外したものが1つ以上連続したもの。空白が必要・または許される個所で1つ以上連続した場合、すべて消費して1つの「空白」として扱う。
識別子：{ `XID_START` - `XID_CONTINUE`* }
グローバルラベル：「＊」 または 「*」。
ローカルラベル：「・」または「-」
属性：「＆」または「&」。
単語登録、単語呼び出し：「＠」または「@」
アクター名と会話文の区切り文字：「：」または「:」
runeコードブロックの開始：「```rune」
runeコードブロックの終了：「```」



ここまで良いか？現状のpest定義との乖離があれば指摘せよ。


### 宣言型言語
パスタスクリプトは宣言型の言語であり、文法内にcall/jump/単語呼び出し以外の制御構造を持たない。call/jump/単語呼び出しにおいても、キーワードの前方一致とフィルター設定の宣言にとどめ、制御構造が必要な場合はruneコードブロックなどに宣言するrune関数に役割を任せる。

### セクションの呼び出し
call/jump/単語呼び出しは、呼び出し条件に一致したセクションの呼び出しを行う。呼び出し条件は以下の組み合わせで、前方一致については必須条件である。




### ラベルの登録と呼び出し


### 単語の登録と呼び出し




## ギャップ分析後の質問

### 実施済み修正（自明な修正、コミット済み）
- ✅ Core Design Decisions から項目6（フォールバック検索）、項目7（配置制約）を削除
- ✅ Requirement 1（単語定義の構文と解析）をパーサー層スコープとして削除
- ✅ Requirement番号を1→9に繰り上げ
- ✅ 各Requirementのパーサー関連ACを削除
- ✅ Requirement 4 AC3からフォールバック検索記述を削除
- ✅ RadixMap<Vec<usize>>の仕様確認・明確化
- ✅ トランスパイラー出力仕様を明記（`yield Talk(pasta_stdlib::word(...))`）

### 開発者確認が必要な項目（TODO）

#### TODO 1: トランスパイラー出力の修正指示 ✅ COMPLETED
- **実施内容**:
  - `src/transpiler/mod.rs` L448の出力を修正
  - `yield pasta_stdlib::word(ctx, "単語", []);` → `yield Talk(pasta_stdlib::word(ctx, "単語", []));`
  - コメント更新: "Word expansion: yield pasta_stdlib::word(...)" → "Word expansion: yield Talk(pasta_stdlib::word(...))"
- **テスト結果**: ✅ リグレッションなし
  - `cargo test`: 全テスト成功
  - `comprehensive_control_flow.transpiled.rn`: 自動生成・更新
  - 新出力確認: L9, L51-53で word() が Talk() で包まれていることを確認
- **コミット**: `feat: Wrap word() output in Talk() - トランスパイラー出力修正`

#### TODO 2: ctx.current_module の要件定義への追加 - ディスカッション開始
- **現状**: 
  - Requirement 2 AC5, AC6 で`ctx.current_module`を使用してローカルスコープ判定と記載
  - Requirement 4 AC8 で`(search_key, current_module)`をキャッシュキーとして使用と記載
- **問題**: ランタイムContext構造体に`current_module`フィールドが要件定義に明記されていない
- **選択肢**:
  - **A案**: Requirement 5 AC7（WordTable実装要件）に以下を追加
    ```
    The Pasta Runtime shall Context構造体にcurrent_module: Stringフィールドを追加する
    The Pasta Transpiler shall 関数呼び出しの開始時にctx.current_moduleをグローバルラベル名に設定する
    The Pasta Transpiler shall 関数終了時にctx.current_moduleを前の値に復元する（ネスト対応）
    ```
  - **B案**: 新しいRequirement として「Context拡張」を追加（Requirement 10）
  - **C案**: Requirement 3（会話内での単語参照）に統合
- **質問**: どのアプローチを選択すべきでしょうか？

#### TODO 3: Requirement 8 AC4 の設計変更への対応 ✅ COMPLETED
- **問題**: 
  - Requirement 8 AC4: 「フォールバック検索の順序を明記する（Rune変数/関数→単語辞書前方一致→前方一致ラベル）」
  - Requirement 4 でフォールバック検索を削除した（単語定義は前方一致のみ、フォールバックなし）
  - 矛盾: AC4がフォールバック検索の記述を求めているが、Requirement 4の設計でそれは不要
- **決定**: AC4を修正
  - 現在: 「フォールバック検索の順序を明記する...」
  - 修正後: 「単語辞書検索の前方一致ロジックを説明する（ローカル → グローバル統合マージ）」
- **実施内容**: requirements.md の Requirement 8 AC4 を更新
- **備考**: Requirement 9 AC9（サンプルスクリプト）の説明も「フォールバック」→「複合検索」に変更

#### TODO 4: 参照実装ファイルの同期確認 - 検討中
- **現状**: 
  - `comprehensive_control_flow.rn`（参照実装、手作業メンテナンス）: 最終更新 2025/12/16
  - `comprehensive_control_flow.transpiled.rn`（現トランスパイラー出力）: 最終更新 2025/12/20（修正済み）
  - 参照実装は老朽化（4日古い）かつスタイルが異なる（Actor/Talk関数の手作業定義 vs 自動生成）
- **選択肢**:
  - **A案**: 参照実装を削除・廃止化する
    - 理由: 自動生成される`.transpiled.rn`が常にシングルソースオブトゥルース
    - 手作業メンテナンスの負担を排除
    - テストは自動生成ファイルのパース確認に集中
  - **B案**: 参照実装を最新化し、テストとして位置づける
    - 参照実装 = 期待される出力の手作業リファレンス
    - テストで`.transpiled.rn`と比較・同期チェック
    - 手作業メンテナンスコストが高い
  - **C案**: 参照実装はライブドキュメントとして整理
    - mock関数を削除し、最小限の構造リファレンスのみ記載
    - コメントを充実させて使用例説明に特化
- **質問**: どのアプローチを選択すべきでしょうか？

---

## 設計分析後の質問

設計及び設計分析レポートを踏まえて、修正点・疑問点・不安点などを TODO にて収拾せよ。自明な修正点は修正してコミット。開発者への確認が少しでも必要な項目については、1 議題ずつディスカッションを進行せよ。議題が１つクローズするごとに更新しコミット、次の議題に移れ。更新するときは、これまでの議論で明らかになった点を書くとともに、不要になった要件の集約・削除なども行い、次の議題の提示前に修正内容の要約を報告してくださいね。

## 実装完了指示

実装完了を承認。ステアリングファイルをすべて読み込み、ワークフローに従って完了処理を行ってください。

## pasta XXXX

/kiro-spec-init
pastaスクリプトの説明となるGRAMMAR.mdが、現在の実装仕様から乖離している。現在実装されているpestによる定義から逆算し、文法設計を再度詰めなおしたい。成果物として以下の2つが必要。
1. 正確な文法を説明したもの。pest定義にコメントを付ける形でもよい。
2. GRAMMAR.md。一般向けに文法を説明するもの。


/kiro-spec-init
pasta エンジンに関する仕様。会話行中のインライン要素「＠会話
」について。たとえば「＠＠会話」となっているとき、

1. 最初の「＠会話」の単語解決
2. 解決した単語をキーワードにして単語解決
   の、２段構えの検索になってほしい。理論上は＠＠＠などの３段構え以上も可能と考えて仕様を検討。

## pasta XXXX

/kiro-spec-init
pasta エンジンに関する仕様。会話行中のインライン要素「＠会話」について。たとえば「＠＠会話」となっているとき、

1. 最初の「＠会話」の単語解決
2. 解決した単語をキーワードにして単語解決
   の、２段構えの検索になってほしい。理論上は＠＠＠などの３段構え以上も可能と考えて仕様を検討。

## pasta XXXX

/kiro-spec-init
pasta エンジンに関する仕様。チェイントーク（いったん会話を終了して次のトークに移る）ための IR は定義されているか。例えば「＠チェイン」または「＞チェイン」などとして関数を呼び出して、チェイントーク挿入が実現可能か。なお、すでに実現可能だと要件定義作成時調査で確認できた場合、本仕様は確認のみでクローズとする。要件定義指示の時に調査せよ。

## 確認

## 定型句

要件定義から不明瞭な点を TODO でリストアップし、議題を 1 つずつディスカッション進行して。議題がクローズしたら文書更新してコミット、次の議題へ。

分析結果の指摘点や不明瞭な点・決定が必要な点を TODO 抽出。
また、要件定義の「#### 出力例（リファレンス実装）」や「#### Acceptance Criteria」が、設計を詰めた結果食い違いが出ている。これらについては現在の設計が正だと考えられるため、要件定義の調整を含めてこれらも議題 TODO に含めよ。
自明な修正については議論を行わずに修正クローズ、開発者確認が必要な項目は 1 つずつディスカッション進行して。議題がクリアになったら文書更新してコミット、次の議題へ。議題クリアの判断は都度行って自律的に進めるように。

## セレクター API

### Call/Jump 行の変換

```pasta
  ？天気予報
```

```rune
  for a in pasta::jump(ctx, label, #{}, []) { yield a; }
```

### 利用方法(ctx.pasta API)

```rune
pub mod pasta{
  // Jump関数。Callとやることは同じ。callだけの実装でも可。
  pub fn pasta::jump(ctx, label, filters, args){
    let label = pasta::label_selector(label, filters)
    for a in label(ctx, args) { yield a; }
  }

  // rust側で登録するrune関数。ラベルから関数ポインタを返す。
  // global_label: string　      ⇒ グローバルラベル検索キー
  // local_label: Option<string> ⇒ ローカルラベル検索キー
  pub fn label_selector(label){
    let n = select_label_to_id(label, filters);
    match n {
        1 => crate::会話_1::__start__;
        2 => crate::会話_1::選択肢_1;
        3 => crate::会話_1::選択肢_2;
    }
  }

  // rust側で実装するrust関数。ラベルとfiltersから関数番号を返す。
  pub fn select_label_to_id(label, filters){
    1   // 現在は常に1を返す。
  }
}
```

### 実現したい検索方法

#### グローバルジャンプの場合

- **label_selector("会話",None)**
  ⇒ "会話" で始まるラベルを前方一致
  ⇒ 末尾が必ず`::__start__`であること。

#### ローカルジャンプの場合

-- **label_selector("会話\_1::選択肢", None)**
⇒ `mod 会話_1`の要素から、"選択肢"で始まるラベルを前方一致

### filters について

API 引数として予約。将来的にはフィルター条件をここに並べる。現在は無視してよいが、パラメーターとしては宣言してほしい。

## LabelRegistry でグローバル、ローカルを統一的に連番管理する方法

### グローバルの連番

("グローバルラベル名", "**start**")でキー

### ローカルの連番

("グローバルラベル名", "ローカルラベル名") でキー

### 同じグローバルラベルが複数あるが？

連番が重複しないことさえ保証すればよいので、実用上は困らない。fn_path が少し長くなる弊害は発生するがそれだけといえばそれだけ。
