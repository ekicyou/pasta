<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 - Section 4.7</title>
</head>
<body>
<h2>4.7 – <a name="4.7">デバッグインターフェース</a></h2>

<p>Lua には組み込みのデバッグ機能はありません。代わりに、関数と<em>フック</em>による特別なインターフェースを提供します。このインターフェースを使用すると、さまざまな種類のデバッガ、プロファイラ、およびインタープリタからの「内部情報」を必要とするその他のツールを構築できます。</p><hr /><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  size_t srclen;              /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  unsigned short ftransfer;   /* (r) index of first value transferred */
  unsigned short ntransfer;   /* (r) number of transferred values */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>関数またはアクティベーションレコードに関するさまざまな情報を伝達するために使用される構造体。<a href="#lua_getstack"><code>lua_getstack</code></a> は、後で使用するために、この構造体のプライベート部分のみを埋めます。 <a href="#lua_Debug"><code>lua_Debug</code></a> の他のフィールドを有用な情報で埋めるには、適切なパラメータを使用して <a href="#lua_getinfo"><code>lua_getinfo</code></a> を呼び出す必要があります。（具体的には、フィールドを取得するには、フィールドのコメント内の括弧で囲まれた文字を <a href="#lua_getinfo"><code>lua_getinfo</code></a> のパラメータ <code>what</code> に追加する必要があります。）</p><p><a href="#lua_Debug"><code>lua_Debug</code></a> のフィールドには次の意味があります</p><ul>

<li><b><code>source</code>: </b> 関数を作成したチャンクのソース。<code>source</code> が '<code>@</code>' で始まる場合、関数がファイル内で定義されたことを意味し、ファイル名は '<code>@</code>' の後に続きます。<code>source</code> が '<code>=</code>' で始まる場合、そのコンテンツの残りはユーザーに依存する方法でソースを記述します。それ以外の場合、関数は文字列で定義され、<code>source</code> はその文字列です。</li>

<li><b><code>srclen</code>: </b> 文字列 <code>source</code> の長さ。</li>

<li><b><code>short_src</code>: </b> エラーメッセージで使用される <code>source</code> の「印刷可能な」バージョン。</li>

<li><b><code>linedefined</code>: </b> 関数の定義が始まる行番号。</li>

<li><b><code>lastlinedefined</code>: </b> 関数の定義が終わる行番号。</li>

<li><b><code>what</code>: </b> 関数が Lua 関数の場合は文字列 <code>"Lua"</code>、C 関数の場合は <code>"C"</code>、チャンクのメイン部分の場合は <code>"main"</code>。</li>

<li><b><code>currentline</code>: </b> 与えられた関数が実行されている現在の行。行情報がない場合、<code>currentline</code> は -1 に設定されます。</li>

<li><b><code>name</code>: </b> 与えられた関数の適切な名前。Lua の関数はファーストクラスの値であるため、固定された名前はありません。一部の関数は複数のグローバル変数の値になることがあり、他の関数はテーブルフィールドにのみ格納できます。 <code>lua_getinfo</code> 関数は、関数がどのように呼び出されたかを調べて適切な名前を見つけます。名前が見つからない場合、<code>name</code> は <code>NULL</code> に設定されます。</li>

<li><b><code>namewhat</code>: </b> <code>name</code> フィールドを説明します。 <code>namewhat</code> の値は、関数がどのように呼び出されたかに応じて、<code>"global"</code>、<code>"local"</code>、<code>"method"</code>、<code>"field"</code>、<code>"upvalue"</code>、または <code>""</code>（空文字列）のいずれかになります。（Lua は他のオプションが適用されないと思われる場合、空文字列を使用します。）</li>

<li><b><code>istailcall</code>: </b> この関数の呼び出しが末尾呼び出しによって呼び出された場合は true。この場合、このレベルの呼び出し元はスタックにありません。</li>

<li><b><code>nups</code>: </b> 関数のアップバリューの数。</li>

<li><b><code>nparams</code>: </b> 関数のパラメータの数 (C 関数の場合は常に 0)。</li>

<li><b><code>isvararg</code>: </b> 関数が可変長引数関数の場合 true (C 関数の場合は常に true)。</li>

<li><b><code>ftransfer</code>: </b> 「転送」される最初の値、つまり呼び出しのパラメータまたは戻り値のスタック内のインデックス。(他の値は連続したインデックスにあります。) このインデックスを使用すると、<a href="#lua_getlocal"><code>lua_getlocal</code></a> および <a href="#lua_setlocal"><code>lua_setlocal</code></a> を介してこれらの値にアクセスして変更できます。このフィールドは、呼び出しフック中に最初のパラメータを示す場合、または返される最初の値を示す戻りフック中にのみ意味があります。（呼び出しフックの場合、この値は常に 1 です。）</li>

<li><b><code>ntransfer</code>: </b> 転送される値の数 (前の項目を参照)。(Lua 関数の呼び出しの場合、この値は常に <code>nparams</code> と等しくなります。)</li>

</ul>




<hr /><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>現在のフック関数を返します。</p><hr /><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookcount (lua_State *L);</pre>

<p>現在のフックカウントを返します。</p><hr /><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_gethookmask (lua_State *L);</pre>

<p>現在のフックマスクを返します。</p><hr /><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
</p><pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>特定の関数または関数の呼び出しに関する情報を取得します。</p><p>関数の呼び出しに関する情報を取得するには、パラメータ<code>ar</code>は、以前の<a href="#lua_getstack"><code>lua_getstack</code></a>の呼び出しによって入力されたか、フックへの引数として渡された有効なアクティベーションレコードでなければなりません（<a href="#lua_Hook"><code>lua_Hook</code></a>を参照）。</p><p>関数に関する情報を取得するには、その関数をスタックにプッシュし、<code>what</code>文字列を文字'<code>&gt;</code>'で開始します。（この場合、<code>lua_getinfo</code>はスタックのトップから関数をポップします。）たとえば、関数<code>f</code>が定義された行を知るには、次のコードを記述できます。</p><pre>     lua_Debug ar;
     lua_getglobal(L, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>文字列<code>what</code>の各文字は、構造体<code>ar</code>のいくつかのフィールドを埋めるか、スタックにプッシュする値を選択します。（これらの文字は、構造体<a href="#lua_Debug"><code>lua_Debug</code></a>の宣言でも、各フィールドに続くコメントの括弧内にドキュメント化されています。）</p><ul>

<li><b>'<code>f</code>'：</b> 指定されたレベルで実行中の関数をスタックにプッシュします。</li>

<li><b>'<code>l</code>'：</b> フィールド<code>currentline</code>を埋めます。</li>

<li><b>'<code>n</code>'：</b> フィールド<code>name</code>および<code>namewhat</code>を埋めます。</li>

<li><b>'<code>r</code>'：</b> フィールド<code>ftransfer</code>および<code>ntransfer</code>を埋めます。</li>

<li><b>'<code>S</code>'：</b> フィールド<code>source</code>、<code>short_src</code>、<code>linedefined</code>、<code>lastlinedefined</code>、および<code>what</code>を埋めます。</li>

<li><b>'<code>t</code>'：</b> フィールド<code>istailcall</code>を埋めます。</li>

<li><b>'<code>u</code>'：</b> フィールド<code>nups</code>、<code>nparams</code>、および<code>isvararg</code>を埋めます。</li>

<li><b>'<code>L</code>'：</b> インデックスが、関連付けられたコードを持つ関数の行、つまりブレークポイントを設定できる行であるテーブルをスタックにプッシュします。（コードのない行には、空行とコメントが含まれます。）このオプションをオプション'<code>f</code>'とともに指定すると、そのテーブルは関数の後にプッシュされます。これは、メモリエラーが発生する可能性のある唯一のオプションです。</li>

</ul>

<p>この関数は、<code>what</code>に無効なオプションがあることを示すために0を返します。それでも、有効なオプションは正しく処理されます。</p><hr /><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>指定されたアクティベーションレコードまたは指定された関数のローカル変数または一時的な値に関する情報を取得します。</p><p>最初の場合、パラメータ<code>ar</code>は、以前の<a href="#lua_getstack"><code>lua_getstack</code></a>の呼び出しによって入力されたか、フックへの引数として渡された有効なアクティベーションレコードでなければなりません（<a href="#lua_Hook"><code>lua_Hook</code></a>を参照）。インデックス<code>n</code>は、検査するローカル変数を指定します。変数インデックスと名前の詳細については、<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>を参照してください。</p><p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a>は、変数の値をスタックにプッシュし、その名前を返します。</p><p>2番目のケースでは、<code>ar</code>は<code>NULL</code>でなければならず、検査する関数はスタックの最上位になければなりません。この場合、Lua関数のパラメータのみが表示され（アクティブな変数の情報がないため）、スタックには値がプッシュされません。</p><p>インデックスがアクティブなローカル変数の数よりも大きい場合は、<code>NULL</code>を返します（何もプッシュしません）。</p><hr /><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>インタープリターのランタイムスタックに関する情報を取得します。</p><p>この関数は、指定されたレベルで実行中の関数の*アクティベーションレコード*の識別を使用して<a href="#lua_Debug"><code>lua_Debug</code></a>構造体の一部を埋めます。レベル0は現在実行中の関数であり、レベル*n+1*はレベル*n*を呼び出した関数です（スタックにカウントされない末尾呼び出しを除く）。スタックの深さよりも大きいレベルで呼び出されると、<a href="#lua_getstack"><code>lua_getstack</code></a>は0を返します。それ以外の場合は1を返します。</p><hr /><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), –]</span>
</p><pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>インデックス<code>funcindex</code>にあるクロージャの<code>n</code>番目のアップバリューに関する情報を取得します。アップバリューの値をスタックにプッシュし、その名前を返します。インデックス<code>n</code>がアップバリューの数よりも大きい場合は、<code>NULL</code>を返します（何もプッシュしません）。</p><p>アップバリューの詳細については、<a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a>を参照してください。</p><hr /><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>デバッグフック関数の型。</p><p>フックが呼び出されるたびに、その<code>ar</code>引数のフィールド<code>event</code>には、フックをトリガーした特定のイベントが設定されます。Luaは、これらのイベントを次の定数で識別します：<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>、<a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>、<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>、<a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>、および<a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>。さらに、行イベントの場合、フィールド<code>currentline</code>も設定されます。<code>ar</code>の他のフィールドの値を取得するには、フックは<a href="#lua_getinfo"><code>lua_getinfo</code></a>を呼び出す必要があります。</p><p>呼び出しイベントの場合、<code>event</code>は通常の値である<code>LUA_HOOKCALL</code>、または末尾呼び出しの場合は<code>LUA_HOOKTAILCALL</code>にすることができます。この場合、対応する戻りイベントはありません。</p><p>Luaがフックを実行している間、フックへの他の呼び出しは無効になります。したがって、フックがLuaを呼び出して関数またはチャンクを実行する場合、この実行はフックへの呼び出しなしで発生します。</p><p>フック関数は継続を持つことができません。つまり、nullでない<code>k</code>で<a href="#lua_yieldk"><code>lua_yieldk</code></a>、<a href="#lua_pcallk"><code>lua_pcallk</code></a>、または<a href="#lua_callk"><code>lua_callk</code></a>を呼び出すことはできません。</p><p>フック関数は、次の条件でyieldできます。カウントイベントと行イベントのみがyieldできます。yieldするには、フック関数は、<code>nresults</code>がゼロ（つまり、値がない）である<a href="#lua_yield"><code>lua_yield</code></a>を呼び出して実行を終了する必要があります。</p><hr /><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>デバッグフック関数を設定します。</p><p>引数<code>f</code>はフック関数です。<code>mask</code>は、フックが呼び出されるイベントを指定します。これは、定数<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>、<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>、<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>、および<a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>のビットごとのORで形成されます。<code>count</code>引数は、マスクに<code>LUA_MASKCOUNT</code>が含まれている場合にのみ意味があります。各イベントについて、フックは以下で説明するように呼び出されます。</p><ul>

<li><b>呼び出しフック：</b> インタープリターが関数を呼び出すときに呼び出されます。フックは、Luaが新しい関数に入った直後に呼び出されます。</li>

<li><b>戻りフック：</b> インタープリターが関数から戻るときに呼び出されます。フックは、Luaが関数を離れる直前に呼び出されます。</li>

<li><b>行フック：</b> インタープリターが新しいコード行の実行を開始しようとしているとき、またはコード内で（同じ行にでも）戻るときに呼び出されます。このイベントは、LuaがLua関数を実行している間のみ発生します。</li>

<li><b>カウントフック：</b> インタープリターが<code>count</code>命令を実行するたびに呼び出されます。このイベントは、LuaがLua関数を実行している間のみ発生します。</li>

</ul>

<p>フックは、<code>mask</code>をゼロに設定することで無効になります。</p><hr /><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>指定されたアクティベーションレコードのローカル変数の値を設定します。スタックの最上位の値を変数に割り当て、その名前を返します。また、スタックから値をポップします。</p><p>インデックスがアクティブなローカル変数の数よりも大きい場合は、<code>NULL</code>を返します（何もポップしません）。</p><p>パラメータ<code>ar</code>および<code>n</code>は、関数<a href="#lua_getlocal"><code>lua_getlocal</code></a>と同じです。</p><hr /><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, –]</span>
</p><pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>クロージャのアップバリューの値を設定します。スタックの最上位の値をアップバリューに割り当て、その名前を返します。また、スタックから値をポップします。</p><p>インデックス<code>n</code>がアップバリューの数よりも大きい場合は、<code>NULL</code>を返します（何もポップしません）。</p><p>パラメータ<code>funcindex</code>および<code>n</code>は、関数<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>と同じです。</p><hr /><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>インデックス<code>funcindex</code>にあるクロージャの<code>n</code>番目のアップバリューの一意の識別子を返します。</p><p>これらの固有の識別子により、プログラムは異なるクロージャがアップバリューを共有しているかどうかを確認できます。アップバリューを共有する（つまり、同じ外部ローカル変数にアクセスする）Luaクロージャは、それらのアップバリューインデックスに対して同一のIDを返します。</p><p>パラメータ<code>funcindex</code>および<code>n</code>は、関数<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>と同じですが、<code>n</code>はアップバリューの数よりも大きくすることはできません。</p><hr /><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, –]</span>
</p><pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>インデックス<code>funcindex1</code>にあるLuaクロージャの<code>n1</code>番目のアップバリューを、インデックス<code>funcindex2</code>にあるLuaクロージャの<code>n2</code>番目のアップバリューを参照するようにします。</p>

</body>
</html>
