<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 - Section 4.1</title>
</head>
<body>
<h2>4.1 – <a name="4.1">スタック</a></h2>



<p>Lua は、値を C との間で受け渡すために、<em>仮想スタック</em>を使用します。このスタック内の各要素は、Lua 値（<b>nil</b>、数値、文字列など）を表します。API 内の関数は、受け取る Lua ステートパラメータを介してこのスタックにアクセスできます。</p><p>LuaがCを呼び出すたびに、呼び出された関数は新しいスタックを取得します。このスタックは、以前のスタックや、まだアクティブなC関数のスタックとは独立しています。このスタックには、最初にC関数への引数が含まれており、C関数は一時的なLua値を保存し、呼び出し元に返される結果をプッシュする必要があります（<a href="#lua_CFunction"><code>lua_CFunction</code></a>を参照）。</p><p>便宜上、APIのほとんどのクエリ操作は厳密なスタック規律に従いません。代わりに、<em>インデックス</em>を使用してスタック内の任意の要素を参照できます。正のインデックスは絶対スタック位置を表し、スタックの底を1として始まります。負のインデックスは、スタックの最上部を基準としたオフセットを表します。より具体的には、スタックに<em>n</em>個の要素がある場合、インデックス1は最初の要素（つまり、最初にスタックにプッシュされた要素）を表し、インデックス<em>n</em>は最後の要素を表します。インデックス-1も最後の要素（つまり、最上部の要素）を表し、インデックス-<em>n</em>は最初の要素を表します。</p><h3>4.1.1 – <a name="4.1.1">スタックサイズ</a></h3>

<p>Lua APIを操作するときは、一貫性を確保する責任があります。特に、<em>スタックオーバーフローを制御する責任があります</em>。API関数を呼び出すときは、スタックに結果を格納するのに十分な空き容量があることを確認する必要があります。</p><p>上記ルールには1つの例外があります。結果の数が固定されていないLua関数を呼び出す場合（<a href="#lua_call"><code>lua_call</code></a>を参照）、Luaはスタックにすべての結果を格納するのに十分なスペースがあることを保証します。ただし、追加のスペースは保証しません。したがって、このような呼び出しの後にスタックに何かをプッシュする前に、<a href="#lua_checkstack"><code>lua_checkstack</code></a>を使用する必要があります。</p><p>LuaがCを呼び出すたびに、スタックに少なくとも<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>個の追加要素のためのスペースがあることを保証します。つまり、最大で<code>LUA_MINSTACK</code>個の値を安全にプッシュできます。<code>LUA_MINSTACK</code>は20として定義されているため、コードが要素をスタックにプッシュするループがない限り、通常はスタック領域を気にする必要はありません。必要に応じて、関数<a href="#lua_checkstack"><code>lua_checkstack</code></a>を使用して、スタックに新しい要素をプッシュするための十分なスペースがあることを確認できます。</p><h3>4.1.2 – <a name="4.1.2">有効なインデックスと許容可能なインデックス</a></h3>

<p>スタックインデックスを受け取るAPIの関数は、<em>有効なインデックス</em>または<em>許容可能なインデックス</em>でのみ機能します。</p><p><em>有効なインデックス</em>とは、変更可能なLua値を格納する位置を参照するインデックスです。これは、1からスタックの最上部（<code>1 ≤ abs(index) ≤ top</code>）までのスタックインデックスと、Cコードからアクセスできるがスタックにはないいくつかの位置を表す<em>擬似インデックス</em>で構成されます。擬似インデックスは、レジストリ（<a href="#4.3">§4.3</a>を参照）とC関数のアップバリュー（<a href="#4.2">§4.2</a>を参照）にアクセスするために使用されます。</p><p>特定の変更可能な位置を必要とせず、値のみを必要とする関数（クエリ関数など）は、許容可能なインデックスで呼び出すことができます。<em>許容可能なインデックス</em>は、有効なインデックスのいずれかですが、スタック用に割り当てられた領域内のスタックの最上部より後の任意の正のインデックス、つまりスタックサイズまでのインデックスにすることもできます。（0は許容可能なインデックスではないことに注意してください。）現在のC関数の実際のアップバリュー数よりも大きいアップバリュー（<a href="#4.2">§4.2</a>を参照）へのインデックスも許容されます（ただし、無効です）。特に記載がない限り、APIの関数は許容可能なインデックスで動作します。</p><p>許容可能なインデックスは、スタックをクエリするときにスタックの最上部に対する追加のテストを回避するのに役立ちます。たとえば、C関数は、3番目の引数があるかどうかを確認する必要なく、つまり3が有効なインデックスであるかどうかを確認する必要なく、3番目の引数をクエリできます。</p><p>許容可能なインデックスで呼び出すことができる関数の場合、無効なインデックスは、仮想型<a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>の値を含むかのように扱われ、これはnil値のように動作します。</p><h3>4.1.3 – <a name="4.1.3">文字列へのポインタ</a></h3>

<p>APIのいくつかの関数は、スタック内のLua文字列へのポインタ（<code>const char*</code>）を返します。（<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>、<a href="#lua_pushlstring"><code>lua_pushlstring</code></a>、<a href="#lua_pushstring"><code>lua_pushstring</code></a>、<a href="#lua_tolstring"><code>lua_tolstring</code></a>を参照。また、補助ライブラリの<a href="#luaL_checklstring"><code>luaL_checklstring</code></a>、<a href="#luaL_checkstring"><code>luaL_checkstring</code></a>、<a href="#luaL_tolstring"><code>luaL_tolstring</code></a>も参照）。</p><p>一般に、Luaのガベージコレクションは内部メモリを解放または移動し、内部文字列へのポインタを無効にする可能性があります。これらのポインタを安全に使用できるように、APIは、スタックインデックスの文字列へのポインタは、そのインデックスの文字列値がスタックから削除されない限り有効であることを保証します。（ただし、別のインデックスに移動することはできます。）インデックスが（アップバリューを参照する）擬似インデックスである場合、ポインタは、対応する呼び出しがアクティブであり、対応するアップバリューが変更されない限り有効です。</p><p>デバッグインターフェースの一部の関数も、<a href="#lua_getlocal"><code>lua_getlocal</code></a>、<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>、<a href="#lua_setlocal"><code>lua_setlocal</code></a>、<a href="#lua_setupvalue"><code>lua_setupvalue</code></a>など、文字列へのポインタを返します。これらの関数では、呼び出し元の関数がアクティブであり、指定されたクロージャ（指定されている場合）がスタック内にある限り、ポインタが有効であることが保証されます。</p><p>これらの保証を除いて、ガベージコレクタは内部文字列へのポインタを自由に無効にすることができます。</p>
</body>
</html>
