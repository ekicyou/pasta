<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 Reference Manual - Chapter 03</title>
</head>
<body>
<h1>3 – <a name="3">言語</a></h1>



<p>このセクションでは、Luaの語彙、構文、および意味について説明します。言い換えれば、このセクションでは、どのトークンが有効か、それらをどのように組み合わせることができるか、およびそれらの組み合わせが何を意味するかについて説明します。</p><p>言語構成は、通常の拡張BNF表記を使用して説明されます。{<em>a</em>}は0個以上の<em>a</em>を意味し、[<em>a</em>]はオプションの<em>a</em>を意味します。非終端記号は非終端記号のように表示され、キーワードは<b>kword</b>のように表示され、その他の終端記号は「<b>=</b>」のように表示されます。Luaの完全な構文は、このマニュアルの最後に<a href="#9">§9</a>にあります。</p><h2>3.1 – <a name="3.1">字句規則</a></h2>

<p>Luaは自由形式の言語です。2つのトークン間の区切り文字として以外は、字句要素（トークン）間のスペースとコメントを無視します。ソースコードでは、Luaは標準ASCII空白文字（スペース、改ページ、改行、復帰、水平タブ、垂直タブ）をスペースとして認識します。</p><p>
Luaの<em>名前</em>（<em>識別子</em>とも呼ばれる）は、ラテン文字、アラビア数字、およびアンダースコアで構成される任意の文字列で、数字で始まらず、予約語でないものであれば使用できます。識別子は、変数、テーブルフィールド、およびラベルに名前を付けるために使用されます。</p><p>次の<em>キーワード</em>は予約されており、名前として使用することはできません。</p><pre>     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>Luaは大文字と小文字を区別する言語です。<code>and</code>は予約語ですが、<code>And</code>と<code>AND</code>は2つの異なる有効な名前です。慣例として、プログラムはアンダースコアと1つ以上の大文字（<a href="#pdf-_VERSION"><code>_VERSION</code></a>など）で始まる名前の作成を避ける必要があります。</p><p>次の文字列は、他のトークンを示します</p><pre>     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p><em>短いリテラル文字列</em>は、一致する単一引用符または二重引用符で区切ることができ、次のCのようなエスケープシーケンスを含めることができます。 '<code>\a</code>' (ベル)、'<code>\b</code>' (バックスペース)、'<code>\f</code>' (改ページ)、'<code>\n</code>' (改行)、'<code>\r</code>' (復帰)、'<code>\t</code>' (水平タブ)、'<code>\v</code>' (垂直タブ)、'<code>\\</code>' (バックスラッシュ)、'<code>\"</code>' (引用符 [二重引用符])、および '<code>\'</code>' (アポストロフィ [単一引用符])。バックスラッシュの後に改行が続くと、文字列内の改行になります。エスケープシーケンス '<code>\z</code>' は、改行を含む後続の空白文字スパンをスキップします。これは、文字列の内容に改行やスペースを追加せずに、長いリテラル文字列を複数行に分割してインデントするのに特に役立ちます。短いリテラル文字列には、エスケープされていない改行や、有効なエスケープシーケンスを形成しないエスケープを含めることはできません。</p><p>埋め込まれたゼロを含む、短いリテラル文字列内の任意のバイトを、その数値で指定できます。これは、エスケープシーケンス <code>\x<em>XX</em></code>（<em>XX</em>は2つの16進数）またはエスケープシーケンス <code>\<em>ddd</em></code>（<em>ddd</em>は最大3つの10進数）を使用して行うことができます。（10進数のエスケープシーケンスの後に数字が続く場合は、正確に3桁で表現する必要があることに注意してください。）</p><p>Unicode文字のUTF-8エンコードは、エスケープシーケンス<code>\u{<em>XXX</em>}</code>（必須の括弧で囲む）を使用してリテラル文字列に挿入できます。ここで、<em>XXX</em>は文字コードポイントを表す1つ以上の16進数です。このコードポイントは、<em>2<sup>31</sup></em>未満の値にすることができます。（Luaはここで元のUTF-8仕様を使用しており、有効なUnicodeコードポイントに限定されません。）</p><p>リテラル文字列は、<em>長い括弧</em>で囲まれた長い形式を使用して定義することもできます。レベル<em>n</em>の<em>開始長い括弧</em>を、左角括弧の後に<em>n</em>個の等号が続き、その後に別の左角括弧が続くものとして定義します。したがって、レベル0の開始長い括弧は<code>[[</code>と記述され、レベル1の開始長い括弧は<code>[=[</code>と記述されます。<em>終了長い括弧</em>も同様に定義されます。たとえば、レベル4の終了長い括弧は<code>]====]</code>と記述されます。<em>長いリテラル</em>は、任意のレベルの開始長い括弧で始まり、同じレベルの最初の終了長い括弧で終わります。同じレベルの終了括弧を除く任意のテキストを含めることができます。この括弧形式のリテラルは、複数行にまたがることができ、エスケープシーケンスを解釈せず、他のレベルの長い括弧を無視します。あらゆる種類の行末シーケンス（復帰、改行、復帰に続く改行、または改行に続く復帰）は、単純な改行に変換されます。開始長い括弧の直後に改行が続く場合、その改行は文字列に含まれません。</p><p>例として、ASCIIを使用するシステム（ '<code>a</code>' が97、改行が10、 '<code>1</code>' が49としてコード化されている）では、以下の5つのリテラル文字列は同じ文字列を表します</p><pre>     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>前の規則によって明示的に影響を受けないリテラル文字列内の任意のバイトは、それ自身を表します。ただし、Luaは解析のためにテキストモードでファイルを開き、システムのファイル関数は一部の制御文字で問題が発生する可能性があります。したがって、バイナリデータは、テキスト以外の文字に対して明示的なエスケープシーケンスを使用する引用符付きリテラルとして表現する方が安全です。</p><p><em>数値定数</em>（または<em>数詞</em>）は、オプションの小数部と、文字 '<code>e</code>' または '<code>E</code>' でマークされたオプションの10進指数で記述できます。Luaは、<code>0x</code>または<code>0X</code>で始まる16進定数も受け入れます。16進定数は、オプションの小数部と、文字 '<code>p</code>' または '<code>P</code>' でマークされ、10進数で記述されたオプションのバイナリ指数も受け入れます。（たとえば、<code>0x1.fp10</code>は1984を示し、これは<em>0x1f / 16</em>に<em>2<sup>10</sup></em>を乗じたものです。）</p><p>基数点または指数を持つ数値定数は浮動小数点数を表します。それ以外の場合、その値が整数に適合するか、16進定数である場合は、整数を表します。それ以外の場合（つまり、オーバーフローする10進数の整数）、浮動小数点数を表します。基数点も指数もない16進数は常に整数値を表します。値がオーバーフローすると、有効な整数に収まるように<em>ラップアラウンド</em>します。</p><p>有効な整数定数の例を次に示します</p><pre>     3   345   0xff   0xBEBADA
</pre><p>有効な浮動小数点定数の例を次に示します</p><pre>     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p><em>コメント</em>は、文字列の外側の任意の場所で二重ハイフン（<code>--</code>）で始まります。<code>--</code>の直後のテキストが開始長い括弧でない場合、コメントは<em>短いコメント</em>であり、行末まで実行されます。それ以外の場合、<em>長いコメント</em>であり、対応する終了長い括弧まで実行されます。</p><h2>3.2 – <a name="3.2">変数</a></h2>

<p>変数は値を格納する場所です。Luaには、グローバル変数、ローカル変数、およびテーブルフィールドの3種類の変数があります。</p><p>単一の名前は、グローバル変数またはローカル変数（または、ローカル変数の特定の種類の関数の仮パラメータ）を表すことができます。</p><pre>	var ::= Name
</pre><p>名前は識別子を示します（<a href="#3.1">§3.1</a>を参照）。</p><p>明示的にローカルとして宣言されない限り、すべての変数名はグローバルであるとみなされます（<a href="#3.3.7">§3.3.7</a>参照）。ローカル変数は<em>レキシカルスコープ</em>を持ちます。ローカル変数は、そのスコープ内で定義された関数から自由にアクセスできます（<a href="#3.5">§3.5</a>参照）。</p><p>変数への最初の代入が行われる前、その値は<b>nil</b>です。</p><p>角括弧は、テーブルのインデックス付けに使用されます。</p><pre>	var ::= prefixexp ‘<b>[</b>’ exp ‘<b>]</b>’
</pre><p>テーブルフィールドへのアクセスは、メタテーブルを介して意味を変更できます（<a href="#2.4">§2.4</a>参照）。</p><p>構文<code>var.Name</code>は、<code>var["Name"]</code>のシンタックスシュガーです。</p><pre>	var ::= prefixexp ‘<b>.</b>’ Name
</pre>

<p>グローバル変数<code>x</code>へのアクセスは、<code>_ENV.x</code>と同等です。チャンクのコンパイル方法により、変数<code>_ENV</code>自体は決してグローバルではありません（<a href="#2.2">§2.2</a>参照）。</p><h2>3.3 – <a name="3.3">ステートメント</a></h2>



<p>Luaは、他の一般的な言語と同様の、ほぼ従来のステートメントセットをサポートしています。このセットには、ブロック、代入、制御構造、関数呼び出し、変数宣言が含まれます。</p><h3>3.3.1 – <a name="3.3.1">ブロック</a></h3>

<p>ブロックはステートメントのリストであり、順次実行されます。</p><pre>	block ::= {stat}
</pre><p>Luaには、ステートメントをセミコロンで区切ったり、セミコロンでブロックを開始したり、セミコロンを2つ続けて記述したりできる、<em>空のステートメント</em>があります。</p><pre>	stat ::= ‘<b>;</b>’
</pre>

<p>関数呼び出しと代入の両方が、開き括弧で始まることができます。この可能性は、Luaの文法にあいまいさを生じさせます。次のフラグメントを考えてみましょう。</p><pre>     a = b + c
     (print or io.write)('done')
</pre><p>文法は、このフラグメントを2つの方法で見ることができます。</p><pre>     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>現在のパーサーは、常にこのような構造を最初の方法で見て、開き括弧を呼び出しの引数の開始として解釈します。このあいまいさを避けるために、括弧で始まるステートメントの前には常にセミコロンを付けるのが良い習慣です。</p><pre>     ;(print or io.write)('done')
</pre>

<p>ブロックを明示的に区切って、単一のステートメントを作成できます。</p><pre>	stat ::= <b>do</b> block <b>end</b>
</pre><p>明示的なブロックは、変数宣言のスコープを制御するのに役立ちます。明示的なブロックは、別のブロックの途中に<b>return</b>ステートメントを追加するためにも使用されることがあります（<a href="#3.3.4">§3.3.4</a>参照）。</p><h3>3.3.2 – <a name="3.3.2">チャンク</a></h3>

<p>Luaのコンパイル単位は、<em>チャンク</em>と呼ばれます。構文的には、チャンクは単なるブロックです。</p><pre>	chunk ::= block
</pre>

<p>Luaは、チャンクを可変数の引数を持つ匿名関数の本体として扱います（<a href="#3.4.11">§3.4.11</a>参照）。そのため、チャンクはローカル変数を定義したり、引数を受け取ったり、値を返したりできます。さらに、そのような匿名関数は、<code>_ENV</code>と呼ばれる外部ローカル変数のスコープ内でコンパイルされます（<a href="#2.2">§2.2</a>参照）。結果の関数は、その変数を使用しなくても、常に<code>_ENV</code>を唯一の外部変数として持ちます。</p><p>チャンクは、ファイルまたはホストプログラム内の文字列に格納できます。チャンクを実行するために、Luaはまずチャンクを<em>ロード</em>し、チャンクのコードを仮想マシンの命令にプリコンパイルします。次に、Luaは仮想マシンのインタープリターを使用して、コンパイルされたコードを実行します。</p><p>チャンクはバイナリ形式にプリコンパイルすることもできます。詳細については、プログラム<code>luac</code>および関数<a href="#pdf-string.dump"><code>string.dump</code></a>を参照してください。ソース形式とコンパイル形式のプログラムは交換可能です。Luaはファイルタイプを自動的に検出して、それに応じて動作します（<a href="#pdf-load"><code>load</code></a>を参照）。</p><h3>3.3.3 – <a name="3.3.3">代入</a></h3>

<p>Luaでは、複数の代入が可能です。したがって、代入の構文では、左側に変数のリスト、右側に式のリストを定義します。両方のリストの要素は、カンマで区切られます。</p><pre>	stat ::= varlist ‘<b>=</b>’ explist
	varlist ::= var {‘<b>,</b>’ var}
	explist ::= exp {‘<b>,</b>’ exp}
</pre><p>式については、<a href="#3.4">§3.4</a>で説明します。</p><p>代入の前に、値のリストは変数のリストの長さに<em>調整</em>されます（<a href="#3.4.12">§3.4.12</a>参照）。</p><p>複数の代入の中で変数が代入と読み取りの両方を行っている場合、Luaはすべての読み取りが代入前の変数の値を取得するようにします。したがって、次のコード</p><pre>     i = 3
     i, a[i] = i+1, 20
</pre><p>は、<code>a[i]</code>の<code>i</code>が（4が代入される前に）3と評価されるため、<code>a[3]</code>を20に設定し、<code>a[4]</code>には影響を与えません。同様に、次の行</p><pre>     x, y = y, x
</pre><p>は、<code>x</code>と<code>y</code>の値を交換し、</p><pre>     x, y, z = y, z, x
</pre><p>は、<code>x</code>、<code>y</code>、および<code>z</code>の値を循環的に並べ替えます。</p><p>この保証は、代入ステートメントの構文内のアクセスのみを対象としていることに注意してください。代入中に呼び出された関数またはメタメソッドが変数の値を変更した場合、Luaはそのアクセスの順序について保証しません。</p><p>グローバル名<code>x = val</code>への代入は、代入<code>_ENV.x = val</code>と同等です（<a href="#2.2">§2.2</a>参照）。</p><p>テーブルフィールドとグローバル変数（実際にはテーブルフィールドでもあります）への代入の意味は、メタテーブルを介して変更できます（<a href="#2.4">§2.4</a>参照）。</p><h3>3.3.4 – <a name="3.3.4">制御構造</a></h3><p>制御構造<b>if</b>、<b>while</b>、および<b>repeat</b>は、通常の意味と使い慣れた構文を持ちます。</p><pre>	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>Luaには、2つの形式の<b>for</b>ステートメントもあります（<a href="#3.3.5">§3.3.5</a>参照）。</p><p>制御構造の条件式は、任意の値 を返すことができます。<b>false</b>と<b>nil</b>の両方がfalseとして評価されます。<b>nil</b>と<b>false</b>以外のすべての値はtrueとして評価されます。特に、数値の0と空の文字列もtrueとして評価されます。</p><p><b>repeat</b>-<b>until</b>ループでは、内部ブロックは<b>until</b>キーワードでは終了せず、条件の後でのみ終了します。したがって、条件はループブロック内で宣言されたローカル変数を参照できます。</p><p><b>goto</b>ステートメントは、プログラム制御をラベルに転送します。構文上の理由から、Luaのラベルもステートメントと見なされます。</p><pre>	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= ‘<b>::</b>’ Name ‘<b>::</b>’
</pre>

<p>ラベルは、ネストされた関数内を除き、定義されているブロック全体で可視になります。gotoは、ローカル変数のスコープに入らない限り、任意の可視ラベルにジャンプできます。ラベルは、同じ名前のラベルが可視になっている場合は、たとえこの他のラベルが外側のブロックで宣言されている場合でも、宣言しないでください。</p><p><b>break</b>ステートメントは、<b>while</b>、<b>repeat</b>、または<b>for</b>ループの実行を終了し、ループ後の次のステートメントにスキップします。</p><pre>	stat ::= <b>break</b>
</pre><p><b>break</b>は、最も内側の囲みループを終了します。</p><p><b>return</b>ステートメントは、関数またはチャンク（匿名関数として扱われます）から値を返すために使用されます。関数は複数の値を返すことができるため、<b>return</b>ステートメントの構文は次のようになります。</p><pre>	stat ::= <b>return</b> [explist] [‘<b>;</b>’]
</pre>

<p><b>return</b>ステートメントは、ブロックの最後のステートメントとしてのみ記述できます。ブロックの途中で<b>return</b>する必要がある場合は、慣用句<code>do return end</code>のように、明示的な内部ブロックを使用できます。これは、<b>return</b>が（内部）ブロックの最後のステートメントになるためです。</p><h3>3.3.5 – <a name="3.3.5">Forステートメント</a></h3>

<p><b>for</b>ステートメントには、数値形式とジェネリック形式の2つの形式があります。</p><h4>数値<b>for</b>ループ</h4>

<p>数値<b>for</b>ループは、制御変数が算術進行をたどる間、コードブロックを繰り返します。次の構文があります。</p><pre>	stat ::= <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b>
</pre><p>指定された識別子（Name）は、ループ本体（<em>ブロック</em>）のローカルである新しい制御変数を定義します。</p><p>ループは、3つの制御式を1回評価することから始まります。それらの値は、それぞれ<em>初期値</em>、<em>制限値</em>、<em>ステップ</em>と呼ばれます。ステップがない場合、デフォルトは1です。</p><p>初期値とステップの両方が整数の場合、ループは整数で実行されます。制限値は整数でない場合があることに注意してください。それ以外の場合、3つの値は浮動小数点数に変換され、ループは浮動小数点数で実行されます。この場合、浮動小数点数の精度に注意してください。</p><p>その初期化の後、ループ本体は、ステップで指定された共通差で、初期値から始まる算術進行をたどる制御変数の値で繰り返されます。負のステップは減少シーケンスを作成します。ゼロに等しいステップはエラーを発生させます。ループは、値が制限値以下（負のステップの場合は制限値以上）である間、続行します。初期値がすでに制限値よりも大きい（または、ステップが負の場合は小さい）場合、本体は実行されません。</p><p>整数ループの場合、制御変数がラップアラウンドすることはありません。代わりに、オーバーフローの場合にループが終了します。</p><p>ループ中に制御変数の値を変更しないでください。ループ後にその値が必要な場合は、ループを終了する前に別の変数に割り当ててください。</p><h4>ジェネリック<b>for</b>ループ</h4>

<p>ジェネリック<b>for</b>ステートメントは、<em>イテレーター</em>と呼ばれる関数を対象として動作します。反復ごとに、イテレーター関数が新しい値を生成するために呼び出され、この新しい値が<b>nil</b>になると停止します。ジェネリック<b>for</b>ループには、次の構文があります。</p><pre>	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {‘<b>,</b>’ Name}
</pre><p>次のような<b>for</b>ステートメント</p><pre>     for <em>var_1</em>, ···, <em>var_n</em> in <em>explist</em> do <em>body</em> end
</pre><p>は、次のように機能します。</p><p>名前<em>var_i</em>は、ループ本体のローカルなループ変数を宣言します。これらの変数の最初の変数が<em>制御変数</em>です。</p><p>ループは、<em>explist</em>を評価して、4つの値を生成することから始まります。<em>イテレーター関数</em>、<em>状態</em>、制御変数の初期値、および<em>終了値</em>です。</p><p>次に、各反復で、Luaはイテレーター関数を2つの引数（状態と制御変数）とともに呼び出します。この呼び出しの結果は、複数の代入の規則に従ってループ変数に割り当てられます（<a href="#3.3.3">§3.3.3</a>参照）。制御変数が<b>nil</b>になると、ループが終了します。それ以外の場合、本体が実行され、ループは次の反復に進みます。</p><p>終了値は、ループが終了したときにリソースを解放するために使用できる、クローズされる変数（<a href="#3.3.8">§3.3.8</a>参照）のように動作します。それ以外の場合は、ループを妨げません。</p><p>ループ中に制御変数の値を変更しないでください。</p><h3>3.3.6 – <a name="3.3.6">ステートメントとしての関数呼び出し</a></h3><p>副作用の可能性を許可するために、関数呼び出しをステートメントとして実行できます。</p><pre>	stat ::= functioncall
</pre><p>この場合、返されたすべての値は破棄されます。関数呼び出しについては、<a href="#3.4.10">§3.4.10</a>で説明します。</p><h3>3.3.7 – <a name="3.3.7">ローカル宣言</a></h3><p>ローカル変数は、ブロック内の任意の場所で宣言できます。宣言には初期化を含めることができます。</p><pre>	stat ::= <b>local</b> attnamelist [‘<b>=</b>’ explist]
	attnamelist ::=  Name attrib {‘<b>,</b>’ Name attrib}
</pre><p>存在する場合、初期代入は複数代入と同じセマンティクスを持ちます（<a href="#3.3.3">§3.3.3</a>参照）。それ以外の場合、すべての変数は<b>nil</b>で初期化されます。</p><p>各変数名の後に属性（山かっこで囲まれた名前）を付けることができます。</p><pre>	attrib ::= [‘<b>&lt;</b>’ Name ‘<b>&gt;</b>’]
</pre><p>可能な属性は2つあります。<code>const</code>は、定数変数、つまり初期化後に代入できない変数を宣言します。<code>close</code>は、クローズされる変数を宣言します（<a href="#3.3.8">§3.3.8</a>参照）。変数のリストには、最大で1つのクローズされる変数を含めることができます。</p><p>チャンクもブロックであるため（<a href="#3.3.2">§3.3.2</a>参照）、ローカル変数を明示的なブロックの外部のチャンクで宣言できます。</p><p>ローカル変数の可視性規則については、<a href="#3.5">§3.5</a>で説明します。</p><h3>3.3.8 – <a name="3.3.8">クローズされる変数</a></h3>

<p>クローズされる変数は、定数ローカル変数のように動作しますが、変数がスコープ外になったときに、通常ブロックの終了、<b>break</b>/<b>goto</b>/<b>return</b>によるブロックの終了、またはエラーによる終了を含め、その値が<em>クローズ</em>される点が異なります。</p><p>ここで、値を<em>クローズする</em>とは、その<code>__close</code>メタメソッドを呼び出すことを意味します。メタメソッドを呼び出すとき、値自体が最初の引数として渡され、終了を引き起こしたエラーオブジェクト（存在する場合）が2番目の引数として渡されます。エラーがない場合は、2番目の引数は<b>nil</b>です。</p><p>クローズされる変数に割り当てられる値は、<code>__close</code>メタメソッドを持つか、false値である必要があります。（<b>nil</b>と<b>false</b>は、クローズされる値として無視されます。）</p><p>同じイベントで複数のクローズされる変数がスコープ外になった場合、それらは宣言された逆の順序でクローズされます。</p><p>クロージングメソッドの実行中にエラーが発生した場合、そのエラーは、変数が定義された通常のコードでのエラーと同様に処理されます。エラーが発生した後も、他の保留中のクロージングメソッドは引き続き呼び出されます。</p><p>コルーチンが yield し、再開されない場合、一部の変数はスコープから外れない可能性があり、そのためクローズされることはありません。（これらの変数は、コルーチン内で作成され、コルーチンが yield した時点でスコープ内にあるものです。）同様に、コルーチンがエラーで終了した場合、スタックを巻き戻さないため、変数をクローズしません。どちらの場合も、ファイナライザーを使用するか、<a href="#pdf-coroutine.close"><code>coroutine.close</code></a>を呼び出して変数をクローズできます。ただし、コルーチンが<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>を介して作成された場合、対応する関数はエラーが発生した場合にコルーチンをクローズします。</p><h2>3.4 – <a name="3.4">式</a></h2>



<p>Lua の基本的な式は次のとおりです。</p><pre>	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= ‘<b>...</b>’
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’
</pre>

<p>数値とリテラル文字列については<a href="#3.1">§3.1</a>で、変数については<a href="#3.2">§3.2</a>で、関数定義については<a href="#3.4.11">§3.4.11</a>で、関数呼び出しについては<a href="#3.4.10">§3.4.10</a>で、テーブルコンストラクターについては<a href="#3.4.9">§3.4.9</a>で説明されています。3つのドット('<code>...</code>')で示される可変長引数式は、可変長引数関数の内部でのみ直接使用できます。これについては<a href="#3.4.11">§3.4.11</a>で説明されています。</p><p>二項演算子には、算術演算子（<a href="#3.4.1">§3.4.1</a>を参照）、ビット演算子（<a href="#3.4.2">§3.4.2</a>を参照）、関係演算子（<a href="#3.4.4">§3.4.4</a>を参照）、論理演算子（<a href="#3.4.5">§3.4.5</a>を参照）、および連結演算子（<a href="#3.4.6">§3.4.6</a>を参照）が含まれます。単項演算子には、単項マイナス（<a href="#3.4.1">§3.4.1</a>を参照）、単項ビット単位 NOT（<a href="#3.4.2">§3.4.2</a>を参照）、単項論理 <b>not</b>（<a href="#3.4.5">§3.4.5</a>を参照）、および単項<em>長さ演算子</em>（<a href="#3.4.7">§3.4.7</a>を参照）が含まれます。</p><h3>3.4.1 – <a name="3.4.1">算術演算子</a></h3><p>Lua は次の算術演算子をサポートしています。</p><ul>
<li><b><code>+</code>: </b>加算</li>
<li><b><code>-</code>: </b>減算</li>
<li><b><code>*</code>: </b>乗算</li>
<li><b><code>/</code>: </b>浮動小数点除算</li>
<li><b><code>//</code>: </b>床関数除算</li>
<li><b><code>%</code>: </b>剰余</li>
<li><b><code>^</code>: </b>べき乗</li>
<li><b><code>-</code>: </b>単項マイナス</li>
</ul>

<p>べき乗と浮動小数点除算を除いて、算術演算子は次のように動作します。両方のオペランドが整数の場合、演算は整数に対して実行され、結果は整数になります。それ以外の場合、両方のオペランドが数値の場合、それらは浮動小数点数に変換され、浮動小数点演算のマシンルール（通常は IEEE 754 標準）に従って演算が実行され、結果は浮動小数点数になります。（文字列ライブラリは算術演算で文字列を数値に強制変換します。詳細については<a href="#3.4.3">§3.4.3</a>を参照してください。）</p><p>べき乗と浮動小数点除算（<code>/</code>）は、常にオペランドを浮動小数点数に変換し、結果は常に浮動小数点数になります。べき乗は ISO&nbsp;C 関数 <code>pow</code> を使用するため、整数以外の指数にも対応できます。</p><p>床関数除算（<code>//</code>）は、商を負の無限大方向に丸める除算であり、オペランドの除算の床を返します。</p><p>剰余は、商を負の無限大方向（床関数除算）に丸める除算の余りとして定義されます。</p><p>整数演算でオーバーフローが発生した場合、すべての演算は<em>ラップアラウンド</em>します。</p><h3>3.4.2 – <a name="3.4.2">ビット演算子</a></h3><p>Lua は次のビット演算子をサポートしています。</p><ul>
<li><b><code>&amp;</code>: </b>ビット単位 AND</li>
<li><b><code>|</code>: </b>ビット単位 OR</li>
<li><b><code>~</code>: </b>ビット単位排他的 OR</li>
<li><b><code>&gt;&gt;</code>: </b>右シフト</li>
<li><b><code>&lt;&lt;</code>: </b>左シフト</li>
<li><b><code>~</code>: </b>単項ビット単位 NOT</li>
</ul>

<p>すべてのビット単位演算は、オペランドを整数に変換し（<a href="#3.4.3">§3.4.3</a>を参照）、それらの整数のすべてのビットで演算を行い、整数を返します。</p><p>右シフトと左シフトの両方で、空いているビットはゼロで埋められます。負の変位は反対方向にシフトします。整数のビット数以上の絶対値を持つ変位は、ゼロになります（すべてのビットがシフトアウトされるため）。</p><h3>3.4.3 – <a name="3.4.3">強制型変換と変換</a></h3><p>Lua は、実行時にいくつかの型と表現の間で自動変換を行います。ビット単位演算子は、常に浮動小数点オペランドを整数に変換します。べき乗と浮動小数点除算は、常に整数オペランドを浮動小数点数に変換します。混合数値（整数と浮動小数点数）に適用される他のすべての算術演算は、整数オペランドを浮動小数点数に変換します。C API は、必要に応じて整数を浮動小数点数に、浮動小数点数を整数に変換します。さらに、文字列連結は、文字列に加えて数値を引数として受け入れます。</p><p>整数から浮動小数点数への変換では、整数値が浮動小数点数として正確に表現できる場合、それが結果となります。それ以外の場合、変換は、最も近い大きい値または最も近い小さい表現可能な値を取得します。この種の変換は決して失敗しません。</p><p>浮動小数点数から整数への変換では、浮動小数点数が整数として正確に表現できるかどうか（つまり、浮動小数点数が整数値を持ち、整数の表現範囲内にあるかどうか）をチェックします。そうである場合、その表現が結果になります。それ以外の場合、変換は失敗します。</p><p>Lua のいくつかの場所では、必要に応じて文字列を数値に強制変換します。特に、文字列ライブラリは、すべての算術演算で文字列を数値に強制変換しようとするメタメソッドを設定します。変換が失敗した場合、ライブラリは他のオペランドのメタメソッド（存在する場合）を呼び出すか、エラーを発生させます。ビット単位演算子は、この強制変換を行わないことに注意してください。</p><p>文字列から数値への暗黙的な強制変換に依存しないことは常に良い習慣です。これらは常に適用されるわけではないためです。特に、<code>"1"==1</code> は false であり、<code>"1"&lt;1</code> はエラーを発生させます（<a href="#3.4.4">§3.4.4</a>を参照）。これらの強制変換は主に互換性のために存在し、将来のバージョンの言語で削除される可能性があります。</p><p>文字列は、その構文と Lua レクサーのルールに従って、整数または浮動小数点数に変換されます。文字列には、先頭と末尾の空白と符号が含まれる場合もあります。文字列から数値へのすべての変換は、基数文字としてドットと現在のロケールマークの両方を受け入れます。（ただし、Lua レクサーはドットのみを受け入れます。）文字列が有効な数値でない場合、変換は失敗します。必要に応じて、この最初のステップの結果は、浮動小数点数と整数間の変換に関する前のルールに従って、特定の数値サブタイプに変換されます。</p><p>数値から文字列への変換では、指定されていない人間が読める形式を使用します。数値を特定の方法で文字列に変換するには、関数<a href="#pdf-string.format"><code>string.format</code></a>を使用してください。</p><h3>3.4.4 – <a name="3.4.4">関係演算子</a></h3><p>Lua は次の関係演算子をサポートしています。</p><ul>
<li><b><code>==</code>: </b>等しい</li>
<li><b><code>~=</code>: </b>等しくない</li>
<li><b><code>&lt;</code>: </b>より小さい</li>
<li><b><code>&gt;</code>: </b>より大きい</li>
<li><b><code>&lt;=</code>: </b>以下</li>
<li><b><code>&gt;=</code>: </b>以上</li>
</ul><p>これらの演算子は常に <b>false</b> または <b>true</b> を返します。</p><p>等価性（<code>==</code>）は、最初にオペランドの型を比較します。型が異なる場合、結果は <b>false</b> です。それ以外の場合、オペランドの値が比較されます。文字列は、バイト内容が同じ場合に等しくなります。数値は、数学的に同じ値を表す場合に等しくなります。</p><p>テーブル、ユーザーデータ、およびスレッドは参照によって比較されます。2つのオブジェクトが等しいと見なされるのは、同じオブジェクトである場合のみです。新しいオブジェクト（テーブル、ユーザーデータ、またはスレッド）を作成するたびに、この新しいオブジェクトは、以前に存在したオブジェクトとは異なります。関数は常にそれ自身と等しくなります。検出可能な違い（動作の違い、定義の違い）を持つ関数は常に異なります。異なる時点で作成されたが、検出可能な違いがない関数は、等しいと分類される場合とされない場合があります（内部キャッシュの詳細によって異なります）。</p><p><code>__eq</code>メタメソッドを使用すると、Lua がテーブルとユーザーデータを比較する方法を変更できます（<a href="#2.4">§2.4</a>を参照）。</p><p>等価性比較では、文字列を数値に、またはその逆に変換しません。したがって、<code>"0"==0</code>は<b>false</b>と評価され、<code>t[0]</code>と<code>t["0"]</code>はテーブル内の異なるエントリを表します。</p><p>演算子<code>~=</code>は、等価性（<code>==</code>）の否定です。</p><p>順序演算子は次のように動作します。両方の引数が数値の場合、それらはサブタイプに関係なく、数学的な値に従って比較されます。それ以外の場合、両方の引数が文字列である場合、それらの値は現在のロケールに従って比較されます。それ以外の場合、Lua は <code>__lt</code> または <code>__le</code> メタメソッドを呼び出そうとします（<a href="#2.4">§2.4</a>を参照）。比較 <code>a &gt; b</code> は <code>b &lt; a</code> に変換され、<code>a &gt;= b</code> は <code>b &lt;= a</code> に変換されます。</p><p>IEEE 754 標準に従い、特殊値 NaN は、それ自身を含め、どの値よりも小さい、等しい、または大きいとは見なされません。</p><h3>3.4.5 – <a name="3.4.5">論理演算子</a></h3><p>Lua の論理演算子は、<b>and</b>、<b>or</b>、および <b>not</b> です。制御構造（<a href="#3.3.4">§3.3.4</a>を参照）と同様に、すべての論理演算子は、<b>false</b> と <b>nil</b> の両方を false とみなし、その他を true とみなします。</p><p>否定演算子 <b>not</b> は、常に <b>false</b> または <b>true</b> を返します。論理積演算子 <b>and</b> は、この値が <b>false</b> または <b>nil</b> である場合は最初の引数を返し、それ以外の場合は <b>and</b> は2番目の引数を返します。論理和演算子 <b>or</b> は、この値が <b>nil</b> および <b>false</b> と異なる場合は最初の引数を返し、それ以外の場合は <b>or</b> は2番目の引数を返します。<b>and</b> と <b>or</b> の両方で短絡評価が使用されます。つまり、2番目のオペランドは必要な場合にのみ評価されます。以下にいくつかの例を示します。</p><pre>     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre>




<h3>3.4.6 – <a name="3.4.6">連結</a></h3><p>Lua の文字列連結演算子は、2つのドット('<code>..</code>')で示されます。両方のオペランドが文字列または数値の場合、数値は指定されていない形式で文字列に変換されます（<a href="#3.4.3">§3.4.3</a>を参照）。それ以外の場合、<code>__concat</code>メタメソッドが呼び出されます（<a href="#2.4">§2.4</a>を参照）。</p><h3>3.4.7 – <a name="3.4.7">長さ演算子</a></h3>

<p>長さ演算子は、単項プレフィックス演算子 <code>#</code> で示されます。</p><p>文字列の長さは、そのバイト数です。（つまり、各文字が1バイトの場合の文字列長の通常の意味です。）</p><p>テーブルに適用された長さ演算子は、そのテーブルの境界を返します。テーブル <code>t</code> の<em>境界</em>は、次の条件を満たす任意の非負の整数です。</p><pre>     (border == 0 or t[border] ~= nil) and
     (t[border + 1] == nil or border == math.maxinteger)
</pre><p>言葉で言えば、境界とは、テーブル内に存在する正の整数インデックスであり、それに続いて存在しないインデックスが続く場合と、2つの制限ケースがあります。インデックス 1 が存在しない場合はゼロ、そのインデックスが存在する場合は整数の最大値です。正の整数ではないキーは、境界に干渉しないことに注意してください。</p><p>境界が1つしかないテーブルは、<em>シーケンス</em>と呼ばれます。たとえば、テーブル <code>{10, 20, 30, 40, 50}</code> は境界（5）が1つしかないため、シーケンスです。テーブル <code>{10, 20, 30, nil, 50}</code> には2つの境界（3と5）があるため、シーケンスではありません。（インデックス 4 の <b>nil</b> は<em>穴</em>と呼ばれます。）テーブル <code>{nil, 20, 30, nil, nil, 60, nil}</code> には3つの境界（0、3、および 6）があるため、これもシーケンスではありません。テーブル <code>{}</code> は境界 0 のシーケンスです。</p><p><code>t</code> がシーケンスの場合、<code>#t</code> はその唯一の境界を返し、これはシーケンスの長さという直感的な概念に対応します。<code>t</code> がシーケンスでない場合、<code>#t</code> はその境界のいずれかを返す可能性があります。（どの境界が返されるかは、テーブルの内部表現の詳細に依存し、テーブルがどのようにデータが格納されたか、および数値ではないキーのメモリアドレスに依存します。）</p><p>テーブルの長さの計算は、最悪の場合でも <em>O(log n)</em> の時間が保証されています。ここで、<em>n</em> はテーブル内の最大の整数キーです。</p><p>プログラムは、<code>__len</code> メタメソッド（<a href="#2.4">§2.4</a> を参照）を使用して、文字列以外の任意の値に対する長さ演算子の動作を変更できます。</p><h3>3.4.8 – <a name="3.4.8">優先順位</a></h3><p>Lua における演算子の優先順位は、以下の表に従い、低いものから高いものの順に示します。</p><pre>     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>通常どおり、式での優先順位を変更するために括弧を使用できます。連結演算子 (<code>..</code>) とべき乗演算子 (<code>^</code>) は右結合です。その他のすべての二項演算子は左結合です。</p><h3>3.4.9 – <a name="3.4.9">テーブルコンストラクタ</a></h3><p>テーブルコンストラクタは、テーブルを作成する式です。コンストラクタが評価されるたびに、新しいテーブルが作成されます。コンストラクタは、空のテーブルを作成したり、テーブルを作成してそのフィールドの一部を初期化したりするために使用できます。コンストラクタの一般的な構文は次のとおりです。</p><pre>	tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp
	fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’
</pre>

<p><code>[exp1] = exp2</code> の形式の各フィールドは、キーが <code>exp1</code> で値が <code>exp2</code> のエントリを新しいテーブルに追加します。<code>name = exp</code> の形式のフィールドは、<code>["name"] = exp</code> と同等です。<code>exp</code> の形式のフィールドは、<code>[i] = exp</code> と同等です。ここで、<code>i</code> は 1 から始まる連続した整数です。その他の形式のフィールドは、このカウントに影響しません。たとえば、</p><pre>     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>は、次のものと同等です。</p><pre>     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>コンストラクタ内での代入の順序は未定義です。（この順序は、キーが繰り返されている場合にのみ重要になります。）</p><p>リスト内の最後のフィールドが <code>exp</code> の形式であり、その式が複数結果の式である場合、この式によって返されるすべての値がリストに連続して入力されます（<a href="#3.4.12">§3.4.12</a> を参照）。</p><p>フィールドリストには、機械生成されたコードの便宜のために、オプションの末尾の区切り記号を含めることができます。</p><h3>3.4.10 – <a name="3.4.10">関数呼び出し</a></h3><p>Lua での関数呼び出しの構文は次のとおりです。</p><pre>	functioncall ::= prefixexp args
</pre><p>関数呼び出しでは、最初に prefixexp と args が評価されます。prefixexp の値の型が <em>function</em> である場合、この関数は指定された引数で呼び出されます。それ以外の場合、prefixexp の <code>__call</code> メタメソッドが存在すればそれが呼び出されます。その最初の引数は prefixexp の値であり、その後に元の呼び出し引数が続きます（<a href="#2.4">§2.4</a> を参照）。</p><p>次の形式</p><pre>	functioncall ::= prefixexp ‘<b>:</b>’ Name args
</pre><p>は、メソッドをエミュレートするために使用できます。<code>v:name(<em>args</em>)</code> の呼び出しは、<code>v.name(v,<em>args</em>)</code> のシンタックスシュガーです。ただし、<code>v</code> は一度だけ評価されます。</p><p>引数の構文は次のとおりです。</p><pre>	args ::= ‘<b>(</b>’ [explist] ‘<b>)</b>’
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>すべての引数式は、呼び出し前に評価されます。<code>f{<em>fields</em>}</code> の形式の呼び出しは、<code>f({<em>fields</em>})</code> のシンタックスシュガーです。つまり、引数リストは単一の新しいテーブルです。<code>f'<em>string</em>'</code> (または <code>f"<em>string</em>"</code> または <code>f[[<em>string</em>]]</code>) の形式の呼び出しは、<code>f('<em>string</em>')</code> のシンタックスシュガーです。つまり、引数リストは単一のリテラル文字列です。</p><p>閉じられる変数のスコープ内にない <code>return <em>functioncall</em></code> の形式の呼び出しは、<em>末尾呼び出し</em>と呼ばれます。Lua は、<em>適切な末尾呼び出し</em>（または<em>適切な末尾再帰</em>）を実装しています。末尾呼び出しでは、呼び出される関数は呼び出し元の関数のスタックエントリを再利用します。したがって、プログラムが実行できるネストされた末尾呼び出しの数に制限はありません。ただし、末尾呼び出しは、呼び出し元の関数に関するデバッグ情報を消去します。末尾呼び出しは、<b>return</b> が引数として単一の関数呼び出しを持ち、閉じられる変数のスコープ外にある特定の構文でのみ発生することに注意してください。この構文により、呼び出し元の関数は、介入アクションなしに、呼び出された関数の戻り値を正確に返します。したがって、次の例はどれも末尾呼び出しではありません。</p><pre>     return (f(x))        -- results adjusted to 1
     return 2 * f(x)      -- result multiplied by 2
     return x, f(x)       -- additional results
     f(x); return         -- results discarded
     return x or f(x)     -- results adjusted to 1
</pre>




<h3>3.4.11 – <a name="3.4.11">関数定義</a></h3>

<p>関数定義の構文は次のとおりです。</p><pre>	functiondef ::= <b>function</b> funcbody
	funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b>
</pre>

<p>次のシンタックスシュガーは、関数定義を簡略化します。</p><pre>	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]
</pre><p>文</p><pre>     function f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     f = function () <em>body</em> end
</pre><p>文</p><pre>     function t.a.b.c.f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     t.a.b.c.f = function () <em>body</em> end
</pre><p>文</p><pre>     local function f () <em>body</em> end
</pre><p>は、次のように変換されます。</p><pre>     local f; f = function () <em>body</em> end
</pre><p>ではなく、</p><pre>     local f = function () <em>body</em> end
</pre><p>（これは、関数の本体に <code>f</code> への参照が含まれている場合にのみ違いが生じます。）</p><p>関数定義は、型が <em>function</em> の実行可能な式です。Lua がチャンクをプリコンパイルするとき、その関数本体はすべてプリコンパイルされますが、まだ作成されていません。その後、Lua が関数定義を実行するたびに、関数は<em>インスタンス化</em>（または<em>クローズ</em>）されます。この関数インスタンス、または<em>クロージャ</em>は、式の最終的な値です。</p><p>パラメータは、引数値で初期化されるローカル変数として機能します。</p><pre>	parlist ::= namelist [‘<b>,</b>’ ‘<b>...</b>’] | ‘<b>...</b>’
</pre><p>Lua 関数が呼び出されると、関数が<em>可変長引数関数</em>でない限り、引数リストをパラメータリストの長さに調整します（<a href="#3.4.12">§3.4.12</a> を参照）。可変長引数関数は、パラメータリストの最後に3つのドット（<code>...</code>）で示されます。可変長引数関数は、引数リストを調整しません。代わりに、すべての追加引数を収集し、3つのドットとしても記述される<em>可変長引数式</em>を介して関数に提供します。この式の値は、複数結果を持つ関数と同様に、すべての実際の追加引数のリストです（<a href="#3.4.12">§3.4.12</a> を参照）。</p><p>例として、次の定義を検討してください。</p><pre>     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>次に、引数からパラメータと可変長引数式への次のマッピングがあります。</p><pre>     CALL             PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>結果は、<b>return</b> ステートメント（<a href="#3.3.4">§3.3.4</a> を参照）を使用して返されます。制御が <b>return</b> ステートメントに遭遇せずに関数の終わりに到達した場合、関数は結果なしで返されます。</p><p>関数が返すことができる値の数には、システムに依存する制限があります。この制限は、1000 より大きいことが保証されています。</p><p><em>コロン</em>構文は、関数に暗黙的な追加のパラメータ <code>self</code> を追加することで、<em>メソッド</em>をエミュレートするために使用されます。したがって、文</p><pre>     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>は、次のシンタックスシュガーです。</p><pre>     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>




<h3>3.4.12 – <a name="3.4.12">式のリスト、複数の結果、および調整</a></h3>

<p>関数呼び出しと可変長引数式の両方が、複数の値を返す可能性があります。これらの式は、<em>複数結果の式</em>と呼ばれます。</p><p>複数結果の式が式のリストの最後の要素として使用される場合、式からのすべての結果が式のリストによって生成された値のリストに追加されます。式のリストを予期する場所に単一の式がある場合、その（シングルトン）リストの最後の式になることに注意してください。</p><p>これらは、Lua が式のリストを予期する場所です。</p><ul>

<li><b>return</b> ステートメント。たとえば、<code>return e1, e2, e3</code> （<a href="#3.3.4">§3.3.4</a> を参照）。</li>

<li>テーブルコンストラクタ。たとえば、<code>{e1, e2, e3}</code> （<a href="#3.4.9">§3.4.9</a> を参照）。</li>

<li>関数呼び出しの引数。たとえば、<code>foo(e1, e2, e3)</code> （<a href="#3.4.10">§3.4.10</a> を参照）。</li>

<li>複数代入。たとえば、<code>a , b, c = e1, e2, e3</code> （<a href="#3.3.3">§3.3.3</a> を参照）。</li>

<li>ローカル宣言。たとえば、<code>local a , b, c = e1, e2, e3</code> （<a href="#3.3.7">§3.3.7</a> を参照）。</li>

<li>汎用 <b>for</b> ループでの初期値。たとえば、<code>for k in e1, e2, e3 do ... end</code> （<a href="#3.3.5">§3.3.5</a> を参照）。</li>

</ul><p>最後の4つのケースでは、式のリストからの値のリストを特定の長さに<em>調整</em>する必要があります。つまり、可変長引数関数ではない関数への呼び出しのパラメータ数（<a href="#3.4.11">§3.4.11</a> を参照）、複数代入またはローカル宣言の変数の数、および汎用 <b>for</b> ループの場合は正確に4つの値です。<em>調整</em>は、次の規則に従います。必要な値よりも多くの値がある場合、余分な値は破棄されます。必要な値よりも少ない値がある場合、リストは <b>nil</b> で拡張されます。式のリストが複数結果の式で終わる場合、調整の前に、その式からのすべての結果が値のリストに入力されます。</p><p>複数結果の式が、最後の要素ではない式のリストで使用されている場合、または構文が単一の式を予期する場所で使用されている場合、Lua はその式の結果リストを1つの要素に調整します。特定の場合として、構文は括弧で囲まれた式の中に単一の式があることを予期します。したがって、複数結果の式の周囲に括弧を追加すると、正確に1つの結果が生成されます。</p><p>構文が単一の式を予期する場所で可変長引数式を使用する必要はほとんどありません。（通常、可変長引数部分の前に通常のパラメータを追加して、そのパラメータを使用する方が簡単です。）そのような必要がある場合は、可変長引数式を単一の変数に割り当てて、その変数を代わりに使用することをお勧めします。</p><p>複数結果の式の使用例を次に示します。すべての場合において、構成が「n番目の結果」を必要とし、そのような結果がない場合は、<b>nil</b> が使用されます。</p><pre>     print(x, f())      -- prints x and all results from f().
     print(x, (f()))    -- prints x and the first result from f().
     print(f(), x)      -- prints the first result from f() and x.
     print(1 + f())     -- prints 1 added to the first result from f().
     local x = ...      -- x gets the first vararg argument.
     x,y = ...          -- x gets the first vararg argument,
                        -- y gets the second vararg argument.
     x,y,z = w, f()     -- x gets w, y gets the first result from f(),
                        -- z gets the second result from f().
     x,y,z = f()        -- x gets the first result from f(),
                        -- y gets the second result from f(),
                        -- z gets the third result from f().
     x,y,z = f(), g()   -- x gets the first result from f(),
                        -- y gets the first result from g(),
                        -- z gets the second result from g().
     x,y,z = (f())      -- x gets the first result from f(), y and z get nil.
     return f()         -- returns all results from f().
     return x, ...      -- returns x and all received vararg arguments.
     return x,y,f()     -- returns x, y, and all results from f().
     {f()}              -- creates a list with all results from f().
     {...}              -- creates a list with all vararg arguments.
     {f(), 5}           -- creates a list with the first result from f() and 5.
</pre>






<h2>3.5 – <a name="3.5">可視性ルール</a></h2>

<p>Lua は、レキシカルスコープの言語です。ローカル変数のスコープは、宣言の後の最初のステートメントで始まり、宣言を含む最も内側のブロックの最後の非voidステートメントまで続きます。（<em>Voidステートメント</em>は、ラベルと空のステートメントです。）次の例を検討してください。</p><pre>     x = 10                -- global variable
     do                    -- new block
       local x = x         -- new 'x', with value 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- another block
         local x = x+1     -- another 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (the global one)
</pre>

<p><code>local x = x</code> のような宣言では、宣言されている新しい <code>x</code> はまだスコープ内ではないため、2番目の <code>x</code> は外部変数を参照することに注意してください。</p><p>レキシカルスコープルールのため、ローカル変数は、そのスコープ内で定義された関数によって自由にアクセスできます。内側の関数で使用されるローカル変数は、内側の関数内で<em>アップ値</em>（または<em>外部ローカル変数</em>、または単に<em>外部変数</em>）と呼ばれます。</p><p><b>local</b> ステートメントを実行するたびに、新しいローカル変数が定義されることに注意してください。次の例を検討してください。</p><pre>     a = {}
     local x = 20
     for i = 1, 10 do
       local y = 0
       a[i] = function () y = y + 1; return x + y end
     end
</pre><p>ループは、10個のクロージャ（つまり、匿名関数の10個のインスタンス）を作成します。これらの各クロージャは異なる <code>y</code> 変数を使用しますが、すべて同じ <code>x</code> を共有します。</p>
</body>
</html>
