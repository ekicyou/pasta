<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 - Section 3.3</title>
</head>
<body>
<h2>3.3 – <a name="3.3">ステートメント</a></h2>



<p>Luaは、他の一般的な言語と同様の、ほぼ従来のステートメントセットをサポートしています。このセットには、ブロック、代入、制御構造、関数呼び出し、変数宣言が含まれます。</p><h3>3.3.1 – <a name="3.3.1">ブロック</a></h3>

<p>ブロックはステートメントのリストであり、順次実行されます。</p><pre>	block ::= {stat}
</pre><p>Luaには、ステートメントをセミコロンで区切ったり、セミコロンでブロックを開始したり、セミコロンを2つ続けて記述したりできる、<em>空のステートメント</em>があります。</p><pre>	stat ::= ‘<b>;</b>’
</pre>

<p>関数呼び出しと代入の両方が、開き括弧で始まることができます。この可能性は、Luaの文法にあいまいさを生じさせます。次のフラグメントを考えてみましょう。</p><pre>     a = b + c
     (print or io.write)('done')
</pre><p>文法は、このフラグメントを2つの方法で見ることができます。</p><pre>     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>現在のパーサーは、常にこのような構造を最初の方法で見て、開き括弧を呼び出しの引数の開始として解釈します。このあいまいさを避けるために、括弧で始まるステートメントの前には常にセミコロンを付けるのが良い習慣です。</p><pre>     ;(print or io.write)('done')
</pre>

<p>ブロックを明示的に区切って、単一のステートメントを作成できます。</p><pre>	stat ::= <b>do</b> block <b>end</b>
</pre><p>明示的なブロックは、変数宣言のスコープを制御するのに役立ちます。明示的なブロックは、別のブロックの途中に<b>return</b>ステートメントを追加するためにも使用されることがあります（<a href="#3.3.4">§3.3.4</a>参照）。</p><h3>3.3.2 – <a name="3.3.2">チャンク</a></h3>

<p>Luaのコンパイル単位は、<em>チャンク</em>と呼ばれます。構文的には、チャンクは単なるブロックです。</p><pre>	chunk ::= block
</pre>

<p>Luaは、チャンクを可変数の引数を持つ匿名関数の本体として扱います（<a href="#3.4.11">§3.4.11</a>参照）。そのため、チャンクはローカル変数を定義したり、引数を受け取ったり、値を返したりできます。さらに、そのような匿名関数は、<code>_ENV</code>と呼ばれる外部ローカル変数のスコープ内でコンパイルされます（<a href="#2.2">§2.2</a>参照）。結果の関数は、その変数を使用しなくても、常に<code>_ENV</code>を唯一の外部変数として持ちます。</p><p>チャンクは、ファイルまたはホストプログラム内の文字列に格納できます。チャンクを実行するために、Luaはまずチャンクを<em>ロード</em>し、チャンクのコードを仮想マシンの命令にプリコンパイルします。次に、Luaは仮想マシンのインタープリターを使用して、コンパイルされたコードを実行します。</p><p>チャンクはバイナリ形式にプリコンパイルすることもできます。詳細については、プログラム<code>luac</code>および関数<a href="#pdf-string.dump"><code>string.dump</code></a>を参照してください。ソース形式とコンパイル形式のプログラムは交換可能です。Luaはファイルタイプを自動的に検出して、それに応じて動作します（<a href="#pdf-load"><code>load</code></a>を参照）。</p><h3>3.3.3 – <a name="3.3.3">代入</a></h3>

<p>Luaでは、複数の代入が可能です。したがって、代入の構文では、左側に変数のリスト、右側に式のリストを定義します。両方のリストの要素は、カンマで区切られます。</p><pre>	stat ::= varlist ‘<b>=</b>’ explist
	varlist ::= var {‘<b>,</b>’ var}
	explist ::= exp {‘<b>,</b>’ exp}
</pre><p>式については、<a href="#3.4">§3.4</a>で説明します。</p><p>代入の前に、値のリストは変数のリストの長さに<em>調整</em>されます（<a href="#3.4.12">§3.4.12</a>参照）。</p><p>複数の代入の中で変数が代入と読み取りの両方を行っている場合、Luaはすべての読み取りが代入前の変数の値を取得するようにします。したがって、次のコード</p><pre>     i = 3
     i, a[i] = i+1, 20
</pre><p>は、<code>a[i]</code>の<code>i</code>が（4が代入される前に）3と評価されるため、<code>a[3]</code>を20に設定し、<code>a[4]</code>には影響を与えません。同様に、次の行</p><pre>     x, y = y, x
</pre><p>は、<code>x</code>と<code>y</code>の値を交換し、</p><pre>     x, y, z = y, z, x
</pre><p>は、<code>x</code>、<code>y</code>、および<code>z</code>の値を循環的に並べ替えます。</p><p>この保証は、代入ステートメントの構文内のアクセスのみを対象としていることに注意してください。代入中に呼び出された関数またはメタメソッドが変数の値を変更した場合、Luaはそのアクセスの順序について保証しません。</p><p>グローバル名<code>x = val</code>への代入は、代入<code>_ENV.x = val</code>と同等です（<a href="#2.2">§2.2</a>参照）。</p><p>テーブルフィールドとグローバル変数（実際にはテーブルフィールドでもあります）への代入の意味は、メタテーブルを介して変更できます（<a href="#2.4">§2.4</a>参照）。</p><h3>3.3.4 – <a name="3.3.4">制御構造</a></h3><p>制御構造<b>if</b>、<b>while</b>、および<b>repeat</b>は、通常の意味と使い慣れた構文を持ちます。</p><pre>	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>Luaには、2つの形式の<b>for</b>ステートメントもあります（<a href="#3.3.5">§3.3.5</a>参照）。</p><p>制御構造の条件式は、任意の値 を返すことができます。<b>false</b>と<b>nil</b>の両方がfalseとして評価されます。<b>nil</b>と<b>false</b>以外のすべての値はtrueとして評価されます。特に、数値の0と空の文字列もtrueとして評価されます。</p><p><b>repeat</b>-<b>until</b>ループでは、内部ブロックは<b>until</b>キーワードでは終了せず、条件の後でのみ終了します。したがって、条件はループブロック内で宣言されたローカル変数を参照できます。</p><p><b>goto</b>ステートメントは、プログラム制御をラベルに転送します。構文上の理由から、Luaのラベルもステートメントと見なされます。</p><pre>	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= ‘<b>::</b>’ Name ‘<b>::</b>’
</pre>

<p>ラベルは、ネストされた関数内を除き、定義されているブロック全体で可視になります。gotoは、ローカル変数のスコープに入らない限り、任意の可視ラベルにジャンプできます。ラベルは、同じ名前のラベルが可視になっている場合は、たとえこの他のラベルが外側のブロックで宣言されている場合でも、宣言しないでください。</p><p><b>break</b>ステートメントは、<b>while</b>、<b>repeat</b>、または<b>for</b>ループの実行を終了し、ループ後の次のステートメントにスキップします。</p><pre>	stat ::= <b>break</b>
</pre><p><b>break</b>は、最も内側の囲みループを終了します。</p><p><b>return</b>ステートメントは、関数またはチャンク（匿名関数として扱われます）から値を返すために使用されます。関数は複数の値を返すことができるため、<b>return</b>ステートメントの構文は次のようになります。</p><pre>	stat ::= <b>return</b> [explist] [‘<b>;</b>’]
</pre>

<p><b>return</b>ステートメントは、ブロックの最後のステートメントとしてのみ記述できます。ブロックの途中で<b>return</b>する必要がある場合は、慣用句<code>do return end</code>のように、明示的な内部ブロックを使用できます。これは、<b>return</b>が（内部）ブロックの最後のステートメントになるためです。</p><h3>3.3.5 – <a name="3.3.5">Forステートメント</a></h3>

<p><b>for</b>ステートメントには、数値形式とジェネリック形式の2つの形式があります。</p><h4>数値<b>for</b>ループ</h4>

<p>数値<b>for</b>ループは、制御変数が算術進行をたどる間、コードブロックを繰り返します。次の構文があります。</p><pre>	stat ::= <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b>
</pre><p>指定された識別子（Name）は、ループ本体（<em>ブロック</em>）のローカルである新しい制御変数を定義します。</p><p>ループは、3つの制御式を1回評価することから始まります。それらの値は、それぞれ<em>初期値</em>、<em>制限値</em>、<em>ステップ</em>と呼ばれます。ステップがない場合、デフォルトは1です。</p><p>初期値とステップの両方が整数の場合、ループは整数で実行されます。制限値は整数でない場合があることに注意してください。それ以外の場合、3つの値は浮動小数点数に変換され、ループは浮動小数点数で実行されます。この場合、浮動小数点数の精度に注意してください。</p><p>その初期化の後、ループ本体は、ステップで指定された共通差で、初期値から始まる算術進行をたどる制御変数の値で繰り返されます。負のステップは減少シーケンスを作成します。ゼロに等しいステップはエラーを発生させます。ループは、値が制限値以下（負のステップの場合は制限値以上）である間、続行します。初期値がすでに制限値よりも大きい（または、ステップが負の場合は小さい）場合、本体は実行されません。</p><p>整数ループの場合、制御変数がラップアラウンドすることはありません。代わりに、オーバーフローの場合にループが終了します。</p><p>ループ中に制御変数の値を変更しないでください。ループ後にその値が必要な場合は、ループを終了する前に別の変数に割り当ててください。</p><h4>ジェネリック<b>for</b>ループ</h4>

<p>ジェネリック<b>for</b>ステートメントは、<em>イテレーター</em>と呼ばれる関数を対象として動作します。反復ごとに、イテレーター関数が新しい値を生成するために呼び出され、この新しい値が<b>nil</b>になると停止します。ジェネリック<b>for</b>ループには、次の構文があります。</p><pre>	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {‘<b>,</b>’ Name}
</pre><p>次のような<b>for</b>ステートメント</p><pre>     for <em>var_1</em>, ···, <em>var_n</em> in <em>explist</em> do <em>body</em> end
</pre><p>は、次のように機能します。</p><p>名前<em>var_i</em>は、ループ本体のローカルなループ変数を宣言します。これらの変数の最初の変数が<em>制御変数</em>です。</p><p>ループは、<em>explist</em>を評価して、4つの値を生成することから始まります。<em>イテレーター関数</em>、<em>状態</em>、制御変数の初期値、および<em>終了値</em>です。</p><p>次に、各反復で、Luaはイテレーター関数を2つの引数（状態と制御変数）とともに呼び出します。この呼び出しの結果は、複数の代入の規則に従ってループ変数に割り当てられます（<a href="#3.3.3">§3.3.3</a>参照）。制御変数が<b>nil</b>になると、ループが終了します。それ以外の場合、本体が実行され、ループは次の反復に進みます。</p><p>終了値は、ループが終了したときにリソースを解放するために使用できる、クローズされる変数（<a href="#3.3.8">§3.3.8</a>参照）のように動作します。それ以外の場合は、ループを妨げません。</p><p>ループ中に制御変数の値を変更しないでください。</p><h3>3.3.6 – <a name="3.3.6">ステートメントとしての関数呼び出し</a></h3><p>副作用の可能性を許可するために、関数呼び出しをステートメントとして実行できます。</p><pre>	stat ::= functioncall
</pre><p>この場合、返されたすべての値は破棄されます。関数呼び出しについては、<a href="#3.4.10">§3.4.10</a>で説明します。</p><h3>3.3.7 – <a name="3.3.7">ローカル宣言</a></h3><p>ローカル変数は、ブロック内の任意の場所で宣言できます。宣言には初期化を含めることができます。</p><pre>	stat ::= <b>local</b> attnamelist [‘<b>=</b>’ explist]
	attnamelist ::=  Name attrib {‘<b>,</b>’ Name attrib}
</pre><p>存在する場合、初期代入は複数代入と同じセマンティクスを持ちます（<a href="#3.3.3">§3.3.3</a>参照）。それ以外の場合、すべての変数は<b>nil</b>で初期化されます。</p><p>各変数名の後に属性（山かっこで囲まれた名前）を付けることができます。</p><pre>	attrib ::= [‘<b>&lt;</b>’ Name ‘<b>&gt;</b>’]
</pre><p>可能な属性は2つあります。<code>const</code>は、定数変数、つまり初期化後に代入できない変数を宣言します。<code>close</code>は、クローズされる変数を宣言します（<a href="#3.3.8">§3.3.8</a>参照）。変数のリストには、最大で1つのクローズされる変数を含めることができます。</p><p>チャンクもブロックであるため（<a href="#3.3.2">§3.3.2</a>参照）、ローカル変数を明示的なブロックの外部のチャンクで宣言できます。</p><p>ローカル変数の可視性規則については、<a href="#3.5">§3.5</a>で説明します。</p><h3>3.3.8 – <a name="3.3.8">クローズされる変数</a></h3>

<p>クローズされる変数は、定数ローカル変数のように動作しますが、変数がスコープ外になったときに、通常ブロックの終了、<b>break</b>/<b>goto</b>/<b>return</b>によるブロックの終了、またはエラーによる終了を含め、その値が<em>クローズ</em>される点が異なります。</p><p>ここで、値を<em>クローズする</em>とは、その<code>__close</code>メタメソッドを呼び出すことを意味します。メタメソッドを呼び出すとき、値自体が最初の引数として渡され、終了を引き起こしたエラーオブジェクト（存在する場合）が2番目の引数として渡されます。エラーがない場合は、2番目の引数は<b>nil</b>です。</p><p>クローズされる変数に割り当てられる値は、<code>__close</code>メタメソッドを持つか、false値である必要があります。（<b>nil</b>と<b>false</b>は、クローズされる値として無視されます。）</p><p>同じイベントで複数のクローズされる変数がスコープ外になった場合、それらは宣言された逆の順序でクローズされます。</p><p>クロージングメソッドの実行中にエラーが発生した場合、そのエラーは、変数が定義された通常のコードでのエラーと同様に処理されます。エラーが発生した後も、他の保留中のクロージングメソッドは引き続き呼び出されます。</p><p>コルーチンが yield し、再開されない場合、一部の変数はスコープから外れない可能性があり、そのためクローズされることはありません。（これらの変数は、コルーチン内で作成され、コルーチンが yield した時点でスコープ内にあるものです。）同様に、コルーチンがエラーで終了した場合、スタックを巻き戻さないため、変数をクローズしません。どちらの場合も、ファイナライザーを使用するか、<a href="#pdf-coroutine.close"><code>coroutine.close</code></a>を呼び出して変数をクローズできます。ただし、コルーチンが<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>を介して作成された場合、対応する関数はエラーが発生した場合にコルーチンをクローズします。</p>
</body>
</html>
