<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 Reference Manual - Chapter 04</title>
</head>
<body>
<h1>4 &ndash; <a name="4">The Application Program Interface</a></h1>



<p>

This section describes the C&nbsp;API for Lua, that is,
the set of C&nbsp;functions available to the host program to communicate
with Lua.
All API functions and related types and constants
are declared in the header file <a name="pdf-lua.h"><code>lua.h</code></a>.


<p>
Even when we use the term "function",
any facility in the API may be provided as a macro instead.
Except where stated otherwise,
all such macros use each of their arguments exactly once
(except for the first argument, which is always a Lua state),
and so do not generate any hidden side-effects.


<p>
As in most C&nbsp;libraries,
the Lua API functions do not check their arguments
for validity or consistency.
However, you can change this behavior by compiling Lua
with the macro <a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a> defined.


<p>
The Lua library is fully reentrant:
it has no global variables.
It keeps all information it needs in a dynamic structure,
called the <em>Lua state</em>.


<p>
Each Lua state has one or more threads,
which correspond to independent, cooperative lines of execution.
The type <a href="#lua_State"><code>lua_State</code></a> (despite its name) refers to a thread.
(Indirectly, through the thread, it also refers to the
Lua state associated to the thread.)


<p>
A pointer to a thread must be passed as the first argument to
every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,
which creates a Lua state from scratch and returns a pointer
to the <em>main thread</em> in the new state.





<h2>4.1 &ndash; <a name="4.1">The Stack</a></h2>



<p>
Lua uses a <em>virtual stack</em> to pass values to and from C.
Each element in this stack represents a Lua value
(<b>nil</b>, number, string, etc.).
Functions in the API can access this stack through the
Lua state parameter that they receive.


<p>
Whenever Lua calls C, the called function gets a new stack,
which is independent of previous stacks and of stacks of
C&nbsp;functions that are still active.
This stack initially contains any arguments to the C&nbsp;function
and it is where the C&nbsp;function can store temporary
Lua values and must push its results
to be returned to the caller (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
For convenience,
most query operations in the API do not follow a strict stack discipline.
Instead, they can refer to any element in the stack
by using an <em>index</em>:
A positive index represents an absolute stack position,
starting at&nbsp;1 as the bottom of the stack;
a negative index represents an offset relative to the top of the stack.
More specifically, if the stack has <em>n</em> elements,
then index&nbsp;1 represents the first element
(that is, the element that was pushed onto the stack first)
and
index&nbsp;<em>n</em> represents the last element;
index&nbsp;-1 also represents the last element
(that is, the element at the&nbsp;top)
and index <em>-n</em> represents the first element.





<h3>4.1.1 &ndash; <a name="4.1.1">Stack Size</a></h3>

<p>
When you interact with the Lua API,
you are responsible for ensuring consistency.
In particular,
<em>you are responsible for controlling stack overflow</em>.
When you call any API function,
you must ensure the stack has enough room to accommodate the results.


<p>
There is one exception to the above rule:
When you call a Lua function
without a fixed number of results (see <a href="#lua_call"><code>lua_call</code></a>),
Lua ensures that the stack has enough space for all results.
However, it does not ensure any extra space.
So, before pushing anything on the stack after such a call
you should use <a href="#lua_checkstack"><code>lua_checkstack</code></a>.


<p>
Whenever Lua calls C,
it ensures that the stack has space for
at least <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a> extra elements;
that is, you can safely push up to <code>LUA_MINSTACK</code> values into it.
<code>LUA_MINSTACK</code> is defined as 20,
so that usually you do not have to worry about stack space
unless your code has loops pushing elements onto the stack.
Whenever necessary,
you can use the function <a href="#lua_checkstack"><code>lua_checkstack</code></a>
to ensure that the stack has enough space for pushing new elements.





<h3>4.1.2 &ndash; <a name="4.1.2">Valid and Acceptable Indices</a></h3>

<p>
Any function in the API that receives stack indices
works only with <em>valid indices</em> or <em>acceptable indices</em>.


<p>
A <em>valid index</em> is an index that refers to a
position that stores a modifiable Lua value.
It comprises stack indices between&nbsp;1 and the stack top
(<code>1 &le; abs(index) &le; top</code>)

plus <em>pseudo-indices</em>,
which represent some positions that are accessible to C&nbsp;code
but that are not in the stack.
Pseudo-indices are used to access the registry (see <a href="#4.3">&sect;4.3</a>)
and the upvalues of a C&nbsp;function (see <a href="#4.2">&sect;4.2</a>).


<p>
Functions that do not need a specific mutable position,
but only a value (e.g., query functions),
can be called with acceptable indices.
An <em>acceptable index</em> can be any valid index,
but it also can be any positive index after the stack top
within the space allocated for the stack,
that is, indices up to the stack size.
(Note that 0 is never an acceptable index.)
Indices to upvalues (see <a href="#4.2">&sect;4.2</a>) greater than the real number
of upvalues in the current C&nbsp;function are also acceptable (but invalid).
Except when noted otherwise,
functions in the API work with acceptable indices.


<p>
Acceptable indices serve to avoid extra tests
against the stack top when querying the stack.
For instance, a C&nbsp;function can query its third argument
without the need to check whether there is a third argument,
that is, without the need to check whether 3 is a valid index.


<p>
For functions that can be called with acceptable indices,
any non-valid index is treated as if it
contains a value of a virtual type <a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>,
which behaves like a nil value.





<h3>4.1.3 &ndash; <a name="4.1.3">Pointers to Strings</a></h3>

<p>
Several functions in the API return pointers (<code>const char*</code>)
to Lua strings in the stack.
(See <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, <a href="#lua_pushlstring"><code>lua_pushlstring</code></a>,
<a href="#lua_pushstring"><code>lua_pushstring</code></a>, and <a href="#lua_tolstring"><code>lua_tolstring</code></a>.
See also <a href="#luaL_checklstring"><code>luaL_checklstring</code></a>, <a href="#luaL_checkstring"><code>luaL_checkstring</code></a>,
and <a href="#luaL_tolstring"><code>luaL_tolstring</code></a> in the auxiliary library.)


<p>
In general,
Lua's garbage collection can free or move memory
and then invalidate pointers to strings handled by a Lua state.
To allow a safe use of these pointers,
the API guarantees that any pointer to a string in a stack index
is valid while the string value at that index is not removed from the stack.
(It can be moved to another index, though.)
When the index is a pseudo-index (referring to an upvalue),
the pointer is valid while the corresponding call is active and
the corresponding upvalue is not modified.


<p>
Some functions in the debug interface
also return pointers to strings,
namely <a href="#lua_getlocal"><code>lua_getlocal</code></a>, <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>,
<a href="#lua_setlocal"><code>lua_setlocal</code></a>, and <a href="#lua_setupvalue"><code>lua_setupvalue</code></a>.
For these functions, the pointer is guaranteed to
be valid while the caller function is active and
the given closure (if one was given) is in the stack.


<p>
Except for these guarantees,
the garbage collector is free to invalidate
any pointer to internal strings.







<h2>4.2 &ndash; <a name="4.2">C Closures</a></h2>

<p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
thus creating a <em>C&nbsp;closure</em>
(see <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>);
these values are called <em>upvalues</em> and are
accessible to the function whenever it is called.


<p>
Whenever a C&nbsp;function is called,
its upvalues are located at specific pseudo-indices.
These pseudo-indices are produced by the macro
<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>.
The first upvalue associated with a function is at index
<code>lua_upvalueindex(1)</code>, and so on.
Any access to <code>lua_upvalueindex(<em>n</em>)</code>,
where <em>n</em> is greater than the number of upvalues of the
current function
(but not greater than 256,
which is one plus the maximum number of upvalues in a closure),
produces an acceptable but invalid index.


<p>
A C&nbsp;closure can also change the values
of its corresponding upvalues.





<h2>4.3 &ndash; <a name="4.3">Registry</a></h2>

<p>
Lua provides a <em>registry</em>,
a predefined table that can be used by any C&nbsp;code to
store whatever Lua values it needs to store.
The registry table is always accessible at pseudo-index
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>.
Any C&nbsp;library can store data into this table,
but it must take care to choose keys
that are different from those used
by other libraries, to avoid collisions.
Typically, you should use as key a string containing your library name,
or a light userdata with the address of a C&nbsp;object in your code,
or any Lua object created by your code.
As with variable names,
string keys starting with an underscore followed by
uppercase letters are reserved for Lua.


<p>
The integer keys in the registry are used
by the reference mechanism (see <a href="#luaL_ref"><code>luaL_ref</code></a>),
with some predefined values.
Therefore, integer keys in the registry
must not be used for other purposes.


<p>
When you create a new Lua state,
its registry comes with some predefined values.
These predefined values are indexed with integer keys
defined as constants in <code>lua.h</code>.
The following constants are defined:

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a></b>:  At this index the registry has
the main thread of the state.
(The main thread is the one created together with the state.)
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a></b>:  At this index the registry has
the global environment.
</li>
</ul>




<h2>4.4 &ndash; <a name="4.4">Error Handling in C</a></h2>



<p>
Internally, Lua uses the C <code>longjmp</code> facility to handle errors.
(Lua will use exceptions if you compile it as C++;
search for <code>LUAI_THROW</code> in the source code for details.)
When Lua faces any error,
such as a memory allocation error or a type error,
it <em>raises</em> an error;
that is, it does a long jump.
A <em>protected environment</em> uses <code>setjmp</code>
to set a recovery point;
any error jumps to the most recent active recovery point.


<p>
Inside a C&nbsp;function you can raise an error explicitly
by calling <a href="#lua_error"><code>lua_error</code></a>.


<p>
Most functions in the API can raise an error,
for instance due to a memory allocation error.
The documentation for each function indicates whether
it can raise errors.


<p>
If an error happens outside any protected environment,
Lua calls a <em>panic function</em> (see <a href="#lua_atpanic"><code>lua_atpanic</code></a>)
and then calls <code>abort</code>,
thus exiting the host application.
Your panic function can avoid this exit by
never returning
(e.g., doing a long jump to your own recovery point outside Lua).


<p>
The panic function,
as its name implies,
is a mechanism of last resort.
Programs should avoid it.
As a general rule,
when a C&nbsp;function is called by Lua with a Lua state,
it can do whatever it wants on that Lua state,
as it should be already protected.
However,
when C code operates on other Lua states
(e.g., a Lua-state argument to the function,
a Lua state stored in the registry, or
the result of <a href="#lua_newthread"><code>lua_newthread</code></a>),
it should use them only in API calls that cannot raise errors.


<p>
The panic function runs as if it were a message handler (see <a href="#2.3">&sect;2.3</a>);
in particular, the error object is on the top of the stack.
However, there is no guarantee about stack space.
To push anything on the stack,
the panic function must first check the available space (see <a href="#4.1.1">&sect;4.1.1</a>).





<h3>4.4.1 &ndash; <a name="4.4.1">Status Codes</a></h3>

<p>
Several functions that report errors in the API use the following
status codes to indicate different kinds of errors or other conditions:

<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0)</b>:  no errors.</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a></b>:  a runtime error.</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a></b>: 
memory allocation error.
For such errors, Lua does not call the message handler.
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a></b>: 
stack overflow while running the message handler
due to another stack overflow.
More often than not,
this error is the result of some other error while running
a message handler.
An error in a message handler will call the handler again,
which will generate the error again, and so on,
until this loop exhausts the stack and cause this error.
</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a></b>:  syntax error during precompilation
or format error in a binary chunk.</li>

<li><b><a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a></b>:  the thread (coroutine) yields.</li>

<li><b><a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a></b>:  a file-related error;
e.g., it cannot open or read the file.</li>

</ul><p>
These constants are defined in the header file <code>lua.h</code>.







<h2>4.5 &ndash; <a name="4.5">Handling Yields in C</a></h2>

<p>
Internally, Lua uses the C <code>longjmp</code> facility to yield a coroutine.
Therefore, if a C&nbsp;function <code>foo</code> calls an API function
and this API function yields
(directly or indirectly by calling another function that yields),
Lua cannot return to <code>foo</code> any more,
because the <code>longjmp</code> removes its frame from the C&nbsp;stack.


<p>
To avoid this kind of problem,
Lua raises an error whenever it tries to yield across an API call,
except for three functions:
<a href="#lua_yieldk"><code>lua_yieldk</code></a>, <a href="#lua_callk"><code>lua_callk</code></a>, and <a href="#lua_pcallk"><code>lua_pcallk</code></a>.
All those functions receive a <em>continuation function</em>
(as a parameter named <code>k</code>) to continue execution after a yield.


<p>
We need to set some terminology to explain continuations.
We have a C&nbsp;function called from Lua which we will call
the <em>original function</em>.
This original function then calls one of those three functions in the C API,
which we will call the <em>callee function</em>,
that then yields the current thread.
This can happen when the callee function is <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
or when the callee function is either <a href="#lua_callk"><code>lua_callk</code></a> or <a href="#lua_pcallk"><code>lua_pcallk</code></a>
and the function called by them yields.


<p>
Suppose the running thread yields while executing the callee function.
After the thread resumes,
it eventually will finish running the callee function.
However,
the callee function cannot return to the original function,
because its frame in the C&nbsp;stack was destroyed by the yield.
Instead, Lua calls a <em>continuation function</em>,
which was given as an argument to the callee function.
As the name implies,
the continuation function should continue the task
of the original function.


<p>
As an illustration, consider the following function:

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* calls Lua */
       ...     /* code 2 */
     }
</pre><p>
Now we want to allow
the Lua code being run by <a href="#lua_pcall"><code>lua_pcall</code></a> to yield.
First, we can rewrite our function like here:

<pre>
     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
In the above code,
the new function <code>k</code> is a
<em>continuation function</em> (with type <a href="#lua_KFunction"><code>lua_KFunction</code></a>),
which should do all the work that the original function
was doing after calling <a href="#lua_pcall"><code>lua_pcall</code></a>.
Now, we must inform Lua that it must call <code>k</code> if the Lua code
being executed by <a href="#lua_pcall"><code>lua_pcall</code></a> gets interrupted in some way
(errors or yielding),
so we rewrite the code as here,
replacing <a href="#lua_pcall"><code>lua_pcall</code></a> by <a href="#lua_pcallk"><code>lua_pcallk</code></a>:

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
Note the external, explicit call to the continuation:
Lua will call the continuation only if needed, that is,
in case of errors or resuming after a yield.
If the called function returns normally without ever yielding,
<a href="#lua_pcallk"><code>lua_pcallk</code></a> (and <a href="#lua_callk"><code>lua_callk</code></a>) will also return normally.
(Of course, instead of calling the continuation in that case,
you can do the equivalent work directly inside the original function.)


<p>
Besides the Lua state,
the continuation function has two other parameters:
the final status of the call and the context value (<code>ctx</code>) that
was passed originally to <a href="#lua_pcallk"><code>lua_pcallk</code></a>.
Lua does not use this context value;
it only passes this value from the original function to the
continuation function.
For <a href="#lua_pcallk"><code>lua_pcallk</code></a>,
the status is the same value that would be returned by <a href="#lua_pcallk"><code>lua_pcallk</code></a>,
except that it is <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> when being executed after a yield
(instead of <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>).
For <a href="#lua_yieldk"><code>lua_yieldk</code></a> and <a href="#lua_callk"><code>lua_callk</code></a>,
the status is always <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> when Lua calls the continuation.
(For these two functions,
Lua will not call the continuation in case of errors,
because they do not handle errors.)
Similarly, when using <a href="#lua_callk"><code>lua_callk</code></a>,
you should call the continuation function
with <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> as the status.
(For <a href="#lua_yieldk"><code>lua_yieldk</code></a>, there is not much point in calling
directly the continuation function,
because <a href="#lua_yieldk"><code>lua_yieldk</code></a> usually does not return.)


<p>
Lua treats the continuation function as if it were the original function.
The continuation function receives the same Lua stack
from the original function,
in the same state it would be if the callee function had returned.
(For instance,
after a <a href="#lua_callk"><code>lua_callk</code></a> the function and its arguments are
removed from the stack and replaced by the results from the call.)
It also has the same upvalues.
Whatever it returns is handled by Lua as if it were the return
of the original function.





<h2>4.6 &ndash; <a name="4.6">Functions and Types</a></h2>

<p>
Here we list all functions and types from the C&nbsp;API in
alphabetical order.
Each function has an indicator like this:
<span class="apii">[-o, +p, <em>x</em>]</span>


<p>
The first field, <code>o</code>,
is how many elements the function pops from the stack.
The second field, <code>p</code>,
is how many elements the function pushes onto the stack.
(Any function always pushes its results after popping its arguments.)
A field in the form <code>x|y</code> means the function can push (or pop)
<code>x</code> or <code>y</code> elements,
depending on the situation;
an interrogation mark '<code>?</code>' means that
we cannot know how many elements the function pops/pushes
by looking only at its arguments.
(For instance, they may depend on what is in the stack.)
The third field, <code>x</code>,
tells whether the function may raise errors:
'<code>-</code>' means the function never raises any error;
'<code>m</code>' means the function may raise only out-of-memory errors;
'<code>v</code>' means the function may raise the errors explained in the text;
'<code>e</code>' means the function can run arbitrary Lua code,
either directly or through metamethods,
and therefore may raise any errors.



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
Converts the acceptable index <code>idx</code>
into an equivalent absolute index
(that is, one that does not depend on the stack size).





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
The type of the memory-allocator function used by Lua states.
The allocator function must provide a
functionality similar to <code>realloc</code>,
but not exactly the same.
Its arguments are
<code>ud</code>, an opaque pointer passed to <a href="#lua_newstate"><code>lua_newstate</code></a>;
<code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
<code>osize</code>, the original size of the block or some code about what
is being allocated;
and <code>nsize</code>, the new size of the block.


<p>
When <code>ptr</code> is not <code>NULL</code>,
<code>osize</code> is the size of the block pointed by <code>ptr</code>,
that is, the size given when it was allocated or reallocated.


<p>
When <code>ptr</code> is <code>NULL</code>,
<code>osize</code> encodes the kind of object that Lua is allocating.
<code>osize</code> is any of
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>, <a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>, or <a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a> when (and only when)
Lua is creating a new object of that type.
When <code>osize</code> is some other value,
Lua is allocating memory for something else.


<p>
Lua assumes the following behavior from the allocator function:


<p>
When <code>nsize</code> is zero,
the allocator must behave like <code>free</code>
and then return <code>NULL</code>.


<p>
When <code>nsize</code> is not zero,
the allocator must behave like <code>realloc</code>.
In particular, the allocator returns <code>NULL</code>
if and only if it cannot fulfill the request.


<p>
Here is a simple implementation for the allocator function,
corresponding to the function <a href="#luaL_alloc"><code>luaL_alloc</code></a> from the
auxiliary library.

<pre>
     void *luaL_alloc (void *ud, void *ptr, size_t osize,
                                            size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
Note that ISO&nbsp;C ensures
that <code>free(NULL)</code> has no effect and that
<code>realloc(NULL,size)</code> is equivalent to <code>malloc(size)</code>.





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
Performs an arithmetic or bitwise operation over the two values
(or one, in the case of negations)
at the top of the stack,
with the value on the top being the second operand,
pops these values, and pushes the result of the operation.
The function follows the semantics of the corresponding Lua operator
(that is, it may call metamethods).


<p>
The value of <code>op</code> must be one of the following constants:

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a></b>:  performs addition (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a></b>:  performs subtraction (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a></b>:  performs multiplication (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a></b>:  performs float division (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a></b>:  performs floor division (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a></b>:  performs modulo (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a></b>:  performs exponentiation (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a></b>:  performs mathematical negation (unary <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a></b>:  performs bitwise NOT (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a></b>:  performs bitwise AND (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a></b>:  performs bitwise OR (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a></b>:  performs bitwise exclusive OR (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a></b>:  performs left shift (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a></b>:  performs right shift (<code>&gt;&gt;</code>)</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
Sets a new panic function and returns the old one (see <a href="#4.4">&sect;4.4</a>).





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
Calls a function.
Like regular Lua calls,
<code>lua_call</code> respects the <code>__call</code> metamethod.
So, here the word "function"
means any callable value.


<p>
To do a call you must use the following protocol:
first, the function to be called is pushed onto the stack;
then, the arguments to the call are pushed
in direct order;
that is, the first argument is pushed first.
Finally you call <a href="#lua_call"><code>lua_call</code></a>;
<code>nargs</code> is the number of arguments that you pushed onto the stack.
When the function returns,
all arguments and the function value are popped
and the call results are pushed onto the stack.
The number of results is adjusted to <code>nresults</code>,
unless <code>nresults</code> is <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>,
which makes all results from the function to be pushed.
In the first case, an explicit number of results,
the caller must ensure that the stack has space for the
returned values.
In the second case, all results,
Lua takes care that the returned values fit into the stack space,
but it does not ensure any extra space in the stack.
The function results are pushed onto the stack in direct order
(the first result is pushed first),
so that after the call the last result is on the top of the stack.


<p>
The maximum value for <code>nresults</code> is 250.


<p>
Any error while calling and running the function is propagated upwards
(with a <code>longjmp</code>).


<p>
The following example shows how the host program can do the
equivalent to this Lua code:

<pre>
     a = f("how", t.x, 14)
</pre><p>
Here it is in&nbsp;C:

<pre>
     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
</pre><p>
Note that the code above is <em>balanced</em>:
at its end, the stack is back to its original configuration.
This is considered good programming practice.





<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
This function behaves exactly like <a href="#lua_call"><code>lua_call</code></a>,
but allows the called function to yield (see <a href="#4.5">&sect;4.5</a>).





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
Type for C&nbsp;functions.


<p>
In order to communicate properly with Lua,
a C&nbsp;function must use the following protocol,
which defines the way parameters and results are passed:
a C&nbsp;function receives its arguments from Lua in its stack
in direct order (the first argument is pushed first).
So, when the function starts,
<code>lua_gettop(L)</code> returns the number of arguments received by the function.
The first argument (if any) is at index 1
and its last argument is at index <code>lua_gettop(L)</code>.
To return values to Lua, a C&nbsp;function just pushes them onto the stack,
in direct order (the first result is pushed first),
and returns in C the number of results.
Any other value in the stack below the results will be properly
discarded by Lua.
Like a Lua function, a C&nbsp;function called by Lua can also return
many results.


<p>
As an example, the following function receives a variable number
of numeric arguments and returns their average and their sum:

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* number of arguments */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
Ensures that the stack has space for at least <code>n</code> extra elements,
that is, that you can safely push up to <code>n</code> values into it.
It returns false if it cannot fulfill the request,
either because it would cause the stack
to be greater than a fixed maximum size
(typically at least several thousand elements) or
because it cannot allocate memory for the extra space.
This function never shrinks the stack;
if the stack already has space for the extra elements,
it is left unchanged.





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
Close all active to-be-closed variables in the main thread,
release all objects in the given Lua state
(calling the corresponding garbage-collection metamethods, if any),
and frees all dynamic memory used by this state.


<p>
On several platforms, you may not need to call this function,
because all resources are naturally released when the host program ends.
On the other hand, long-running programs that create multiple states,
such as daemons or web servers,
will probably need to close states as soon as they are not needed.





<hr><h3><a name="lua_closeslot"><code>lua_closeslot</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_closeslot (lua_State *L, int index);</pre>

<p>
Close the to-be-closed slot at the given index and set its value to <b>nil</b>.
The index must be the last index previously marked to be closed
(see <a href="#lua_toclose"><code>lua_toclose</code></a>) that is still active (that is, not closed yet).


<p>
A <code>__close</code> metamethod cannot yield
when called through this function.





<hr><h3><a name="lua_closethread"><code>lua_closethread</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int lua_closethread (lua_State *L, lua_State *from);</pre>

<p>
Resets a thread, cleaning its call stack and closing all pending
to-be-closed variables.
The parameter <code>from</code> represents the coroutine that is resetting <code>L</code>.
If there is no such coroutine,
this parameter can be <code>NULL</code>.


<p>
Unless <code>L</code> is equal to <code>from</code>,
the call returns a status code:
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> for no errors in the thread
(either the original error that stopped the thread or
errors in closing methods),
or an error status otherwise.
In case of error,
the error object is put on the top of the stack.


<p>
If <code>L</code> is equal to <code>from</code>,
it corresponds to a thread closing itself.
In that case,
the call does not return;
instead, the resume that (re)started the thread returns.
The thread must be running inside a resume.





<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
Compares two Lua values.
Returns 1 if the value at index <code>index1</code> satisfies <code>op</code>
when compared with the value at index <code>index2</code>,
following the semantics of the corresponding Lua operator
(that is, it may call metamethods).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices is not valid.


<p>
The value of <code>op</code> must be one of the following constants:

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a></b>:  compares for equality (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a></b>:  compares for less than (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a></b>:  compares for less or equal (<code>&lt;=</code>)</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
Concatenates the <code>n</code> values at the top of the stack,
pops them, and leaves the result on the top.
If <code>n</code>&nbsp;is&nbsp;1, the result is the single value on the stack
(that is, the function does nothing);
if <code>n</code> is 0, the result is the empty string.
Concatenation is performed following the usual semantics of Lua
(see <a href="#3.4.6">&sect;3.4.6</a>).





<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
Copies the element at index <code>fromidx</code>
into the valid index <code>toidx</code>,
replacing the value at that position.
Values at other positions are not affected.





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_createtable (lua_State *L, int nseq, int nrec);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
Parameter <code>nseq</code> is a hint for how many elements the table
will have as a sequence;
parameter <code>nrec</code> is a hint for how many other elements
the table will have.
Lua may use these hints to preallocate memory for the new table.
This preallocation may help performance when you know in advance
how many elements the table will have.
Otherwise you should use the function <a href="#lua_newtable"><code>lua_newtable</code></a>.





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
Dumps a function as a binary chunk.
Receives a Lua function on the top of the stack
and produces a binary chunk that,
if loaded again,
results in a function equivalent to the one dumped.
As it produces parts of the chunk,
<a href="#lua_dump"><code>lua_dump</code></a> calls function <code>writer</code> (see <a href="#lua_Writer"><code>lua_Writer</code></a>)
with the given <code>data</code>
to write them.


<p>
The function <a href="#lua_dump"><code>lua_dump</code></a> fully preserves the Lua stack
through the calls to the writer function,
except that it may push some values for internal use
before the first call,
and it restores the stack size to its original size
after the last call.


<p>
If <code>strip</code> is true,
the binary representation may not include all debug information
about the function,
to save space.


<p>
The value returned is the error code returned by the last
call to the writer;
0&nbsp;means no errors.





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
Raises a Lua error,
using the value on the top of the stack as the error object.
This function does a long jump,
and therefore never returns
(see <a href="#luaL_error"><code>luaL_error</code></a>).





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gc (lua_State *L, int what, ...);</pre>

<p>
Controls the garbage collector.


<p>
This function performs several tasks,
according to the value of the parameter <code>what</code>.
For options that need extra arguments,
they are listed after the option.

<ul>

<li><b><a name="pdf-LUA_GCCOLLECT"><code>LUA_GCCOLLECT</code></a></b>: 
Performs a full garbage-collection cycle.
</li>

<li><b><a name="pdf-LUA_GCSTOP"><code>LUA_GCSTOP</code></a></b>: 
Stops the garbage collector.
</li>

<li><b><a name="pdf-LUA_GCRESTART"><code>LUA_GCRESTART</code></a></b>: 
Restarts the garbage collector.
</li>

<li><b><a name="pdf-LUA_GCCOUNT"><code>LUA_GCCOUNT</code></a></b>: 
Returns the current amount of memory (in Kbytes) in use by Lua.
</li>

<li><b><a name="pdf-LUA_GCCOUNTB"><code>LUA_GCCOUNTB</code></a></b>: 
Returns the remainder of dividing the current amount of bytes of
memory in use by Lua by 1024.
</li>

<li><b><a name="pdf-LUA_GCSTEP"><code>LUA_GCSTEP</code></a> (size_t n)</b>: 
Performs a step of garbage collection.
</li>

<li><b><a name="pdf-LUA_GCISRUNNING"><code>LUA_GCISRUNNING</code></a></b>: 
Returns a boolean that tells whether the collector is running
(i.e., not stopped).
</li>

<li><b><a name="pdf-LUA_GCINC"><code>LUA_GCINC</code></a></b>: 
Changes the collector to incremental mode.
Returns the previous mode (<code>LUA_GCGEN</code> or <code>LUA_GCINC</code>).
</li>

<li><b><a name="pdf-LUA_GCGEN"><code>LUA_GCGEN</code></a></b>: 
Changes the collector to generational mode.
Returns the previous mode (<code>LUA_GCGEN</code> or <code>LUA_GCINC</code>).
</li>

<li><b><a name="pdf-LUA_GCPARAM"><code>LUA_GCPARAM</code></a> (int param, int val)</b>: 
Changes and/or returns the value of a parameter of the collector.
If <code>val</code> is -1, the call only returns the current value.
The argument <code>param</code> must have one of the following values:

<ul>
<li><b><a name="pdf-LUA_GCPMINORMUL"><code>LUA_GCPMINORMUL</code></a></b>:  The minor multiplier. </li>
<li><b><a name="pdf-LUA_GCPMAJORMINOR"><code>LUA_GCPMAJORMINOR</code></a></b>:  The major-minor multiplier. </li>
<li><b><a name="pdf-LUA_GCPMINORMAJOR"><code>LUA_GCPMINORMAJOR</code></a></b>:  The minor-major multiplier. </li>
<li><b><a name="pdf-LUA_GCPPAUSE"><code>LUA_GCPPAUSE</code></a></b>:  The garbage-collector pause. </li>
<li><b><a name="pdf-LUA_GCPSTEPMUL"><code>LUA_GCPSTEPMUL</code></a></b>:  The step multiplier. </li>
<li><b><a name="pdf-LUA_GCPSTEPSIZE"><code>LUA_GCPSTEPSIZE</code></a></b>:  The step size. </li>
</ul><p>
</li>

</ul>

<p>
For more details about these options,
see <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>.


<p>
This function should not be called by a finalizer.





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
Returns the memory-allocator function of a given state.
If <code>ud</code> is not <code>NULL</code>, Lua stores in <code>*ud</code> the
opaque pointer given when the memory-allocator function was set.





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given index.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
Returns a pointer to a raw memory area associated with the
given Lua state.
The application can use this area for any purpose;
Lua does not use it for anything.


<p>
Each new thread has this area initialized with a copy
of the area of the main thread.


<p>
By default, this area has the size of a pointer to void,
but you can recompile Lua with a different size for this area.
(See <code>LUA_EXTRASPACE</code> in <code>luaconf.h</code>.)





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
Pushes onto the stack the value of the global <code>name</code>.
Returns the type of that value.





<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Pushes onto the stack the value <code>t[i]</code>,
where <code>t</code> is the value at the given index.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
If the value at the given index has a metatable,
the function pushes that metatable onto the stack and returns&nbsp;1.
Otherwise,
the function returns&nbsp;0 and pushes nothing on the stack.





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given index
and <code>k</code> is the value on the top of the stack.


<p>
This function pops the key from the stack,
pushing the resulting value in its place.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
Returns the index of the top element in the stack.
Because indices start at&nbsp;1,
this result is equal to the number of elements in the stack;
in particular, 0&nbsp;means an empty stack.





<hr><h3><a name="lua_getiuservalue"><code>lua_getiuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getiuservalue (lua_State *L, int index, int n);</pre>

<p>
Pushes onto the stack the <code>n</code>-th user value associated with the
full userdata at the given index and
returns the type of the pushed value.


<p>
If the userdata does not have that value,
pushes <b>nil</b> and returns <a href="#pdf-LUA_TNONE"><code>LUA_TNONE</code></a>.





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index,
shifting up the elements above this index to open space.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
The type of integers in Lua.


<p>
By default this type is <code>long long</code>,
(usually a 64-bit two's complement integer),
but that can be changed to <code>long</code> or <code>int</code>
(usually a 32-bit two's complement integer).
(See <code>LUA_INT_TYPE</code> in <code>luaconf.h</code>.)


<p>
Lua also defines the constants
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a> and <a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>,
with the minimum and the maximum values that fit in this type.





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a boolean,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a C&nbsp;function,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a function
(either C or Lua), and 0&nbsp;otherwise.





<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is an integer
(that is, the value is a number and is represented as an integer),
and 0&nbsp;otherwise.





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a light userdata,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is <b>nil</b>,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
Returns 1 if the given index is not valid,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
Returns 1 if the given index is not valid
or if the value at this index is <b>nil</b>,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a number
or a string convertible to a number,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a string
or a number (which is always convertible to a string),
and 0&nbsp;otherwise.





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a table,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a thread,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a userdata
(either full or light), and 0&nbsp;otherwise.





<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
Returns 1 if the given coroutine can yield,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
The type for continuation-function contexts.
It must be a numeric type.
This type is defined as <code>intptr_t</code>
when <code>intptr_t</code> is available,
so that it can store pointers too.
Otherwise, it is defined as <code>ptrdiff_t</code>.





<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
Type for continuation functions (see <a href="#4.5">&sect;4.5</a>).





<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
Returns the length of the value at the given index.
It is equivalent to the '<code>#</code>' operator in Lua (see <a href="#3.4.7">&sect;3.4.7</a>) and
may trigger a metamethod for the "length" event (see <a href="#2.4">&sect;2.4</a>).
The result is pushed on the stack.





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
Loads a Lua chunk without running it.
If there are no errors,
<code>lua_load</code> pushes the compiled chunk as a Lua
function on top of the stack.
Otherwise, it pushes an error message.


<p>
The <code>lua_load</code> function uses a user-supplied <code>reader</code> function
to read the chunk (see <a href="#lua_Reader"><code>lua_Reader</code></a>).
The <code>data</code> argument is an opaque value passed to the reader function.


<p>
The <code>chunkname</code> argument gives a name to the chunk,
which is used for error messages and in debug information (see <a href="#4.7">&sect;4.7</a>).


<p>
<code>lua_load</code> automatically detects whether the chunk is text or binary
and loads it accordingly (see program <code>luac</code>).
The string <code>mode</code> works as in function <a href="#pdf-load"><code>load</code></a>,
with the addition that
a <code>NULL</code> value is equivalent to the string "<code>bt</code>".
Moreover, it may have a '<code>B</code>' instead of a '<code>b</code>',
meaning a <em>fixed buffer</em> with the binary dump.


<p>
A fixed buffer means that the address returned by the reader function
will contain the chunk until everything created by the chunk has
been collected;
therefore, Lua can avoid copying to internal structures
some parts of the chunk.
(In general, a fixed buffer would keep its contents
until the end of the program,
for instance with the chunk in ROM.)
Moreover, for a fixed buffer,
the reader function should return the entire chunk in the first read.
(As an example, <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a> does that,
which means that you can use it to load fixed buffers.)


<p>
The function <a href="#lua_load"><code>lua_load</code></a> fully preserves the Lua stack
through the calls to the reader function,
except that it may push some values for internal use
before the first call,
and it restores the stack size to its original size plus one
(for the pushed result) after the last call.


<p>
<code>lua_load</code> can return
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>, <a href="#pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>, or <a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>.
The function may also return other values corresponding to
errors raised by the read function (see <a href="#4.4.1">&sect;4.4.1</a>).


<p>
If the resulting function has upvalues,
its first upvalue is set to the value of the global environment
stored at index <code>LUA_RIDX_GLOBALS</code> in the registry (see <a href="#4.3">&sect;4.3</a>).
When loading main chunks,
this upvalue will be the <code>_ENV</code> variable (see <a href="#2.2">&sect;2.2</a>).
Other upvalues are initialized with <b>nil</b>.





<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud,
                                   unsigned int seed);</pre>

<p>
Creates a new independent state and returns its main thread.
Returns <code>NULL</code> if it cannot create the state
(due to lack of memory).
The argument <code>f</code> is the allocator function;
Lua will do all memory allocation for this state
through this function (see <a href="#lua_Alloc"><code>lua_Alloc</code></a>).
The second argument, <code>ud</code>, is an opaque pointer that Lua
passes to the allocator in every call.
The third argument, <code>seed</code>,
is a seed for the hashing of strings.





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
It is equivalent to <code>lua_createtable(L,0,0)</code>.





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
Creates a new thread, pushes it on the stack,
and returns a pointer to a <a href="#lua_State"><code>lua_State</code></a> that represents this new thread.
The new thread returned by this function shares with the original thread
its global environment,
but has an independent execution stack.


<p>
Threads are subject to garbage collection,
like any Lua object.





<hr><h3><a name="lua_newuserdatauv"><code>lua_newuserdatauv</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue);</pre>

<p>
This function creates and pushes on the stack a new full userdata,
with <code>nuvalue</code> associated Lua values, called <code>user values</code>,
plus an associated block of raw memory with <code>size</code> bytes.
(The user values can be set and read with the functions
<a href="#lua_setiuservalue"><code>lua_setiuservalue</code></a> and <a href="#lua_getiuservalue"><code>lua_getiuservalue</code></a>.)


<p>
The function returns the address of the block of memory.
Lua ensures that this address is valid as long as
the corresponding userdata is alive (see <a href="#2.5">&sect;2.5</a>).
Moreover, if the userdata is marked for finalization (see <a href="#2.5.3">&sect;2.5.3</a>),
its address is valid at least until the call to its finalizer.





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>v</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
Pops a key from the stack,
and pushes a key&ndash;value pair from the table at the given index,
the "next" pair after the given key.
If there are no more elements in the table,
then <a href="#lua_next"><code>lua_next</code></a> returns&nbsp;0 and pushes nothing.


<p>
A typical table traversal looks like this:

<pre>
     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }
</pre>

<p>
While traversing a table,
avoid calling <a href="#lua_tolstring"><code>lua_tolstring</code></a> directly on a key,
unless you know that the key is actually a string.
Recall that <a href="#lua_tolstring"><code>lua_tolstring</code></a> may change
the value at the given index;
this confuses the next call to <a href="#lua_next"><code>lua_next</code></a>.


<p>
This function may raise an error if the given key
is neither <b>nil</b> nor present in the table.
See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying
the table during its traversal.





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
The type of floats in Lua.


<p>
By default this type is double,
but that can be changed to a single float or a long double.
(See <code>LUA_FLOAT_TYPE</code> in <code>luaconf.h</code>.)





<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
Tries to convert a Lua float to a Lua integer;
the float <code>n</code> must have an integral value.
If that value is within the range of Lua integers,
it is converted to an integer and assigned to <code>*p</code>.
The macro results in a boolean indicating whether the
conversion was successful.
(Note that this range test can be tricky to do
correctly without this macro, due to rounding.)


<p>
This macro may evaluate its arguments more than once.





<hr><h3><a name="lua_numbertocstring"><code>lua_numbertocstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>unsigned lua_numbertocstring (lua_State *L, int idx,
                                        char *buff);</pre>

<p>
Converts the number at acceptable index <code>idx</code> to a string
and puts the result in <code>buff</code>.
The buffer must have a size of at least <a name="pdf-LUA_N2SBUFFSZ"><code>LUA_N2SBUFFSZ</code></a> bytes.
The conversion follows a non-specified format (see <a href="#3.4.3">&sect;3.4.3</a>).
The function returns the number of bytes written to the buffer
(including the final zero),
or zero if the value at <code>idx</code> is not a number.





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
Calls a function (or a callable object) in protected mode.


<p>
Both <code>nargs</code> and <code>nresults</code> have the same meaning as
in <a href="#lua_call"><code>lua_call</code></a>.
If there are no errors during the call,
<a href="#lua_pcall"><code>lua_pcall</code></a> behaves exactly like <a href="#lua_call"><code>lua_call</code></a>.
However, if there is any error,
<a href="#lua_pcall"><code>lua_pcall</code></a> catches it,
pushes a single value on the stack (the error object),
and returns an error code.
Like <a href="#lua_call"><code>lua_call</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a> always removes the function
and its arguments from the stack.


<p>
If <code>msgh</code> is 0,
then the error object returned on the stack
is exactly the original error object.
Otherwise, <code>msgh</code> is the stack index of a
<em>message handler</em>.
(This index cannot be a pseudo-index.)
In case of runtime errors,
this handler will be called with the error object
and its return value will be the object
returned on the stack by <a href="#lua_pcall"><code>lua_pcall</code></a>.


<p>
Typically, the message handler is used to add more debug
information to the error object, such as a stack traceback.
Such information cannot be gathered after the return of <a href="#lua_pcall"><code>lua_pcall</code></a>,
since by then the stack has unwound.


<p>
The <a href="#lua_pcall"><code>lua_pcall</code></a> function returns one of the following status codes:
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>, <a href="#pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>, <a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>, or <a href="#pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>.





<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
This function behaves exactly like <a href="#lua_pcall"><code>lua_pcall</code></a>,
except that it allows the called function to yield (see <a href="#4.5">&sect;4.5</a>).





<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, <em>e</em>]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
Pops <code>n</code> elements from the stack.
It is implemented as a macro over <a href="#lua_settop"><code>lua_settop</code></a>.





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
Pushes a boolean value with value <code>b</code> onto the stack.





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
Pushes a new C&nbsp;closure onto the stack.
This function receives a pointer to a C&nbsp;function
and pushes onto the stack a Lua value of type <code>function</code> that,
when called, invokes the corresponding C&nbsp;function.
The parameter <code>n</code> tells how many upvalues this function will have
(see <a href="#4.2">&sect;4.2</a>).


<p>
Any function to be callable by Lua must
follow the correct protocol to receive its parameters
and return its results (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
the so called upvalues;
these upvalues are then accessible to the function whenever it is called.
This association is called a C&nbsp;closure (see <a href="#4.2">&sect;4.2</a>).
To create a C&nbsp;closure,
first the initial values for its upvalues must be pushed onto the stack.
(When there are multiple upvalues, the first value is pushed first.)
Then <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
is called to create and push the C&nbsp;function onto the stack,
with the argument <code>n</code> telling how many values will be
associated with the function.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> also pops these values from the stack.


<p>
The maximum value for <code>n</code> is 255.


<p>
When <code>n</code> is zero,
this function creates a <em>light C&nbsp;function</em>,
which is just a pointer to the C&nbsp;function.
In that case, it never raises a memory error.





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Pushes a C&nbsp;function onto the stack.
This function is equivalent to <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> with no upvalues.





<hr><h3><a name="lua_pushexternalstring"><code>lua_pushexternalstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushexternalstring (lua_State *L,
                const char *s, size_t len, lua_Alloc falloc, void *ud);</pre>

<p>
Creates an <em>external string</em>,
that is, a string that uses memory not managed by Lua.
The pointer <code>s</code> points to the external buffer
holding the string content,
and <code>len</code> is the length of the string.
The string should have a zero at its end,
that is, the condition <code>s[len] == '\0'</code> should hold.
As with any string in Lua,
the length must fit in a Lua integer.


<p>
If <code>falloc</code> is different from <code>NULL</code>,
that function will be called by Lua
when the external buffer is no longer needed.
The contents of the buffer should not change before this call.
The function will be called with the given <code>ud</code>,
the string <code>s</code> as the block,
the length plus one (to account for the ending zero) as the old size,
and 0 as the new size.


<p>
Even when using an external buffer,
Lua still has to allocate a header for the string.
In case of a memory-allocation error,
Lua will call <code>falloc</code> before raising the error.


<p>
The function returns a pointer to the string (that is, <code>s</code>).





<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
Pushes onto the stack a formatted string
and returns a pointer to this string (see <a href="#4.1.3">&sect;4.1.3</a>).
The result is a copy of <code>fmt</code> with
each <em>conversion specifier</em> replaced by a string representation
of its respective extra argument.
A conversion specifier (and its corresponding extra argument) can be
'<code>%%</code>' (inserts the character '<code>%</code>'),
'<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
'<code>%f</code>' (inserts a <a href="#lua_Number"><code>lua_Number</code></a>),
'<code>%I</code>' (inserts a <a href="#lua_Integer"><code>lua_Integer</code></a>),
'<code>%p</code>' (inserts a void pointer),
'<code>%d</code>' (inserts an <code>int</code>),
'<code>%c</code>' (inserts an <code>int</code> as a one-byte character), and
'<code>%U</code>' (inserts an <code>unsigned long</code> as a UTF-8 byte sequence).


<p>
Every occurrence of '<code>%</code>' in the string <code>fmt</code>
must form a valid conversion specifier.


<p>
Besides memory allocation errors,
this function may raise an error if the resulting string is too large.





<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
Pushes the global environment onto the stack.





<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
Pushes an integer with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
Pushes a light userdata onto the stack.


<p>
Userdata represent C&nbsp;values in Lua.
A <em>light userdata</em> represents a pointer, a <code>void*</code>.
It is a value (like a number):
you do not create it, it has no individual metatable,
and it is not collected (as it was never created).
A light userdata is equal to "any"
light userdata with the same C&nbsp;address.





<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
This macro is equivalent to <a href="#lua_pushstring"><code>lua_pushstring</code></a>,
but should be used only when <code>s</code> is a literal string.
(Lua may optimize this case.)





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>v</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
Pushes the string pointed to by <code>s</code> with size <code>len</code>
onto the stack.
Lua will make or reuse an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.
The string can contain any binary data,
including embedded zeros.


<p>
Returns a pointer to the internal copy of the string (see <a href="#4.1.3">&sect;4.1.3</a>).


<p>
Besides memory allocation errors,
this function may raise an error if the string is too large.





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
Pushes a nil value onto the stack.





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
Pushes a float with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
Pushes the zero-terminated string pointed to by <code>s</code>
onto the stack.
Lua will make or reuse an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.


<p>
Returns a pointer to the internal copy of the string (see <a href="#4.1.3">&sect;4.1.3</a>).


<p>
If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and returns <code>NULL</code>.





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
Pushes the thread represented by <code>L</code> onto the stack.
Returns 1 if this thread is the main thread of its state.





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
Pushes a copy of the element at the given index
onto the stack.





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
Equivalent to <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>,
except that it receives a <code>va_list</code>
instead of a variable number of arguments,
and it does not raise errors.
Instead, in case of errors it pushes the error message
and returns <code>NULL</code>.





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
Returns 1 if the two values in indices <code>index1</code> and
<code>index2</code> are primitively equal
(that is, equal without calling the <code>__eq</code> metamethod).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices are not valid.





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_gettable"><code>lua_gettable</code></a>, but does a raw access
(i.e., without metamethods).
The value at <code>index</code> must be a table.





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Pushes onto the stack the value <code>t[n]</code>,
where <code>t</code> is the table at the given index.
The access is raw,
that is, it does not use the <code>__index</code> metavalue.


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the table at the given index and
<code>k</code> is the pointer <code>p</code> represented as a light userdata.
The access is raw;
that is, it does not use the <code>__index</code> metavalue.


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Unsigned lua_rawlen (lua_State *L, int index);</pre>

<p>
Returns the raw "length" of the value at the given index:
for strings, this is the string length;
for tables, this is the result of the length operator ('<code>#</code>')
with no metamethods;
for userdata, this is the size of the block of memory allocated
for the userdata.
For other values, this call returns&nbsp;0.





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_settable"><code>lua_settable</code></a>, but does a raw assignment
(i.e., without metamethods).
The value at <code>index</code> must be a table.





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Does the equivalent of <code>t[i] = v</code>,
where <code>t</code> is the table at the given index
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not use the <code>__newindex</code> metavalue.





<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
Does the equivalent of <code>t[p] = v</code>,
where <code>t</code> is the table at the given index,
<code>p</code> is encoded as a light userdata,
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not use the <code>__newindex</code> metavalue.





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
The reader function used by <a href="#lua_load"><code>lua_load</code></a>.
Every time <a href="#lua_load"><code>lua_load</code></a> needs another piece of the chunk,
it calls the reader,
passing along its <code>data</code> parameter.
The reader must return a pointer to a block of memory
with a new piece of the chunk
and set <code>size</code> to the block size.
The block must exist until the reader function is called again.
To signal the end of the chunk,
the reader must return <code>NULL</code> or set <code>size</code> to zero.
The reader function may return pieces of any size greater than zero.





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
Sets the C&nbsp;function <code>f</code> as the new value of global <code>name</code>.
It is defined as a macro:

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
Removes the element at the given valid index,
shifting down the elements above this index to fill the gap.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index
without shifting any element
(therefore replacing the value at that given index),
and then pops the top element.





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs,
                          int *nresults);</pre>

<p>
Starts and resumes a coroutine in the given thread <code>L</code>.


<p>
To start a coroutine,
you push the main function plus any arguments
onto the empty stack of the thread.
then you call <a href="#lua_resume"><code>lua_resume</code></a>,
with <code>nargs</code> being the number of arguments.
The function returns when the coroutine suspends,
finishes its execution, or raises an unprotected error.
When it returns without errors,
<code>*nresults</code> is updated and
the top of the stack contains
the <code>*nresults</code> values passed to <a href="#lua_yield"><code>lua_yield</code></a>
or returned by the body function.
<a href="#lua_resume"><code>lua_resume</code></a> returns
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the coroutine yields,
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> if the coroutine finishes its execution
without errors,
or an error code in case of errors (see <a href="#4.4.1">&sect;4.4.1</a>).
In case of errors,
the error object is pushed on the top of the stack.
(In that case, <code>nresults</code> is not updated,
as its value would have to be 1 for the sole error object.)


<p>
To resume a suspended coroutine,
you remove the <code>*nresults</code> yielded values from its stack,
push the values to be passed as results from <code>yield</code>,
and then call <a href="#lua_resume"><code>lua_resume</code></a>.


<p>
The parameter <code>from</code> represents the coroutine that is resuming <code>L</code>.
If there is no such coroutine,
this parameter can be <code>NULL</code>.





<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
Rotates the stack elements between the valid index <code>idx</code>
and the top of the stack.
The elements are rotated <code>n</code> positions in the direction of the top,
for a positive <code>n</code>,
or <code>-n</code> positions in the direction of the bottom,
for a negative <code>n</code>.
The absolute value of <code>n</code> must not be greater than the size
of the slice being rotated.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
Changes the allocator function of a given state to <code>f</code>
with user data <code>ud</code>.





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
Pops a value from the stack and
sets it as the new value of global <code>name</code>.





<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Does the equivalent to <code>t[n] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value on the top of the stack.


<p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_setiuservalue"><code>lua_setiuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>int lua_setiuservalue (lua_State *L, int index, int n);</pre>

<p>
Pops a value from the stack and sets it as
the new <code>n</code>-th user value associated to the
full userdata at the given index.
Returns 0 if the userdata does not have that value.





<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>int lua_setmetatable (lua_State *L, int index);</pre>

<p>
Pops a table or <b>nil</b> from the stack and
sets that value as the new metatable for the value at the given index.
(<b>nil</b> means no metatable.)


<p>
(For historical reasons, this function returns an <code>int</code>,
which now is always 1.)





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index,
<code>v</code> is the value on the top of the stack,
and <code>k</code> is the value just below the top.


<p>
This function pops both the key and the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
Receives any acceptable stack index, or&nbsp;0,
and sets the stack top to this index.
If the new top is greater than the old one,
then the new elements are filled with <b>nil</b>.
If <code>index</code> is&nbsp;0, then all stack elements are removed.


<p>
This function can run arbitrary code when removing an index
marked as to-be-closed from the stack.





<hr><h3><a name="lua_setwarnf"><code>lua_setwarnf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud);</pre>

<p>
Sets the warning function to be used by Lua to emit warnings
(see <a href="#lua_WarnFunction"><code>lua_WarnFunction</code></a>).
The <code>ud</code> parameter sets the value <code>ud</code> passed to
the warning function.





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
An opaque structure that points to a thread and indirectly
(through the thread) to the whole state of a Lua interpreter.
The Lua library is fully reentrant:
it has no global variables.
All information about a state is accessible through this structure.


<p>
A pointer to this structure must be passed as the first argument to
every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,
which creates a Lua state from scratch.





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
Returns the status of the thread <code>L</code>.


<p>
The status can be <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> for a normal thread,
an error code if the thread finished the execution
of a <a href="#lua_resume"><code>lua_resume</code></a> with an error,
or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the thread is suspended.


<p>
You can call functions only in threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>.
You can resume threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
(to start a new coroutine) or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
(to resume a coroutine).





<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
Converts the zero-terminated string <code>s</code> to a number,
pushes that number into the stack,
and returns the total size of the string,
that is, its length plus one.
The conversion can result in an integer or a float,
according to the lexical conventions of Lua (see <a href="#3.1">&sect;3.1</a>).
The string may have leading and trailing whitespaces and a sign.
If the string is not a valid numeral,
returns 0 and pushes nothing.
(Note that the result can be used as a boolean,
true if the conversion succeeds.)





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;boolean
value (0&nbsp;or&nbsp;1).
Like all tests in Lua,
<a href="#lua_toboolean"><code>lua_toboolean</code></a> returns true for any Lua value
different from <b>false</b> and <b>nil</b>;
otherwise it returns false.
(If you want to accept only actual boolean values,
use <a href="#lua_isboolean"><code>lua_isboolean</code></a> to test the value's type.)





<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
Converts a value at the given index to a C&nbsp;function.
That value must be a C&nbsp;function;
otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_toclose"><code>lua_toclose</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void lua_toclose (lua_State *L, int index);</pre>

<p>
Marks the given index in the stack as a
to-be-closed slot (see <a href="#3.3.8">&sect;3.3.8</a>).
Like a to-be-closed variable in Lua,
the value at that slot in the stack will be closed
when it goes out of scope.
Here, in the context of a C function,
to go out of scope means that the running function returns to Lua,
or there is an error,
or the slot is removed from the stack through
<a href="#lua_settop"><code>lua_settop</code></a> or <a href="#lua_pop"><code>lua_pop</code></a>,
or there is a call to <a href="#lua_closeslot"><code>lua_closeslot</code></a>.
A slot marked as to-be-closed should not be removed from the stack
by any other function in the API except <a href="#lua_settop"><code>lua_settop</code></a> or <a href="#lua_pop"><code>lua_pop</code></a>,
unless previously deactivated by <a href="#lua_closeslot"><code>lua_closeslot</code></a>.


<p>
This function raises an error if the value at the given slot
neither has a <code>__close</code> metamethod nor is a false value.


<p>
This function should not be called for an index
that is equal to or below an active to-be-closed slot.


<p>
Note that, both in case of errors and of a regular return,
by the time the <code>__close</code> metamethod runs,
the C&nbsp;stack was already unwound,
so that any automatic C&nbsp;variable declared in the calling function
(e.g., a buffer) will be out of scope.





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tointegerx"><code>lua_tointegerx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the signed integral type <a href="#lua_Integer"><code>lua_Integer</code></a>.
The Lua value must be an integer,
or a number or string convertible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>);
otherwise, <code>lua_tointegerx</code> returns&nbsp;0.


<p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;string.
The Lua value must be a string or a number;
otherwise, the function returns <code>NULL</code>.
If the value is a number,
then <code>lua_tolstring</code> also
<em>changes the actual value in the stack to a string</em>.
(This change confuses <a href="#lua_next"><code>lua_next</code></a>
when <code>lua_tolstring</code> is applied to keys during a table traversal.)


<p>
If <code>len</code> is not <code>NULL</code>,
the function sets <code>*len</code> with the string length.
The returned C&nbsp;string always has a zero ('<code>\0</code>')
after its last character,
but can contain other zeros in its body.


<p>
The pointer returned by <code>lua_tolstring</code>
may be invalidated by the garbage collector if the
corresponding Lua value is removed from the stack (see <a href="#4.1.3">&sect;4.1.3</a>).


<p>
This function can raise memory errors only
when converting a number to a string
(as then it may create a new string).





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the C&nbsp;type <a href="#lua_Number"><code>lua_Number</code></a> (see <a href="#lua_Number"><code>lua_Number</code></a>).
The Lua value must be a number or a string convertible to a number
(see <a href="#3.4.3">&sect;3.4.3</a>);
otherwise, <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> returns&nbsp;0.


<p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a generic
C&nbsp;pointer (<code>void*</code>).
The value can be a userdata, a table, a thread, a string, or a function;
otherwise, <code>lua_topointer</code> returns <code>NULL</code>.
Different objects will give different pointers.
There is no way to convert the pointer back to its original value.


<p>
Typically this function is used only for hashing and debug information.





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tolstring"><code>lua_tolstring</code></a> with <code>len</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a Lua thread
(represented as <code>lua_State*</code>).
This value must be a thread;
otherwise, the function returns <code>NULL</code>.





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
If the value at the given index is a full userdata,
returns its memory-block address.
If the value is a light userdata,
returns its value (a pointer).
Otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
Returns the type of the value in the given valid index,
or <code>LUA_TNONE</code> for a non-valid but acceptable index.
The types returned by <a href="#lua_type"><code>lua_type</code></a> are coded by the following constants
defined in <code>lua.h</code>:
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>,
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>,
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>,
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>,
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>,
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>,
and
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>.





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
Returns the name of the type encoded by the value <code>tp</code>,
which must be one the values returned by <a href="#lua_type"><code>lua_type</code></a>.





<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
The unsigned version of <a href="#lua_Integer"><code>lua_Integer</code></a>.





<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
Returns the pseudo-index that represents the <code>i</code>-th upvalue of
the running function (see <a href="#4.2">&sect;4.2</a>).
<code>i</code> must be in the range <em>[1,256]</em>.





<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_version (lua_State *L);</pre>

<p>
Returns the version number of this core.





<hr><h3><a name="lua_WarnFunction"><code>lua_WarnFunction</code></a></h3>
<pre>typedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);</pre>

<p>
The type of warning functions, called by Lua to emit warnings.
The first parameter is an opaque pointer
set by <a href="#lua_setwarnf"><code>lua_setwarnf</code></a>.
The second parameter is the warning message.
The third parameter is a boolean that
indicates whether the message is
to be continued by the message in the next call.


<p>
See <a href="#pdf-warn"><code>warn</code></a> for more details about warnings.





<hr><h3><a name="lua_warning"><code>lua_warning</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_warning (lua_State *L, const char *msg, int tocont);</pre>

<p>
Emits a warning with the given message.
A message in a call with <code>tocont</code> true should be
continued in another call to this function.


<p>
See <a href="#pdf-warn"><code>warn</code></a> for more details about warnings.





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
The type of the writer function used by <a href="#lua_dump"><code>lua_dump</code></a>.
Every time <a href="#lua_dump"><code>lua_dump</code></a> produces another piece of chunk,
it calls the writer,
passing along the buffer to be written (<code>p</code>),
its size (<code>sz</code>),
and the <code>ud</code> parameter supplied to <a href="#lua_dump"><code>lua_dump</code></a>.


<p>
After <a href="#lua_dump"><code>lua_dump</code></a> writes its last piece,
it will signal that by calling the writer function one more time,
with a <code>NULL</code> buffer (and size 0).


<p>
The writer returns an error code:
0&nbsp;means no errors;
any other value means an error and stops <a href="#lua_dump"><code>lua_dump</code></a> from
calling the writer again.





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
Exchange values between different threads of the same state.


<p>
This function pops <code>n</code> values from the stack <code>from</code>,
and pushes them onto the stack <code>to</code>.





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
This function is equivalent to <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
but it has no continuation (see <a href="#4.5">&sect;4.5</a>).
Therefore, when the thread resumes,
it continues the function that called
the function calling <code>lua_yield</code>.
To avoid surprises,
this function should be called only in a tail call.





<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>v</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
Yields a coroutine (thread).


<p>
When a C&nbsp;function calls <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
the running coroutine suspends its execution,
and the call to <a href="#lua_resume"><code>lua_resume</code></a> that started this coroutine returns.
The parameter <code>nresults</code> is the number of values from the stack
that will be passed as results to <a href="#lua_resume"><code>lua_resume</code></a>.


<p>
When the coroutine is resumed again,
Lua calls the given continuation function <code>k</code> to continue
the execution of the C&nbsp;function that yielded (see <a href="#4.5">&sect;4.5</a>).
This continuation function receives the same stack
from the previous function,
with the <code>n</code> results removed and
replaced by the arguments passed to <a href="#lua_resume"><code>lua_resume</code></a>.
Moreover,
the continuation function receives the value <code>ctx</code>
that was passed to <a href="#lua_yieldk"><code>lua_yieldk</code></a>.


<p>
Usually, this function does not return;
when the coroutine eventually resumes,
it continues executing the continuation function.
However, there is one special case,
which is when this function is called
from inside a line or a count hook (see <a href="#4.7">&sect;4.7</a>).
In that case, <code>lua_yieldk</code> should be called with no continuation
(probably in the form of <a href="#lua_yield"><code>lua_yield</code></a>) and no results,
and the hook should return immediately after the call.
Lua will yield and,
when the coroutine resumes again,
it will continue the normal execution
of the (Lua) function that triggered the hook.


<p>
This function can raise an error if it is called from a thread
with a pending C call with no continuation function
(what is called a <em>C-call boundary</em>),
or it is called from a thread that is not running inside a resume
(typically the main thread).







<h2>4.7 &ndash; <a name="4.7">The Debug Interface</a></h2>

<p>
Lua has no built-in debugging facilities.
Instead, it offers a special interface
by means of functions and <em>hooks</em>.
This interface allows the construction of different
kinds of debuggers, profilers, and other tools
that need "inside information" from the interpreter.



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  size_t srclen;              /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  unsigned char extraargs;    /* (t) number of extra arguments */
  char istailcall;            /* (t) */
  int ftransfer;              /* (r) index of first value transferred */
  int ntransfer;              /* (r) number of transferred values */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>
A structure used to carry different pieces of
information about a function or an activation record.
<a href="#lua_getstack"><code>lua_getstack</code></a> fills only the private part
of this structure, for later use.
To fill the other fields of <a href="#lua_Debug"><code>lua_Debug</code></a> with useful information,
you must call <a href="#lua_getinfo"><code>lua_getinfo</code></a> with an appropriate parameter.
(Specifically, to get a field,
you must add the letter between parentheses in the field's comment
to the parameter <code>what</code> of <a href="#lua_getinfo"><code>lua_getinfo</code></a>.)


<p>
The fields of <a href="#lua_Debug"><code>lua_Debug</code></a> have the following meaning:

<ul>

<li><b><code>source</code></b>: 
the source of the chunk that created the function.
If <code>source</code> starts with a '<code>@</code>',
it means that the function was defined in a file where
the file name follows the '<code>@</code>'.
If <code>source</code> starts with a '<code>=</code>',
the remainder of its contents describes the source in a user-dependent manner.
Otherwise,
the function was defined in a string where
<code>source</code> is that string.
</li>

<li><b><code>srclen</code></b>: 
The length of the string <code>source</code>.
</li>

<li><b><code>short_src</code></b>: 
a "printable" version of <code>source</code>, to be used in error messages.
</li>

<li><b><code>linedefined</code></b>: 
the line number where the definition of the function starts.
</li>

<li><b><code>lastlinedefined</code></b>: 
the line number where the definition of the function ends.
</li>

<li><b><code>what</code></b>: 
the string <code>"Lua"</code> if the function is a Lua function,
<code>"C"</code> if it is a C&nbsp;function,
<code>"main"</code> if it is the main part of a chunk.
</li>

<li><b><code>currentline</code></b>: 
the current line where the given function is executing.
When no line information is available,
<code>currentline</code> is set to -1.
</li>

<li><b><code>name</code></b>: 
a reasonable name for the given function.
Because functions in Lua are first-class values,
they do not have a fixed name:
some functions can be the value of multiple global variables,
while others can be stored only in a table field.
The <code>lua_getinfo</code> function checks how the function was
called to find a suitable name.
If it cannot find a name,
then <code>name</code> is set to <code>NULL</code>.
</li>

<li><b><code>namewhat</code></b>: 
explains the <code>name</code> field.
The value of <code>namewhat</code> can be
<code>"global"</code>, <code>"local"</code>, <code>"upvalue"</code>,
<code>"field"</code>, <code>""</code> (the empty string), plus some other options,
according to how the function was called.
(Lua uses the empty string when no other option seems to apply.)
</li>

<li><b><code>istailcall</code></b>: 
true if this function invocation was called by a tail call.
In this case, the caller of this level is not in the stack.
</li>

<li><b><code>extraargs</code></b>: 
The number of extra arguments added by the call
to functions called through <code>__call</code> metamethods.
(Each <code>__call</code> metavalue adds a single extra argument,
the object being called,
but there may be a chain of <code>__call</code> metavalues.)
</li>

<li><b><code>nups</code></b>: 
the number of upvalues of the function.
</li>

<li><b><code>nparams</code></b>: 
the number of parameters of the function
(always 0&nbsp;for C&nbsp;functions).
</li>

<li><b><code>isvararg</code></b>: 
true if the function is a variadic function
(always true for C&nbsp;functions).
</li>

<li><b><code>ftransfer</code></b>: 
the index in the stack of the first value being "transferred",
that is, parameters in a call or return values in a return.
(The other values are in consecutive indices.)
Using this index, you can access and modify these values
through <a href="#lua_getlocal"><code>lua_getlocal</code></a> and <a href="#lua_setlocal"><code>lua_setlocal</code></a>.
This field is only meaningful during a
call hook, denoting the first parameter,
or a return hook, denoting the first value being returned.
(For call hooks, this value is always 1.)
</li>

<li><b><code>ntransfer</code></b>: 
The number of values being transferred (see previous item).
(For calls of Lua functions,
this value is always equal to <code>nparams</code>.)
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
Returns the current hook function.





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
Returns the current hook count.





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
Returns the current hook mask.





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
Gets information about a specific function or function invocation.


<p>
To get information about a function invocation,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).


<p>
To get information about a function, you push it onto the stack
and start the <code>what</code> string with the character '<code>&gt;</code>'.
(In that case,
<code>lua_getinfo</code> pops the function from the top of the stack.)
For instance, to know in which line a function <code>f</code> was defined,
you can write the following code:

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
Each character in the string <code>what</code>
selects some fields of the structure <code>ar</code> to be filled or
a value to be pushed on the stack.
(These characters are also documented in the declaration of
the structure <a href="#lua_Debug"><code>lua_Debug</code></a>,
between parentheses in the comments following each field.)

<ul>

<li><b>'<code>f</code>'</b>: 
pushes onto the stack the function that is
running at the given level;
</li>

<li><b>'<code>l</code>'</b>:  fills in the field <code>currentline</code>;
</li>

<li><b>'<code>n</code>'</b>:  fills in the fields <code>name</code> and <code>namewhat</code>;
</li>

<li><b>'<code>r</code>'</b>:  fills in the fields <code>ftransfer</code> and <code>ntransfer</code>;
</li>

<li><b>'<code>S</code>'</b>: 
fills in the fields <code>source</code>, <code>short_src</code>,
<code>linedefined</code>, <code>lastlinedefined</code>, and <code>what</code>;
</li>

<li><b>'<code>t</code>'</b>:  fills in the fields <code>istailcall</code> and <code>extraargs</code>;
</li>

<li><b>'<code>u</code>'</b>:  fills in the fields
<code>nups</code>, <code>nparams</code>, and <code>isvararg</code>;
</li>

<li><b>'<code>L</code>'</b>: 
pushes onto the stack a table whose indices are
the lines on the function with some associated code,
that is, the lines where you can put a break point.
(Lines with no code include empty lines and comments.)
If this option is given together with option '<code>f</code>',
its table is pushed after the function.
This is the only option that can raise a memory error.
</li>

</ul>

<p>
This function returns 0 to signal an invalid option in <code>what</code>;
even then the valid options are handled correctly.





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Gets information about a local variable or a temporary value
of a given activation record or a given function.


<p>
In the first case,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).
The index <code>n</code> selects which local variable to inspect;
see <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for details about variable indices
and names.


<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a> pushes the variable's value onto the stack
and returns its name.


<p>
In the second case, <code>ar</code> must be <code>NULL</code> and the function
to be inspected must be on the top of the stack.
In this case, only parameters of Lua functions are visible
(as there is no information about what variables are active)
and no values are pushed onto the stack.


<p>
Returns <code>NULL</code> (and pushes nothing)
when the index is greater than
the number of active local variables.





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
Gets information about the interpreter runtime stack.


<p>
This function fills parts of a <a href="#lua_Debug"><code>lua_Debug</code></a> structure with
an identification of the <em>activation record</em>
of the function executing at a given level.
Level&nbsp;0 is the current running function,
whereas level <em>n+1</em> is the function that has called level <em>n</em>
(except for tail calls, which do not count in the stack).
When called with a level greater than the stack depth,
<a href="#lua_getstack"><code>lua_getstack</code></a> returns 0;
otherwise it returns 1.





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Gets information about the <code>n</code>-th upvalue
of the closure at index <code>funcindex</code>.
It pushes the upvalue's value onto the stack
and returns its name.
Returns <code>NULL</code> (and pushes nothing)
when the index <code>n</code> is greater than the number of upvalues.


<p>
See <a href="#pdf-debug.getupvalue"><code>debug.getupvalue</code></a> for more information about upvalues.





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
Type for debugging hook functions.


<p>
Whenever a hook is called, its <code>ar</code> argument has its field
<code>event</code> set to the specific event that triggered the hook.
Lua identifies these events with the following constants:
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>,
and <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.
Moreover, for line events, the field <code>currentline</code> is also set.
To get the value of any other field in <code>ar</code>,
the hook must call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
For call events, <code>event</code> can be <code>LUA_HOOKCALL</code>,
the normal value, or <code>LUA_HOOKTAILCALL</code>, for a tail call;
in this case, there will be no corresponding return event.


<p>
While Lua is running a hook, it disables other calls to hooks.
Therefore, if a hook calls back Lua to execute a function or a chunk,
this execution occurs without any calls to hooks.


<p>
Hook functions cannot have continuations,
that is, they cannot call <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
<a href="#lua_pcallk"><code>lua_pcallk</code></a>, or <a href="#lua_callk"><code>lua_callk</code></a> with a non-null <code>k</code>.


<p>
Hook functions can yield under the following conditions:
Only count and line events can yield;
to yield, a hook function must finish its execution
calling <a href="#lua_yield"><code>lua_yield</code></a> with <code>nresults</code> equal to zero
(that is, with no values).





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
Sets the debugging hook function.


<p>
Argument <code>f</code> is the hook function.
<code>mask</code> specifies on which events the hook will be called:
it is formed by a bitwise OR of the constants
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>,
and <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.
The <code>count</code> argument is only meaningful when the mask
includes <code>LUA_MASKCOUNT</code>.
For each event, the hook is called as explained below:

<ul>

<li><b>The call hook</b>:  is called when the interpreter calls a function.
The hook is called just after Lua enters the new function.
</li>

<li><b>The return hook</b>:  is called when the interpreter returns from a function.
The hook is called just before Lua leaves the function.
</li>

<li><b>The line hook</b>:  is called when the interpreter is about to
start the execution of a new line of code,
or when it jumps back in the code (even to the same line).
This event only happens while Lua is executing a Lua function.
</li>

<li><b>The count hook</b>:  is called after the interpreter executes every
<code>count</code> instructions.
This event only happens while Lua is executing a Lua function.
</li>

</ul>

<p>
Hooks are disabled by setting <code>mask</code> to zero.





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Sets the value of a local variable of a given activation record.
It assigns the value on the top of the stack
to the variable and returns its name.
It also pops the value from the stack.


<p>
Returns <code>NULL</code> (and pops nothing)
when the index is greater than
the number of active local variables.


<p>
Parameters <code>ar</code> and <code>n</code> are as in the function <a href="#lua_getlocal"><code>lua_getlocal</code></a>.





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Sets the value of a closure's upvalue.
It assigns the value on the top of the stack
to the upvalue and returns its name.
It also pops the value from the stack.


<p>
Returns <code>NULL</code> (and pops nothing)
when the index <code>n</code> is greater than the number of upvalues.


<p>
Parameters <code>funcindex</code> and <code>n</code> are as in
the function <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>.





<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
Returns a unique identifier for the upvalue numbered <code>n</code>
from the closure at index <code>funcindex</code>.


<p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.


<p>
Parameters <code>funcindex</code> and <code>n</code> are as in
the function <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>,
but <code>n</code> cannot be greater than the number of upvalues.





<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
Make the <code>n1</code>-th upvalue of the Lua closure at index <code>funcindex1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure at index <code>funcindex2</code>.








</body>
</html>
