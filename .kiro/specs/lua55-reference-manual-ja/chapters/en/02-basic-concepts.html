<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 Reference Manual - Chapter 02</title>
</head>
<body>
<h1>2 &ndash; <a name="2">Basic Concepts</a></h1>



<p>
This section describes the basic concepts of the language.





<h2>2.1 &ndash; <a name="2.1">Values and Types</a></h2>

<p>
Lua is a dynamically typed language.
This means that
variables do not have types; only values do.
There are no type definitions in the language.
All values carry their own type.


<p>
All values in Lua are first-class values.
This means that all values can be stored in variables,
passed as arguments to other functions, and returned as results.


<p>
There are eight basic types in Lua:
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em>, and <em>table</em>.
The type <em>nil</em> has one single value, <b>nil</b>,
whose main property is to be different from any other value;
it often represents the absence of a useful value.
The type <em>boolean</em> has two values, <b>false</b> and <b>true</b>.
Both <b>nil</b> and <b>false</b> make a condition false;
they are collectively called <em>false values</em>.
Any other value makes a condition true.
Despite its name,
<b>false</b> is frequently used as an alternative to <b>nil</b>,
with the key difference that <b>false</b> behaves
like a regular value in a table,
while a <b>nil</b> in a table represents an absent key.


<p>
The type <em>number</em> represents both
integer numbers and real (floating-point) numbers,
using two subtypes: <em>integer</em> and <em>float</em>.
Standard Lua uses 64-bit integers and double-precision (64-bit) floats,
but you can also compile Lua so that it
uses 32-bit integers and/or single-precision (32-bit) floats.
The option with 32 bits for both integers and floats
is particularly attractive
for small machines and embedded systems.
(See macro <code>LUA_32BITS</code> in file <code>luaconf.h</code>.)


<p>
Unless stated otherwise,
any overflow when manipulating integer values <em>wrap around</em>,
according to the usual rules of two's complement arithmetic.
(In other words,
the actual result is the unique representable integer
that is equal modulo <em>2<sup>n</sup></em> to the mathematical result,
where <em>n</em> is the number of bits of the integer type.)


<p>
Lua has explicit rules about when each subtype is used,
but it also converts between them automatically as needed (see <a href="#3.4.3">&sect;3.4.3</a>).
Therefore,
the programmer may choose to mostly ignore the difference
between integers and floats
or to assume complete control over the representation of each number.


<p>
The type <em>string</em> represents immutable sequences of bytes.

Lua is 8-bit clean:
strings can contain any 8-bit value,
including embedded zeros ('<code>\0</code>').
Lua is also encoding-agnostic;
it makes no assumptions about the contents of a string.
The length of any string in Lua must fit in a Lua integer,
and the string plus a small header must fit in <code>size_t</code>.


<p>
Lua can call (and manipulate) functions written in Lua and
functions written in C (see <a href="#3.4.10">&sect;3.4.10</a>).
Both are represented by the type <em>function</em>.


<p>
The type <em>userdata</em> is provided to allow arbitrary C&nbsp;data to
be stored in Lua variables.
A userdata value represents a block of raw memory.
There are two kinds of userdata:
<em>full userdata</em>,
which is an object with a block of memory managed by Lua,
and <em>light userdata</em>,
which is simply a C&nbsp;pointer value.
Userdata has no predefined operations in Lua,
except assignment and identity test.
By using <em>metatables</em>,
the programmer can define operations for full userdata values
(see <a href="#2.4">&sect;2.4</a>).
Userdata values cannot be created or modified in Lua,
only through the C&nbsp;API.
This guarantees the integrity of data owned by
the host program and C&nbsp;libraries.


<p>
The type <em>thread</em> represents independent threads of execution
and it is used to implement coroutines (see <a href="#2.6">&sect;2.6</a>).
Lua threads are not related to operating-system threads.
Lua supports coroutines on all systems,
even those that do not support threads natively.


<p>
The type <em>table</em> implements associative arrays,
that is, arrays that can have as indices not only numbers,
but any Lua value except <b>nil</b> and NaN.
(<em>Not a Number</em> is a special floating-point value
used by the IEEE 754 standard to represent
undefined numerical results, such as <code>0/0</code>.)
Tables can be <em>heterogeneous</em>;
that is, they can contain values of all types (except <b>nil</b>).
Any key associated to the value <b>nil</b> is not considered part of the table.
Conversely, any key that is not part of a table has
an associated value <b>nil</b>.


<p>
Tables are the sole data-structuring mechanism in Lua;
they can be used to represent ordinary arrays, lists,
symbol tables, sets, records, graphs, trees, etc.
To represent records, Lua uses the field name as an index.
The language supports this representation by
providing <code>a.name</code> as syntactic sugar for <code>a["name"]</code>.
There are several convenient ways to create tables in Lua
(see <a href="#3.4.9">&sect;3.4.9</a>).


<p>
Like indices,
the values of table fields can be of any type.
In particular,
because functions are first-class values,
table fields can contain functions.
Thus tables can also carry <em>methods</em> (see <a href="#3.4.11">&sect;3.4.11</a>).


<p>
The indexing of tables follows
the definition of raw equality in the language.
The expressions <code>a[i]</code> and <code>a[j]</code>
denote the same table element
if and only if <code>i</code> and <code>j</code> are raw equal
(that is, equal without metamethods).
In particular, floats with integral values
are equal to their respective integers
(e.g., <code>1.0 == 1</code>).
To avoid ambiguities,
any float used as a key that is equal to an integer
is converted to that integer.
For instance, if you write <code>a[2.0] = true</code>,
the actual key inserted into the table will be the integer <code>2</code>.


<p>
Tables, functions, threads, and (full) userdata values are <em>objects</em>:
variables do not actually <em>contain</em> these values,
only <em>references</em> to them.
Assignment, parameter passing, and function returns
always manipulate references to such values;
these operations do not imply any kind of copy.


<p>
The library function <a href="#pdf-type"><code>type</code></a> returns a string describing the type
of a given value (see <a href="#pdf-type"><code>type</code></a>).





<h2>2.2 &ndash; <a name="2.2">Scopes, Variables, and Environments</a></h2>

<p>
A variable name refers to a global or a local variable according
to the declaration that is in context at that point of the code.
(For the purposes of this discussion,
a function's formal parameter is equivalent to a local variable.)


<p>
All chunks start with an implicit declaration <code>global *</code>,
which declares all free names as global variables;
this preambular declaration becomes void inside the scope of any other
<b>global</b> declaration,
as the following example illustrates:

<pre>
     X = 1       -- Ok, global by default
     do
       global Y  -- voids the implicit initial declaration
       Y = 1     -- Ok, Y declared as global
       X = 1     -- ERROR, X not declared
     end
     X = 2       -- Ok, global by default again
</pre><p>
So, outside any global declaration,
Lua works as global-by-default.
Inside any global declaration,
Lua works without a default:
All variables must be declared.


<p>
Lua is a lexically scoped language.
The scope of a variable declaration begins at the first statement after
the declaration and lasts until the last non-void statement
of the innermost block that includes the declaration.
(<em>Void statements</em> are labels and empty statements.)


<p>
A declaration shadows any declaration for the same name that
is in context at the point of the declaration. Inside this
shadow, any outer declaration for that name is void.
See the next example:

<pre>
     global print, x
     x = 10                -- global variable
     do                    -- new block
       local x = x         -- new 'x', with value 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- another block
         local x = x+1     -- another 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (the global one)
</pre>

<p>
Notice that, in a declaration like <code>local x = x</code>,
the new <code>x</code> being declared is not in scope yet,
and so the <code>x</code> on the right-hand side refers to the outside variable.


<p>
Because of the lexical scoping rules,
local variables can be freely accessed by functions
defined inside their scope.
A local variable used by an inner function is called an <em>upvalue</em>
(or <em>external local variable</em>, or simply <em>external variable</em>)
inside the inner function.


<p>
Notice that each execution of a <b>local</b> statement
defines new local variables.
Consider the following example:

<pre>
     a = {}
     local x = 20
     for i = 1, 10 do
       local y = 0
       a[i] = function () y = y + 1; return x + y end
     end
</pre><p>
The loop creates ten closures
(that is, ten instances of the anonymous function).
Each of these closures uses a different <code>y</code> variable,
while all of them share the same <code>x</code>.


<p>
As we will discuss further in <a href="#3.2">&sect;3.2</a> and <a href="#3.3.3">&sect;3.3.3</a>,
any reference to a global variable <code>var</code>
is syntactically translated to <code>_ENV.var</code>.
Moreover, every chunk is compiled in the scope of
an external local variable named <code>_ENV</code> (see <a href="#3.3.2">&sect;3.3.2</a>),
so <code>_ENV</code> itself is never a free name in a chunk.


<p>
Despite the existence of this external <code>_ENV</code> variable and
the translation of free names,
<code>_ENV</code> is a regular name.
In particular,
you can define new variables and parameters with that name.
(However, you should not define <code>_ENV</code> as a global variable,
otherwise <code>_ENV.var</code> would translate to
<code>_ENV._ENV.var</code> and so on, in an infinite loop.)
Each reference to a global variable name uses the <code>_ENV</code> that is
visible at that point in the program.


<p>
Any table used as the value of <code>_ENV</code> is called an <em>environment</em>.


<p>
Lua keeps a distinguished environment called the <em>global environment</em>.
This value is kept at a special index in the C registry (see <a href="#4.3">&sect;4.3</a>).
In Lua, the global variable <a href="#pdf-_G"><code>_G</code></a> is initialized with this same value.
(<a href="#pdf-_G"><code>_G</code></a> is never used internally,
so changing its value will affect only your own code.)


<p>
When Lua loads a chunk,
the default value for its <code>_ENV</code> variable
is the global environment (see <a href="#pdf-load"><code>load</code></a>).
Therefore, by default,
global variables in Lua code refer to entries in the global environment
and, therefore, they act as conventional global variables.
Moreover, all standard libraries are loaded in the global environment
and some functions there operate on that environment.
You can use <a href="#pdf-load"><code>load</code></a> (or <a href="#pdf-loadfile"><code>loadfile</code></a>)
to load a chunk with a different environment.
(In C, you have to load the chunk and then change the value
of its first upvalue; see <a href="#lua_setupvalue"><code>lua_setupvalue</code></a>.)





<h2>2.3 &ndash; <a name="2.3">Error Handling</a></h2>

<p>
Several operations in Lua can <em>raise</em> an error.
An error interrupts the normal flow of the program,
which can continue by <em>catching</em> the error.


<p>
Lua code can explicitly raise an error by calling the
<a href="#pdf-error"><code>error</code></a> function.
(This function never returns.)


<p>
To catch errors in Lua,
you can do a <em>protected call</em>,
using <a href="#pdf-pcall"><code>pcall</code></a> (or <a href="#pdf-xpcall"><code>xpcall</code></a>).
The function <a href="#pdf-pcall"><code>pcall</code></a> calls a given function in <em>protected mode</em>.
Any error while running the function stops its execution,
and control returns immediately to <code>pcall</code>,
which returns a status code.


<p>
Because Lua is an embedded extension language,
Lua code starts running by a call
from C&nbsp;code in the host program.
(When you use Lua standalone,
the <code>lua</code> application is the host program.)
Usually, this call is protected;
so, when an otherwise unprotected error occurs during
the compilation or execution of a Lua chunk,
control returns to the host,
which can take appropriate measures,
such as printing an error message.


<p>
Whenever there is an error,
an <em>error object</em>
is propagated with information about the error.
Lua itself only generates errors whose error object is a string,
but programs can generate errors with
any value as the error object,
except <b>nil</b>.
(Lua will change a <b>nil</b> as error object to a string message.)
It is up to the Lua program or its host to handle such error objects.
For historical reasons,
an error object is often called an <em>error message</em>,
even though it does not have to be a string.


<p>
When you use <a href="#pdf-xpcall"><code>xpcall</code></a> (or <a href="#lua_pcall"><code>lua_pcall</code></a>, in C)
you can give a <em>message handler</em>
to be called in case of errors.
This function is called with the original error object
and returns a new error object.
It is called before the error unwinds the stack,
so that it can gather more information about the error,
for instance by inspecting the stack and creating a stack traceback.
This message handler is still protected by the protected call;
so, an error inside the message handler
will call the message handler again.
If this loop goes on for too long,
Lua breaks it and returns an appropriate message.
The message handler is called only for regular runtime errors.
It is not called for memory-allocation errors
nor for errors while running finalizers or other message handlers.


<p>
Lua also offers a system of <em>warnings</em> (see <a href="#pdf-warn"><code>warn</code></a>).
Unlike errors, warnings do not interfere
in any way with program execution.
They typically only generate a message to the user,
although this behavior can be adapted from C (see <a href="#lua_setwarnf"><code>lua_setwarnf</code></a>).





<h2>2.4 &ndash; <a name="2.4">Metatables and Metamethods</a></h2>

<p>
Every value in Lua can have a <em>metatable</em>.
This <em>metatable</em> is an ordinary Lua table
that defines the behavior of the original value
under certain events.
You can change several aspects of the behavior
of a value by setting specific fields in its metatable.
For instance, when a non-numeric value is the operand of an addition,
Lua checks for a function in the field <code>__add</code> of the value's metatable.
If it finds one,
Lua calls this function to perform the addition.


<p>
The key for each event in a metatable is a string
with the event name prefixed by two underscores;
the corresponding value is called a <em>metavalue</em>.
For most events, the metavalue must be a function,
which is then called a <em>metamethod</em>.
In the previous example, the key is the string "<code>__add</code>"
and the metamethod is the function that performs the addition.
Unless stated otherwise,
a metamethod can in fact be any callable value,
which is either a function or a value with a <code>__call</code> metamethod.


<p>
You can query the metatable of any value
using the <a href="#pdf-getmetatable"><code>getmetatable</code></a> function.
Lua queries metamethods in metatables using a raw access (see <a href="#pdf-rawget"><code>rawget</code></a>).


<p>
You can replace the metatable of tables
using the <a href="#pdf-setmetatable"><code>setmetatable</code></a> function.
You cannot change the metatable of other types from Lua code,
except by using the debug library (<a href="#6.11">&sect;6.11</a>).


<p>
Tables and full userdata have individual metatables,
although multiple tables and userdata can share their metatables.
Values of all other types share one single metatable per type;
that is, there is one single metatable for all numbers,
one for all strings, etc.
By default, a value has no metatable,
but the string library sets a metatable for the string type (see <a href="#6.5">&sect;6.5</a>).


<p>
A detailed list of operations controlled by metatables is given next.
Each event is identified by its corresponding key.
By convention, all metatable keys used by Lua are composed by
two underscores followed by lowercase Latin letters.



<ul>

<li><b><code>__add</code></b>: 
the addition (<code>+</code>) operation.
If any operand for an addition is not a number,
Lua will try to call a metamethod.
It starts by checking the first operand (even if it is a number);
if that operand does not define a metamethod for <code>__add</code>,
then Lua will check the second operand.
If Lua can find a metamethod,
it calls the metamethod with the two operands as arguments,
and the result of the call
(adjusted to one value)
is the result of the operation.
Otherwise, if no metamethod is found,
Lua raises an error.
</li>

<li><b><code>__sub</code></b>: 
the subtraction (<code>-</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__mul</code></b>: 
the multiplication (<code>*</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__div</code></b>: 
the division (<code>/</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__mod</code></b>: 
the modulo (<code>%</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__pow</code></b>: 
the exponentiation (<code>^</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__unm</code></b>: 
the negation (unary <code>-</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__idiv</code></b>: 
the floor division (<code>//</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__band</code></b>: 
the bitwise AND (<code>&amp;</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod
if any operand is neither an integer
nor a float coercible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>).
</li>

<li><b><code>__bor</code></b>: 
the bitwise OR (<code>|</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__bxor</code></b>: 
the bitwise exclusive OR (binary <code>~</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__bnot</code></b>: 
the bitwise NOT (unary <code>~</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__shl</code></b>: 
the bitwise left shift (<code>&lt;&lt;</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__shr</code></b>: 
the bitwise right shift (<code>&gt;&gt;</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__concat</code></b>: 
the concatenation (<code>..</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod
if any operand is neither a string nor a number
(which is always coercible to a string).
</li>

<li><b><code>__len</code></b>: 
the length (<code>#</code>) operation.
If the object is not a string,
Lua will try its metamethod.
If there is a metamethod,
Lua calls it with the object as argument,
and the result of the call
(always adjusted to one value)
is the result of the operation.
If there is no metamethod but the object is a table,
then Lua uses the table length operation (see <a href="#3.4.7">&sect;3.4.7</a>).
Otherwise, Lua raises an error.
</li>

<li><b><code>__eq</code></b>: 
the equal (<code>==</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod only when the values
being compared are either both tables or both full userdata
and they are not primitively equal.
The result of the call is always converted to a boolean.
</li>

<li><b><code>__lt</code></b>: 
the less than (<code>&lt;</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod only when the values
being compared are neither both numbers nor both strings.
Moreover, the result of the call is always converted to a boolean.
</li>

<li><b><code>__le</code></b>: 
the less equal (<code>&lt;=</code>) operation.
Behavior similar to the less than operation.
</li>

<li><b><code>__index</code></b>: 
The indexing access operation <code>table[key]</code>.
This event happens when <code>table</code> is not a table or
when <code>key</code> is not present in <code>table</code>.
The metavalue is looked up in the metatable of <code>table</code>.


<p>
The metavalue for this event can be either a function, a table,
or any value with an <code>__index</code> metavalue.
If it is a function,
it is called with <code>table</code> and <code>key</code> as arguments,
and the result of the call
(adjusted to one value)
is the result of the operation.
Otherwise,
the final result is the result of indexing this metavalue with <code>key</code>.
This indexing is regular, not raw,
and therefore can trigger another <code>__index</code> metavalue.
</li>

<li><b><code>__newindex</code></b>: 
The indexing assignment <code>table[key] = value</code>.
Like the index event,
this event happens when <code>table</code> is not a table or
when <code>key</code> is not present in <code>table</code>.
The metavalue is looked up in the metatable of <code>table</code>.


<p>
Like with indexing,
the metavalue for this event can be either a function, a table,
or any value with an <code>__newindex</code> metavalue.
If it is a function,
it is called with <code>table</code>, <code>key</code>, and <code>value</code> as arguments.
Otherwise,
Lua repeats the indexing assignment over this metavalue
with the same key and value.
This assignment is regular, not raw,
and therefore can trigger another <code>__newindex</code> metavalue.


<p>
Whenever a <code>__newindex</code> metavalue is invoked,
Lua does not perform the primitive assignment.
If needed,
the metamethod itself can call <a href="#pdf-rawset"><code>rawset</code></a>
to do the assignment.
</li>

<li><b><code>__call</code></b>: 
The call operation <code>func(args)</code>.
This event happens when Lua tries to call a non-function value
(that is, <code>func</code> is not a function).
The metamethod is looked up in <code>func</code>.
If present,
the metamethod is called with <code>func</code> as its first argument,
followed by the arguments of the original call (<code>args</code>).
All results of the call
are the results of the operation.
This is the only metamethod that allows multiple results.
</li>

</ul>

<p>
In addition to the previous list,
the interpreter also respects the following keys in metatables:
<code>__gc</code> (see <a href="#2.5.3">&sect;2.5.3</a>),
<code>__close</code> (see <a href="#3.3.8">&sect;3.3.8</a>),
<code>__mode</code> (see <a href="#2.5.4">&sect;2.5.4</a>),
and <code>__name</code>.
(The entry <code>__name</code>,
when it contains a string,
may be used by <a href="#pdf-tostring"><code>tostring</code></a> and in error messages.)


<p>
For the unary operators (negation, length, and bitwise NOT),
the metamethod is computed and called with a dummy second operand,
equal to the first one.
This extra operand is only to simplify Lua's internals
(by making these operators behave like a binary operation)
and may be removed in future versions.
For most uses this extra operand is irrelevant.


<p>
Because metatables are regular tables,
they can contain arbitrary fields,
not only the event names defined above.
Some functions in the standard library
(e.g., <a href="#pdf-tostring"><code>tostring</code></a>)
use other fields in metatables for their own purposes.


<p>
It is a good practice to add all needed metamethods to a table
before setting it as a metatable of some object.
In particular, the <code>__gc</code> metamethod works only when this order
is followed (see <a href="#2.5.3">&sect;2.5.3</a>).
It is also a good practice to set the metatable of an object
right after its creation.





<h2>2.5 &ndash; <a name="2.5">Garbage Collection</a></h2>



<p>
Lua performs automatic memory management.
This means that
you do not have to worry about allocating memory for new objects
or freeing it when the objects are no longer needed.
Lua manages memory automatically by running
a <em>garbage collector</em> to collect all <em>dead</em> objects.
All memory used by Lua is subject to automatic management:
strings, tables, userdata, functions, threads, internal structures, etc.


<p>
An object is considered <em>dead</em>
as soon as the collector can be sure the object
will not be accessed again in the normal execution of the program.
("Normal execution" here excludes finalizers,
which resurrect dead objects (see <a href="#2.5.3">&sect;2.5.3</a>),
and it excludes also some operations using the debug library.)
Note that the time when the collector can be sure that an object
is dead may not coincide with the programmer's expectations.
The only guarantees are that Lua will not collect an object
that may still be accessed in the normal execution of the program,
and it will eventually collect an object
that is inaccessible from Lua.
(Here,
<em>inaccessible from Lua</em> means that neither a variable nor
another live object refer to the object.)
Because Lua has no knowledge about C&nbsp;code,
it never collects objects accessible through the registry (see <a href="#4.3">&sect;4.3</a>),
which includes the global environment (see <a href="#2.2">&sect;2.2</a>) and
the main thread.


<p>
The garbage collector (GC) in Lua can work in two modes:
incremental and generational.


<p>
The default GC mode with the default parameters
are adequate for most uses.
However, programs that waste a large proportion of their time
allocating and freeing memory can benefit from other settings.
Keep in mind that the GC behavior is non-portable
both across platforms and across different Lua releases;
therefore, optimal settings are also non-portable.


<p>
You can change the GC mode and parameters by calling
<a href="#lua_gc"><code>lua_gc</code></a> in&nbsp;C
or <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> in Lua.
You can also use these functions to control the collector directly,
for instance to stop or restart it.





<h3>2.5.1 &ndash; <a name="2.5.1">Incremental Garbage Collection</a></h3>

<p>
In incremental mode,
each GC cycle performs a mark-and-sweep collection in small steps
interleaved with the program's execution.
In this mode,
the collector uses three numbers to control its garbage-collection cycles:
the <em>garbage-collector pause</em>,
the <em>garbage-collector step multiplier</em>,
and the <em>garbage-collector step size</em>.


<p>
The garbage-collector pause
controls how long the collector waits before starting a new cycle.
The collector starts a new cycle when the number of bytes
hits <em>n%</em> of the total after the previous collection.
Larger values make the collector less aggressive.
Values equal to or less than 100 mean the collector will not wait to
start a new cycle.
A value of 200 means that the collector waits for
the total number of bytes to double before starting a new cycle.


<p>
The garbage-collector step size controls the
size of each incremental step,
specifically how many bytes the interpreter allocates
before performing a step:
A value of <em>n</em> means the interpreter will allocate
approximately <em>n</em> bytes between steps.


<p>
The garbage-collector step multiplier
controls how much work each incremental step does.
A value of <em>n</em> means the interpreter will execute
<em>n%</em> <em>units of work</em> for each word allocated.
A unit of work corresponds roughly to traversing one slot
or sweeping one object.
Larger values make the collector more aggressive.
Beware that values too small can
make the collector too slow to ever finish a cycle.
As a special case, a zero value means unlimited work,
effectively producing a non-incremental, stop-the-world collector.





<h3>2.5.2 &ndash; <a name="2.5.2">Generational Garbage Collection</a></h3>

<p>
In generational mode,
the collector does frequent <em>minor</em> collections,
which traverses only objects recently created.
If after a minor collection the number of bytes is above a limit,
the collector shifts to a <em>major</em> collection,
which traverses all objects.
The collector will then stay doing major collections until
it detects that the program is generating enough garbage to justify
going back to minor collections.


<p>
The generational mode uses three parameters:
the <em>minor multiplier</em>, the <em>minor-major multiplier</em>,
and the <em>major-minor multiplier</em>.


<p>
The minor multiplier controls the frequency of minor collections.
For a minor multiplier <em>x</em>,
a new minor collection will be done when the number of bytes
grows <em>x%</em> larger than the number in use just
after the last major collection.
For instance, for a multiplier of 20,
the collector will do a minor collection when the number of bytes
gets 20% larger than the total after the last major collection.


<p>
The minor-major multiplier controls the shift to major collections.
For a multiplier <em>x</em>,
the collector will shift to a major collection
when the number of bytes from old objects grows <em>x%</em> larger
than the total after the previous major collection.
For instance, for a multiplier of 100,
the collector will do a major collection when the number of old bytes
gets larger than twice the total after the previous major collection.
As a special case,
a value of 0 stops the collector from doing major collections.


<p>
The major-minor multiplier controls the shift back to minor collections.
For a multiplier <em>x</em>,
the collector will shift back to minor collections
after a major collection collects at least <em>x%</em>
of the bytes allocated during the last cycle.
In particular, for a multiplier of 0,
the collector will immediately shift back to minor collections
after doing one major collection.





<h3>2.5.3 &ndash; <a name="2.5.3">Garbage-Collection Metamethods</a></h3>

<p>
You can set garbage-collector metamethods for tables
and, using the C&nbsp;API,
for full userdata (see <a href="#2.4">&sect;2.4</a>).
These metamethods, called <em>finalizers</em>,
are called when the garbage collector detects that the
corresponding table or userdata is dead.
Finalizers allow you to coordinate Lua's garbage collection
with external resource management such as closing files,
network or database connections,
or freeing your own memory.


<p>
For an object (table or userdata) to be finalized when collected,
you must <em>mark</em> it for finalization.

You mark an object for finalization when you set its metatable
and the metatable has a <code>__gc</code> metamethod.
Note that if you set a metatable without a <code>__gc</code> field
and later create that field in the metatable,
the object will not be marked for finalization.


<p>
When a marked object becomes dead,
it is not collected immediately by the garbage collector.
Instead, Lua puts it in a list.
After the collection,
Lua goes through that list.
For each object in the list,
it checks the object's <code>__gc</code> metamethod:
If it is present,
Lua calls it with the object as its single argument.


<p>
At the end of each garbage-collection cycle,
the finalizers are called in
the reverse order that the objects were marked for finalization,
among those collected in that cycle;
that is, the first finalizer to be called is the one associated
with the object marked last in the program.
The execution of each finalizer may occur at any point during
the execution of the regular code.


<p>
Because the object being collected must still be used by the finalizer,
that object (and other objects accessible only through it)
must be <em>resurrected</em> by Lua.
Usually, this resurrection is transient,
and the object memory is freed in the next garbage-collection cycle.
However, if the finalizer stores the object in some global place
(e.g., a global variable),
then the resurrection is permanent.
Moreover, if the finalizer marks a finalizing object for finalization again,
its finalizer will be called again in the next cycle where the
object is dead.
In any case,
the object memory is freed only in a GC cycle where
the object is dead and not marked for finalization.


<p>
When you close a state (see <a href="#lua_close"><code>lua_close</code></a>),
Lua calls the finalizers of all objects marked for finalization,
following the reverse order that they were marked.
If any finalizer marks objects for collection during that phase,
these marks have no effect.


<p>
Finalizers cannot yield nor run the garbage collector.
Because they can run in unpredictable times,
it is good practice to restrict each finalizer
to the minimum necessary to properly release
its associated resource.


<p>
Any error while running a finalizer generates a warning;
the error is not propagated.





<h3>2.5.4 &ndash; <a name="2.5.4">Weak Tables</a></h3>

<p>
A <em>weak table</em> is a table whose elements are
<em>weak references</em>.
A weak reference is ignored by the garbage collector.
In other words,
if the only references to an object are weak references,
then the garbage collector will collect that object.


<p>
A weak table can have weak keys, weak values, or both.
A table with weak values allows the collection of its values,
but prevents the collection of its keys.
A table with both weak keys and weak values allows the collection of
both keys and values.
In any case, if either the key or the value is collected,
the whole pair is removed from the table.
The weakness of a table is controlled by the
<code>__mode</code> field of its metatable.
This metavalue, if present, must be one of the following strings:
"<code>k</code>", for a table with weak keys;
"<code>v</code>", for a table with weak values;
or "<code>kv</code>", for a table with both weak keys and values.


<p>
A table with weak keys and strong values
is also called an <em>ephemeron table</em>.
In an ephemeron table,
a value is considered reachable only if its key is reachable.
In particular,
if the only reference to a key comes through its value,
the pair is removed.


<p>
Any change in the weakness of a table may take effect only
at the next collect cycle.
In particular, if you change the weakness to a stronger mode,
Lua may still collect some items from that table
before the change takes effect.


<p>
Only objects that have an explicit construction
are removed from weak tables.
Values, such as numbers and light C&nbsp;functions,
are not subject to garbage collection,
and therefore are not removed from weak tables
(unless their associated values are collected).
Although strings are subject to garbage collection,
they do not have an explicit construction and
their equality is by value;
they behave more like values than like objects.
Therefore, they are not removed from weak tables.


<p>
Resurrected objects
(that is, objects being finalized
and objects accessible only through objects being finalized)
have a special behavior in weak tables.
They are removed from weak values before running their finalizers,
but are removed from weak keys only in the next collection
after running their finalizers, when such objects are actually freed.
This behavior allows the finalizer to access properties
associated with the object through weak tables.


<p>
If a weak table is among the resurrected objects in a collection cycle,
it may not be properly cleared until the next cycle.







<h2>2.6 &ndash; <a name="2.6">Coroutines</a></h2>

<p>
Lua supports coroutines,
also called <em>collaborative multithreading</em>.
A coroutine in Lua represents an independent thread of execution.
Unlike threads in multithread systems, however,
a coroutine only suspends its execution by explicitly calling
a yield function.


<p>
You create a coroutine by calling <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>.
Its sole argument is a function
that is the main function of the coroutine.
The <code>create</code> function only creates a new coroutine and
returns a handle to it (an object of type <em>thread</em>);
it does not start the coroutine.


<p>
You execute a coroutine by calling <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
When you first call <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
passing as its first argument
a thread returned by <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
the coroutine starts its execution by
calling its main function.
Extra arguments passed to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> are passed
as arguments to that function.
After the coroutine starts running,
it runs until it terminates or <em>yields</em>.


<p>
A coroutine can terminate its execution in two ways:
normally, when its main function returns
(explicitly or implicitly, after the last instruction);
and abnormally, if there is an unprotected error.
In case of normal termination,
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns <b>true</b>,
plus any values returned by the coroutine main function.
In case of errors, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns <b>false</b>
plus the error object.
In this case, the coroutine does not unwind its stack,
so that it is possible to inspect it after the error
with the debug API.


<p>
A coroutine yields by calling <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
When a coroutine yields,
the corresponding <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns immediately,
even if the yield happens inside nested function calls
(that is, not in the main function,
but in a function directly or indirectly called by the main function).
In the case of a yield, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> also returns <b>true</b>,
plus any values passed to <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
The next time you resume the same coroutine,
it continues its execution from the point where it yielded,
with the call to <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> returning any extra
arguments passed to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.


<p>
Like <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
the <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> function also creates a coroutine,
but instead of returning the coroutine itself,
it returns a function that, when called, resumes the coroutine.
Any arguments passed to this function
go as extra arguments to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> returns all the values returned by <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
except the first one (the boolean error code).
Unlike <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
the function created by <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
propagates any error to the caller.
In this case,
the function also closes the coroutine (see <a href="#pdf-coroutine.close"><code>coroutine.close</code></a>).


<p>
As an example of how coroutines work,
consider the following code:

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
When you run it, it produces the following output:

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
You can also create and manipulate coroutines through the C API:
see functions <a href="#lua_newthread"><code>lua_newthread</code></a>, <a href="#lua_resume"><code>lua_resume</code></a>,
and <a href="#lua_yield"><code>lua_yield</code></a>.






</body>
</html>
