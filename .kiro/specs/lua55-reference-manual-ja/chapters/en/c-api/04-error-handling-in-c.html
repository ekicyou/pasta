<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Lua 5.5 - Section 4.4</title>
</head>
<body>
<h2>4.4 &ndash; <a name="4.4">Error Handling in C</a></h2>



<p>
Internally, Lua uses the C <code>longjmp</code> facility to handle errors.
(Lua will use exceptions if you compile it as C++;
search for <code>LUAI_THROW</code> in the source code for details.)
When Lua faces any error,
such as a memory allocation error or a type error,
it <em>raises</em> an error;
that is, it does a long jump.
A <em>protected environment</em> uses <code>setjmp</code>
to set a recovery point;
any error jumps to the most recent active recovery point.


<p>
Inside a C&nbsp;function you can raise an error explicitly
by calling <a href="#lua_error"><code>lua_error</code></a>.


<p>
Most functions in the API can raise an error,
for instance due to a memory allocation error.
The documentation for each function indicates whether
it can raise errors.


<p>
If an error happens outside any protected environment,
Lua calls a <em>panic function</em> (see <a href="#lua_atpanic"><code>lua_atpanic</code></a>)
and then calls <code>abort</code>,
thus exiting the host application.
Your panic function can avoid this exit by
never returning
(e.g., doing a long jump to your own recovery point outside Lua).


<p>
The panic function,
as its name implies,
is a mechanism of last resort.
Programs should avoid it.
As a general rule,
when a C&nbsp;function is called by Lua with a Lua state,
it can do whatever it wants on that Lua state,
as it should be already protected.
However,
when C code operates on other Lua states
(e.g., a Lua-state argument to the function,
a Lua state stored in the registry, or
the result of <a href="#lua_newthread"><code>lua_newthread</code></a>),
it should use them only in API calls that cannot raise errors.


<p>
The panic function runs as if it were a message handler (see <a href="#2.3">&sect;2.3</a>);
in particular, the error object is on the top of the stack.
However, there is no guarantee about stack space.
To push anything on the stack,
the panic function must first check the available space (see <a href="#4.1.1">&sect;4.1.1</a>).





<h3>4.4.1 &ndash; <a name="4.4.1">Status Codes</a></h3>

<p>
Several functions that report errors in the API use the following
status codes to indicate different kinds of errors or other conditions:

<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0)</b>:  no errors.</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a></b>:  a runtime error.</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a></b>: 
memory allocation error.
For such errors, Lua does not call the message handler.
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a></b>: 
stack overflow while running the message handler
due to another stack overflow.
More often than not,
this error is the result of some other error while running
a message handler.
An error in a message handler will call the handler again,
which will generate the error again, and so on,
until this loop exhausts the stack and cause this error.
</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a></b>:  syntax error during precompilation
or format error in a binary chunk.</li>

<li><b><a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a></b>:  the thread (coroutine) yields.</li>

<li><b><a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a></b>:  a file-related error;
e.g., it cannot open or read the file.</li>

</ul><p>
These constants are defined in the header file <code>lua.h</code>.








</body>
</html>
