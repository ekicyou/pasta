// Pasta DSL Grammar Definition (PEG)
// 
// This grammar defines the Pasta DSL syntax for dialogue scripting.
// Supports both full-width and half-width characters for all keywords.

// Note: WHITESPACE defined without _ would make it explicit
// Using _ makes it implicit (auto-inserted between tokens)
// We keep it implicit for ease of parsing
// Unicode空白文字: タブ、半角スペース、全角スペース、その他のUnicode空白
// pestではUnicodeエスケープを文字クラス内で使えないため、|区切りで列挙
WHITESPACE = _{ " " | "\t" | "\u{3000}" | "\u{00A0}" | "\u{1680}" | "\u{2000}" | "\u{2001}" | "\u{2002}" | "\u{2003}" | "\u{2004}" | "\u{2005}" | "\u{2006}" | "\u{2007}" | "\u{2008}" | "\u{2009}" | "\u{200A}" | "\u{202F}" | "\u{205F}" }
COMMENT = _{ comment_line }
comment_line = { WHITESPACE* ~ ("＃" | "#") ~ (!NEWLINE ~ ANY)* ~ NEWLINE? }

// === File Structure ===
// Top-level: Only lines starting with specific characters are allowed

file = {
    SOI ~
    (top_level_line)*~
    EOI
}

top_level_line = {
    comment_line |
    global_word_def |
    global_label |
    empty_line
}

empty_line = _{ NEWLINE }
indent_only_line = _{ indent ~ NEWLINE }

// === Labels ===
// Global label: starts with ＊ or *
// Body can contain indented lines

global_label = ${
    global_label_marker ~ label_name ~ NEWLINE ~
    (label_body_line | indent_only_line | empty_line)*
}

// Label body line: starts with indent, then dispatch by first character
label_body_line = {
    indent ~ (
        comment_marker ~ comment_content ~ NEWLINE |
        rune_start ~ rune_block_content |
        at_marker ~ word_def_content |
        amp_marker ~ attribute_content |
        dollar_marker ~ var_assign_content |
        local_label_marker ~ local_label_content |
        call_marker ~ call_content |
        jump_marker ~ jump_content |
        speech_line_content
    )
}

// Local label: indent + (ー or -), optionally followed by parameter declarations
local_label_content = {
    label_name ~ label_params? ~ NEWLINE ~
    (local_label_body_line | indent_only_line | empty_line)*
}

// Label parameters: space-separated list of ＄param_name
label_params = { (WHITESPACE+ ~ dollar_marker ~ var_name)+ }

local_label_body_line = {
    indent ~ (
        comment_marker ~ comment_content ~ NEWLINE |
        rune_start ~ rune_block_content |
        at_marker ~ word_def_content |
        amp_marker ~ attribute_content |
        dollar_marker ~ var_assign_content |
        call_marker ~ call_content |
        jump_marker ~ jump_content |
        speech_line_content
    )
}

comment_marker = { "＃" | "#" }
comment_content = @{ (!NEWLINE ~ ANY)* }

global_label_marker = { "＊" | "*" }
local_label_marker = { "・" | "-" }

// Label name: XID_START followed by XID_CONTINUE
// Note: local_label_marker (・ or -) is not in XID_START, so no exclusion needed
// Note: Full-width digits (U+FF10-FF19) must be explicitly included due to PEST limitation
label_name = @{ XID_START ~ (XID_CONTINUE | '\u{FF10}'..'\u{FF19}')* }
// Reserved pattern: label names starting and ending with "__" are reserved for system use
// Examples: __start__, __word_test__, __reserved__
reserved_label_pattern = @{ "__" ~ XID_START ~ XID_CONTINUE* ~ "__" }

// Word definition content: ＠word_name：value1　value2
word_def_content = {
    word_name ~ colon ~ word_value_list ~ NEWLINE
}

// Attribute content: ＆key：value
attribute_content = {
    attribute_key ~ colon ~ attribute_value ~ NEWLINE
}

// Variable assignment: ＄var_name＝expr or ＄＊var_name＝expr
var_assign_content = {
    var_scope? ~ var_name ~ equals ~ expr ~ NEWLINE
}

attribute_key = @{ ident }
attribute_value = { var_ref | literal_value }
literal_value = @{ (!(NEWLINE | colon | word_separator) ~ ANY)+ }

// Call statement content (after ＞)
call_content = {
    jump_target ~ filter_list? ~ arg_list? ~ NEWLINE
}

// Jump statement content (after ？)
jump_content = {
    jump_target ~ filter_list? ~ arg_list? ~ NEWLINE
}

// Speech line content (speaker：content)
speech_line_content = {
    speaker ~ colon ~ speech_content ~ NEWLINE ~
    (continuation_line)*
}

speaker = @{ (!colon ~ !NEWLINE ~ ANY)+ }

speech_content = { (text_part | func_call | var_ref | sakura_script)* }

continuation_line = {
    indent ~ indent+ ~ speech_content ~ NEWLINE
}

text_part = @{ (!(at_marker | sakura_escape | NEWLINE) ~ ANY)+ }

sakura_script = { sakura_escape ~ sakura_command }
sakura_escape = { "\\" | "＼" }
// Sakura commands can be:
// - Single char: \n, \0, \1, ＼ｎ, ＼０, ＼１
// - Char + number: \w8, ＼ｗ８
// - Char + brackets: \s[0], ＼ｓ［０］, \![raise,event]
// - Underscore + char + brackets: \_w[50], ＿ｗ［５０］
sakura_bracket_open = { "[" | "［" }
sakura_bracket_close = { "]" | "］" }
sakura_letter = { ASCII_ALPHA | '\u{FF41}'..'\u{FF5A}' | '\u{FF21}'..'\u{FF3A}' }  // Latin letters (both half and full width)
sakura_digit = { ASCII_DIGIT | '\u{FF10}'..'\u{FF19}' }  // Digits (both half and full width)
sakura_underscore = { "_" | "＿" }

sakura_command = @{
    // Pattern 1: Underscore + letters + optional brackets: \_w[50]
    sakura_underscore ~ sakura_letter+ ~ (sakura_bracket_open ~ (!sakura_bracket_close ~ ANY)* ~ sakura_bracket_close)?  |
    
    // Pattern 2: ! or letter(s) + brackets: \s[0], \custom[arg], \![event]
    ("!" | "！" | sakura_letter+) ~ sakura_bracket_open ~ (!sakura_bracket_close ~ ANY)* ~ sakura_bracket_close  |
    
    // Pattern 3: Single letter + digits: \w8  (but not \n2 - that should be \n followed by text "2")
    sakura_letter ~ sakura_digit+ ~ !sakura_letter  |
    
    // Pattern 4: Single letter: \n
    sakura_letter  |
    
    // Pattern 5: Digits only: \0, \1
    sakura_digit+
}

call_marker = { "＞" | ">" }
jump_marker = { "？" | "?" }

jump_target = {
    dynamic_target |
    long_jump |
    global_target |
    local_target
}

dynamic_target = { at_marker ~ var_name }
long_jump = { global_label_marker ~ label_name ~ local_label_marker ~ label_name }
global_target = { global_label_marker ~ label_name }
local_target = { label_name }

// Filter attributes for label selection
filter_list = { (at_marker ~ attribute_key ~ colon ~ filter_value)+ }
filter_value = { var_ref | literal_value }

// Argument list
arg_list = {
    lparen ~ argument* ~ rparen
}

argument = { named_arg | positional_arg }
named_arg = { arg_name ~ colon ~ arg_value }
positional_arg = { arg_value }

arg_name = @{ ident }
arg_value = { string_literal | number_literal | var_ref | func_call }

lparen = { "（" | "(" }
rparen = { "）" | ")" }

// === Word Definition ===
// Global: ＠word_name：value1　value2
// Local: (indent) ＠word_name：value1　value2

global_word_def = {
    at_marker ~ word_name ~ colon ~ word_value_list ~ NEWLINE
}

word_name = @{ ident }
word_value_list = @{ word_value ~ (word_separator ~ word_value)* }
word_value = { (!word_separator ~ !NEWLINE ~ ANY)+ }
word_separator = { "　" | "\t" }

dollar_marker = { "＄" | "$" }
var_scope = { global_label_marker }
var_name = @{ ident }
equals = { "＝" | "=" }

// === Expressions ===

expr = { term ~ (bin_op ~ term)* }

term = {
    paren_expr |
    func_call |
    var_ref |
    number_literal |
    string_literal
}

paren_expr = { lparen ~ expr ~ rparen }

bin_op = {
    add | sub | mul | div | modulo
}

add = { "+" | "＋" }
sub = { "-" | "－" }
mul = { "*" | "＊" | "×" }
div = { "/" | "／" | "÷" }
modulo = { "%" | "％" }

// === Variables and Functions ===

var_ref = { (at_marker | dollar_marker) ~ var_scope? ~ var_name }

func_call = {
    at_marker ~ func_name ~ arg_list?
}

func_name = @{ ident }

// === Rune Code Block ===
// Only multi-line construct
// (indent) ```rune
// ... content ...
// (indent) ```

rune_block_content = ${
    NEWLINE ~
    rune_content ~
    indent ~ rune_end ~ NEWLINE?
}

rune_content = @{
    (!(indent ~ "```") ~ ANY)*
}

rune_start = { "```rune" | "```" }
rune_end = { "```" }

// === Literals ===

string_literal = {
    ja_string | en_string
}

ja_string = { "「" ~ ja_string_content ~ "」" }
ja_string_content = @{ (!"」" ~ ANY)* }

en_string = { "\"" ~ en_string_content ~ "\"" }
en_string_content = @{ (!("\"" | "\\") ~ ANY | "\\" ~ ANY)* }

number_literal = @{
    ("-" | "－")? ~ digit+ ~ (("." | "．") ~ digit+)?
}

digit = { ASCII_DIGIT | '０'..'９' }

// === Common Elements ===

at_marker = { "＠" | "@" }
amp_marker = { "＆" | "&" }
colon = { "：" | ":" }

ident = @{ !ident_forbidden ~ XID_START ~ XID_CONTINUE* }
ident_forbidden = { global_label_marker | local_label_marker | call_marker | jump_marker | at_marker | dollar_marker | colon | equals }

indent = @{ WHITESPACE+ }
ws = { (" " | "\t" | "\u{3000}")+ }  // Non-silent whitespace for explicit spacing

// === Unicode Identifier Rules ===
// Following Rust identifier rules (Unicode XID_Start + XID_Continue)
XID_START = {
    'a'..'z' | 'A'..'Z' | "_" |
    '\u{0080}'..'\u{00FF}' |          // Latin extended
    '\u{0100}'..'\u{017F}' |          // Latin extended A
    '\u{0180}'..'\u{024F}' |          // Latin extended B
    '\u{1E00}'..'\u{1EFF}' |          // Latin extended additional
    '\u{2C60}'..'\u{2C7F}' |          // Latin extended C
    '\u{A720}'..'\u{A7FF}' |          // Latin extended D
    '\u{3040}'..'\u{309F}' |          // Hiragana
    '\u{30A0}'..'\u{30FF}' |          // Katakana
    '\u{4E00}'..'\u{9FFF}' |          // CJK Unified Ideographs
    '\u{3400}'..'\u{4DBF}' |          // CJK Extension A
    '\u{20000}'..'\u{2A6DF}' |        // CJK Extension B
    '\u{AC00}'..'\u{D7AF}'            // Hangul
}

XID_CONTINUE = {
    XID_START | '0'..'9' |
    '\u{0300}'..'\u{036F}' |          // Combining diacritical marks
    '\u{1DC0}'..'\u{1DFF}' |          // Combining diacritical marks supplement
    '\u{20D0}'..'\u{20FF}' |          // Combining diacritical marks for symbols
    '\u{FE20}'..'\u{FE2F}'            // Combining half marks
}
