//! Parser2 module for Pasta DSL using pasta2.pest grammar.
//!
//! grammar.pest `file = ( file_scope | global_scene_scope )*` 仕様に完全準拠。
//! 複数の file_scope と global_scene_scope を任意順序・任意回数で正確に処理します。
//!
//! This module provides parsing functionality based on the authoritative
//! pasta2.pest grammar specification (now located at `grammar.pest`).
//! The grammar file is immutable and represents the canonical definition
//! of Pasta DSL syntax.
//!
//! # Migration Purpose
//!
//! This module exists to enable a gradual migration from the legacy `parser`
//! module to a new implementation based on the verified `pasta2.pest` grammar.
//! Both modules coexist during the transition period:
//!
//! - `pasta::parser` - Legacy parser (to be deprecated)
//! - `pasta::parser2` - New parser based on pasta2.pest (this module)
//!
//! # Grammar Authority
//!
//! The `grammar.pest` file in this module is the authoritative specification
//! for Pasta DSL syntax. It was moved from `pasta2.pest` without any content
//! changes and must never be manually edited.
//!
//! # AST Structure (parser2-filescope-bug-fix)
//!
//! `PastaFile.items: Vec<FileItem>` でファイル内の全アイテムを記述順序で保持:
//! - `FileItem::FileAttr` - ファイルレベル属性
//! - `FileItem::GlobalWord` - ファイルレベル単語定義
//! - `FileItem::GlobalSceneScope` - グローバルシーン
//!
//! ヘルパーメソッドで型別アクセスも可能:
//! - `file.file_attrs()` - 全ファイル属性
//! - `file.words()` - 全単語定義
//! - `file.global_scene_scopes()` - 全グローバルシーン
//!
//! # Example
//!
//! ```no_run
//! use pasta::parser::{parse_str, parse_file, FileItem};
//! use std::path::Path;
//!
//! // Parse from string
//! let source = "＊挨拶\n  Alice：こんにちは\n";
//! let ast = parse_str(source, "test.pasta").unwrap();
//!
//! // Access via helper methods
//! for attr in ast.file_attrs() {
//!     println!("Attr: {}", attr.key);
//! }
//! for scene in ast.global_scene_scopes() {
//!     println!("Scene: {}", scene.name);
//! }
//!
//! // Or iterate items directly for order-sensitive processing
//! for item in &ast.items {
//!     match item {
//!         FileItem::FileAttr(attr) => println!("FileAttr: {}", attr.key),
//!         FileItem::GlobalWord(word) => println!("GlobalWord: {}", word.name),
//!         FileItem::GlobalSceneScope(scene) => println!("Scene: {}", scene.name),
//!     }
//! }
//! ```

pub mod ast;

pub use ast::*;

use pest::Parser as PestParser;
use pest::iterators::{Pair, Pairs};
use pest_derive::Parser;
use std::path::Path;

use crate::error::PastaError;

/// Pest parser generated from grammar.pest (pasta2.pest).
///
/// This parser is automatically generated by pest_derive from the
/// grammar.pest file, which contains the authoritative Pasta DSL grammar.
#[derive(Parser)]
#[grammar = "parser/grammar.pest"]
pub struct PastaParser2;

/// Parse a Pasta script from a string using pasta2.pest grammar.
///
/// This function parses the provided source string and constructs a complete
/// AST representation following the 3-layer scope hierarchy defined in the grammar.
///
/// # Arguments
///
/// * `source` - Pasta DSL source code as a string
/// * `filename` - Filename for error reporting (does not need to exist)
///
/// # Returns
///
/// * `Ok(PastaFile)` - Successfully parsed AST
/// * `Err(PastaError)` - Parse error with location information
///
/// # Example
///
/// ```
/// use pasta::parser::parse_str;
///
/// let source = r#"＊挨拶
///   Alice：こんにちは
/// "#;
///
/// match parse_str(source, "example.pasta") {
///     Ok(ast) => println!("Parsed {} global scenes", ast.global_scene_scopes().len()),
///     Err(e) => eprintln!("Parse error: {}", e),
/// }
/// ```
pub fn parse_str(source: &str, filename: &str) -> Result<PastaFile, PastaError> {
    let pairs = PastaParser2::parse(Rule::file, source).map_err(|e| {
        let (line, column) = match e.line_col {
            pest::error::LineColLocation::Pos((l, c)) => (l, c),
            pest::error::LineColLocation::Span((l, c), _) => (l, c),
        };
        let message = format!("Parse error in {} at {}:{}: {}", filename, line, column, e);
        PastaError::ParseError {
            file: filename.to_string(),
            line,
            column,
            message,
        }
    })?;

    build_ast(pairs, filename)
}

/// Parse a Pasta script file using pasta2.pest grammar.
///
/// This function reads the file contents and delegates to `parse_str`.
///
/// # Arguments
///
/// * `path` - Path to the .pasta file
///
/// # Returns
///
/// * `Ok(PastaFile)` - Successfully parsed AST with path set to the input path
/// * `Err(PastaError)` - Parse or IO error
///
/// # Example
///
/// ```no_run
/// use pasta::parser::parse_file;
/// use std::path::Path;
///
/// let ast = parse_file(Path::new("scripts/main.pasta"))?;
/// println!("File: {:?}", ast.path);
/// println!("Global scenes: {}", ast.global_scene_scopes().len());
/// # Ok::<(), pasta::PastaError>(())
/// ```
pub fn parse_file(path: &Path) -> Result<PastaFile, PastaError> {
    let source = std::fs::read_to_string(path)?;
    let filename = path.to_string_lossy();
    let mut ast = parse_str(&source, &filename)?;
    ast.path = path.to_path_buf();
    Ok(ast)
}

// ============================================================================
// AST Builder
// ============================================================================

/// Build AST from parsed pairs.
///
/// grammar.pest `file = ( file_scope | global_scene_scope )*` に準拠。
/// 複数の file_scope と global_scene_scope を任意順序で処理し、
/// 出現順序を items に保持します。
fn build_ast(pairs: Pairs<Rule>, filename: &str) -> Result<PastaFile, PastaError> {
    let mut file = PastaFile::new(std::path::PathBuf::from(filename));
    let mut last_global_scene_name: Option<String> = None;

    for pair in pairs {
        match pair.as_rule() {
            Rule::file_scope => {
                // file_scope 内の attrs と words を個別の FileItem として追加
                let scope = parse_file_scope(pair)?;
                for attr in scope.attrs {
                    file.items.push(FileItem::FileAttr(attr));
                }
                for word in scope.words {
                    file.items.push(FileItem::GlobalWord(word));
                }
            }
            Rule::global_scene_scope => {
                let scene = parse_global_scene_scope(pair, &mut last_global_scene_name, filename)?;
                file.items.push(FileItem::GlobalSceneScope(scene));
            }
            Rule::EOI => {}
            _ => {}
        }
    }

    Ok(file)
}

/// Parse file scope.
fn parse_file_scope(pair: Pair<Rule>) -> Result<FileScope, PastaError> {
    let mut scope = FileScope::default();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::file_attr_line => {
                for attr_pair in inner.into_inner() {
                    if attr_pair.as_rule() == Rule::attr {
                        scope.attrs.push(parse_attr(attr_pair)?);
                    }
                }
            }
            Rule::file_word_line => {
                for kw_pair in inner.into_inner() {
                    if kw_pair.as_rule() == Rule::key_words {
                        scope.words.push(parse_key_words(kw_pair)?);
                    }
                }
            }
            _ => {}
        }
    }

    Ok(scope)
}

/// Parse global scene scope.
fn parse_global_scene_scope(
    pair: Pair<Rule>,
    last_name: &mut Option<String>,
    filename: &str,
) -> Result<GlobalSceneScope, PastaError> {
    let span = span_from_pair(&pair);
    let mut scene_name = String::new();
    let mut is_continuation = false;
    let mut attrs = Vec::new();
    let mut words = Vec::new();
    let mut code_blocks = Vec::new();
    let mut local_scenes = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::global_scene_start => {
                let (name, cont) = parse_global_scene_start(inner, last_name, filename)?;
                scene_name = name.clone();
                is_continuation = cont;
                *last_name = Some(name);
            }
            Rule::global_scene_attr_line => {
                for attr_pair in inner.into_inner() {
                    if attr_pair.as_rule() == Rule::attr {
                        attrs.push(parse_attr(attr_pair)?);
                    }
                }
            }
            Rule::global_scene_word_line => {
                for kw_pair in inner.into_inner() {
                    if kw_pair.as_rule() == Rule::key_words {
                        words.push(parse_key_words(kw_pair)?);
                    }
                }
            }
            Rule::code_block => {
                code_blocks.push(parse_code_block(inner)?);
            }
            Rule::local_start_scene_scope => {
                local_scenes.push(parse_local_start_scene_scope(inner)?);
            }
            Rule::local_scene_scope => {
                local_scenes.push(parse_local_scene_scope(inner)?);
            }
            _ => {}
        }
    }

    Ok(GlobalSceneScope {
        name: scene_name,
        is_continuation,
        attrs,
        words,
        code_blocks,
        local_scenes,
        span,
    })
}

/// Parse global scene start (line or continue line).
fn parse_global_scene_start(
    pair: Pair<Rule>,
    last_name: &Option<String>,
    filename: &str,
) -> Result<(String, bool), PastaError> {
    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::global_scene_line => {
                // Named scene
                for scene_inner in inner.into_inner() {
                    if scene_inner.as_rule() == Rule::id {
                        return Ok((scene_inner.as_str().to_string(), false));
                    }
                }
            }
            Rule::global_scene_continue_line => {
                // Continuation scene - inherit name from last
                if let Some(name) = last_name {
                    return Ok((name.clone(), true));
                } else {
                    let span = inner.as_span();
                    let (line, col) = span.start_pos().line_col();
                    return Err(PastaError::ParseError {
                        file: filename.to_string(),
                        line,
                        column: col,
                        message: "Unnamed global scene at start of file. A named global scene must appear before any unnamed scenes.".to_string(),
                    });
                }
            }
            _ => {}
        }
    }

    Ok((String::new(), false))
}

/// Parse local start scene scope (no name).
fn parse_local_start_scene_scope(pair: Pair<Rule>) -> Result<LocalSceneScope, PastaError> {
    let span = span_from_pair(&pair);
    let mut scope = LocalSceneScope::start();
    scope.span = span;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::var_set_local | Rule::var_set_global => {
                scope
                    .items
                    .push(LocalSceneItem::VarSet(parse_var_set(inner)?));
            }
            Rule::call_scene => {
                scope
                    .items
                    .push(LocalSceneItem::CallScene(parse_call_scene(inner)?));
            }
            Rule::action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ActionLine(parse_action_line(inner)?));
            }
            Rule::continue_action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ContinueAction(parse_continue_action_line(
                        inner,
                    )?));
            }
            Rule::code_block => {
                scope.code_blocks.push(parse_code_block(inner)?);
            }
            _ => {}
        }
    }

    Ok(scope)
}

/// Parse local scene scope (with name).
fn parse_local_scene_scope(pair: Pair<Rule>) -> Result<LocalSceneScope, PastaError> {
    let span = span_from_pair(&pair);
    let mut scope = LocalSceneScope::start();
    scope.span = span;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::local_scene_line => {
                for scene_inner in inner.into_inner() {
                    if scene_inner.as_rule() == Rule::id {
                        scope.name = Some(scene_inner.as_str().to_string());
                        break;
                    }
                }
            }
            Rule::var_set_local | Rule::var_set_global => {
                scope
                    .items
                    .push(LocalSceneItem::VarSet(parse_var_set(inner)?));
            }
            Rule::call_scene => {
                scope
                    .items
                    .push(LocalSceneItem::CallScene(parse_call_scene(inner)?));
            }
            Rule::action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ActionLine(parse_action_line(inner)?));
            }
            Rule::continue_action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ContinueAction(parse_continue_action_line(
                        inner,
                    )?));
            }
            Rule::code_block => {
                scope.code_blocks.push(parse_code_block(inner)?);
            }
            _ => {}
        }
    }

    Ok(scope)
}

/// Parse attribute.
fn parse_attr(pair: Pair<Rule>) -> Result<Attr, PastaError> {
    let span = span_from_pair(&pair);
    let mut key = String::new();
    let mut value = AttrValue::AttrString(String::new());

    for inner in pair.into_inner() {
        if inner.as_rule() == Rule::key_attr {
            for kv_inner in inner.into_inner() {
                match kv_inner.as_rule() {
                    Rule::id => {
                        key = kv_inner.as_str().to_string();
                    }
                    Rule::number_literal => {
                        value = parse_attr_number(kv_inner.as_str());
                    }
                    Rule::string_contents | Rule::string_blank => {
                        value = AttrValue::String(kv_inner.as_str().to_string());
                    }
                    Rule::attr_string => {
                        value = AttrValue::AttrString(kv_inner.as_str().to_string());
                    }
                    _ => {}
                }
            }
        }
    }

    Ok(Attr { key, value, span })
}

/// Parse attribute number value.
fn parse_attr_number(s: &str) -> AttrValue {
    let normalized = normalize_number_str(s);
    if normalized.contains('.') {
        AttrValue::Float(normalized.parse().unwrap_or(0.0))
    } else {
        AttrValue::Integer(normalized.parse().unwrap_or(0))
    }
}

/// Parse key_words.
fn parse_key_words(pair: Pair<Rule>) -> Result<KeyWords, PastaError> {
    let span = span_from_pair(&pair);
    let mut name = String::new();
    let mut words = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                name = inner.as_str().to_string();
            }
            Rule::words => {
                for word_inner in inner.into_inner() {
                    match word_inner.as_rule() {
                        Rule::string_contents | Rule::string_blank => {
                            words.push(word_inner.as_str().to_string());
                        }
                        Rule::word_nofenced => {
                            words.push(word_inner.as_str().to_string());
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }

    Ok(KeyWords { name, words, span })
}

/// Parse code block.
fn parse_code_block(pair: Pair<Rule>) -> Result<CodeBlock, PastaError> {
    let span = span_from_pair(&pair);
    let mut language = None;
    let mut content = String::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                language = Some(inner.as_str().to_string());
            }
            Rule::code_contents => {
                content = inner.as_str().to_string();
            }
            _ => {}
        }
    }

    Ok(CodeBlock {
        language,
        content,
        span,
    })
}

/// Parse var_set.
fn parse_var_set(pair: Pair<Rule>) -> Result<VarSet, PastaError> {
    let span = span_from_pair(&pair);
    let scope = match pair.as_rule() {
        Rule::var_set_global => VarScope::Global,
        _ => VarScope::Local,
    };

    let mut name = String::new();
    let mut value = Expr::BlankString;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                name = inner.as_str().to_string();
            }
            _ => {
                // Try to parse as expression
                if let Some(expr) = try_parse_expr(inner.clone()) {
                    value = expr;
                }
            }
        }
    }

    Ok(VarSet {
        name,
        scope,
        value,
        span,
    })
}

/// Parse call_scene.
fn parse_call_scene(pair: Pair<Rule>) -> Result<CallScene, PastaError> {
    let span = span_from_pair(&pair);
    let mut target = String::new();
    let mut args = None;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                target = inner.as_str().to_string();
            }
            Rule::args => {
                args = Some(parse_args(inner)?);
            }
            _ => {}
        }
    }

    Ok(CallScene { target, args, span })
}

/// Parse action_line.
fn parse_action_line(pair: Pair<Rule>) -> Result<ActionLine, PastaError> {
    let span = span_from_pair(&pair);
    let mut actor = String::new();
    let mut actions = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                actor = inner.as_str().to_string();
            }
            Rule::actions => {
                actions = parse_actions(inner)?;
            }
            _ => {}
        }
    }

    Ok(ActionLine {
        actor,
        actions,
        span,
    })
}

/// Parse continue_action_line.
fn parse_continue_action_line(pair: Pair<Rule>) -> Result<ContinueAction, PastaError> {
    let span = span_from_pair(&pair);
    let mut actions = Vec::new();

    for inner in pair.into_inner() {
        if inner.as_rule() == Rule::actions {
            actions = parse_actions(inner)?;
        }
    }

    Ok(ContinueAction { actions, span })
}

/// Parse actions.
fn parse_actions(pair: Pair<Rule>) -> Result<Vec<Action>, PastaError> {
    let mut actions = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::talk => {
                actions.push(Action::Talk(inner.as_str().to_string()));
            }
            Rule::word_ref => {
                for id_inner in inner.into_inner() {
                    if id_inner.as_rule() == Rule::id {
                        actions.push(Action::WordRef(id_inner.as_str().to_string()));
                    }
                }
            }
            Rule::var_ref_local => {
                for id_inner in inner.into_inner() {
                    if id_inner.as_rule() == Rule::id {
                        actions.push(Action::VarRef {
                            name: id_inner.as_str().to_string(),
                            scope: VarScope::Local,
                        });
                    }
                }
            }
            Rule::var_ref_global => {
                for id_inner in inner.into_inner() {
                    if id_inner.as_rule() == Rule::id {
                        actions.push(Action::VarRef {
                            name: id_inner.as_str().to_string(),
                            scope: VarScope::Global,
                        });
                    }
                }
            }
            Rule::fn_call_local => {
                let (name, args) = parse_fn_call_inner(inner)?;
                actions.push(Action::FnCall {
                    name,
                    args,
                    scope: FnScope::Local,
                });
            }
            Rule::fn_call_global => {
                let (name, args) = parse_fn_call_inner(inner)?;
                actions.push(Action::FnCall {
                    name,
                    args,
                    scope: FnScope::Global,
                });
            }
            Rule::sakura_script => {
                actions.push(Action::SakuraScript(inner.as_str().to_string()));
            }
            Rule::at_escape | Rule::dollar_escape | Rule::sakura_escape => {
                actions.push(Action::Escape(inner.as_str().to_string()));
            }
            _ => {}
        }
    }

    Ok(actions)
}

/// Parse function call inner parts.
fn parse_fn_call_inner(pair: Pair<Rule>) -> Result<(String, Args), PastaError> {
    let mut name = String::new();
    let mut args = Args::empty();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                name = inner.as_str().to_string();
            }
            Rule::args => {
                args = parse_args(inner)?;
            }
            _ => {}
        }
    }

    Ok((name, args))
}

/// Parse args.
fn parse_args(pair: Pair<Rule>) -> Result<Args, PastaError> {
    let span = span_from_pair(&pair);
    let mut items = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::positional_arg => {
                for expr_inner in inner.into_inner() {
                    if let Some(expr) = try_parse_expr(expr_inner) {
                        items.push(Arg::Positional(expr));
                    }
                }
            }
            Rule::key_arg => {
                let (key, value) = parse_key_arg(inner)?;
                items.push(Arg::Keyword { key, value });
            }
            _ => {}
        }
    }

    Ok(Args { items, span })
}

/// Parse key_arg.
fn parse_key_arg(pair: Pair<Rule>) -> Result<(String, Expr), PastaError> {
    let mut key = String::new();
    let mut value = Expr::BlankString;

    for inner in pair.into_inner() {
        if inner.as_rule() == Rule::key_expr {
            for kv_inner in inner.into_inner() {
                match kv_inner.as_rule() {
                    Rule::id => {
                        key = kv_inner.as_str().to_string();
                    }
                    _ => {
                        if let Some(expr) = try_parse_expr(kv_inner) {
                            value = expr;
                        }
                    }
                }
            }
        }
    }

    Ok((key, value))
}

/// Try to parse an expression from a pair.
fn try_parse_expr(pair: Pair<Rule>) -> Option<Expr> {
    match pair.as_rule() {
        Rule::number_literal => {
            let normalized = normalize_number_str(pair.as_str());
            if normalized.contains('.') {
                Some(Expr::Float(normalized.parse().ok()?))
            } else {
                Some(Expr::Integer(normalized.parse().ok()?))
            }
        }
        Rule::string_contents => Some(Expr::String(pair.as_str().to_string())),
        Rule::string_blank => Some(Expr::BlankString),
        Rule::var_ref_local => {
            for inner in pair.into_inner() {
                if inner.as_rule() == Rule::id {
                    return Some(Expr::VarRef {
                        name: inner.as_str().to_string(),
                        scope: VarScope::Local,
                    });
                }
            }
            None
        }
        Rule::var_ref_global => {
            for inner in pair.into_inner() {
                if inner.as_rule() == Rule::id {
                    return Some(Expr::VarRef {
                        name: inner.as_str().to_string(),
                        scope: VarScope::Global,
                    });
                }
            }
            None
        }
        Rule::fn_call_local => {
            let (name, args) = parse_fn_call_inner(pair).ok()?;
            Some(Expr::FnCall {
                name,
                args,
                scope: FnScope::Local,
            })
        }
        Rule::fn_call_global => {
            let (name, args) = parse_fn_call_inner(pair).ok()?;
            Some(Expr::FnCall {
                name,
                args,
                scope: FnScope::Global,
            })
        }
        Rule::paren_expr => {
            for inner in pair.into_inner() {
                if let Some(expr) = try_parse_expr(inner) {
                    return Some(Expr::Paren(Box::new(expr)));
                }
            }
            None
        }
        Rule::add_op | Rule::sub_op | Rule::mul_op | Rule::div_op | Rule::modulo_op => {
            // Binary operators are handled at a higher level
            None
        }
        _ => {
            // Try recursively for nested expressions
            for inner in pair.into_inner() {
                if let Some(expr) = try_parse_expr(inner) {
                    return Some(expr);
                }
            }
            None
        }
    }
}

/// Normalize number string by converting full-width characters to half-width.
///
/// Converts:
/// - Full-width digits ('０'..'９') to half-width ('0'..'9')
/// - Full-width minus ('－') to half-width ('-')
/// - Full-width decimal point ('．') to half-width ('.')
fn normalize_number_str(s: &str) -> String {
    s.chars()
        .map(|c| match c {
            '０'..='９' => ((c as u32 - '０' as u32) + '0' as u32) as u8 as char,
            '－' => '-',
            '．' => '.',
            _ => c,
        })
        .collect()
}

/// Create Span from pest Pair.
fn span_from_pair(pair: &Pair<Rule>) -> Span {
    let pest_span = pair.as_span();
    let (start_line, start_col) = pest_span.start_pos().line_col();
    let (end_line, end_col) = pest_span.end_pos().line_col();
    Span::from_pest((start_line, start_col), (end_line, end_col))
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_number_str_half_width() {
        assert_eq!(normalize_number_str("123"), "123");
        assert_eq!(normalize_number_str("-456"), "-456");
        assert_eq!(normalize_number_str("3.14"), "3.14");
    }

    #[test]
    fn test_normalize_number_str_full_width() {
        assert_eq!(normalize_number_str("１２３"), "123");
        assert_eq!(normalize_number_str("－４５６"), "-456");
        assert_eq!(normalize_number_str("３．１４"), "3.14");
    }

    #[test]
    fn test_normalize_number_str_mixed() {
        assert_eq!(normalize_number_str("１2３"), "123");
        assert_eq!(normalize_number_str("3．１４"), "3.14");
        assert_eq!(normalize_number_str("－123"), "-123");
    }

    #[test]
    fn test_parse_empty_file() {
        let result = parse_str("", "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        assert!(file.global_scene_scopes().is_empty());
    }

    #[test]
    fn test_parse_simple_global_scene() {
        let source = "＊挨拶\n  Alice：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = file.global_scene_scopes();
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].name, "挨拶");
        assert!(!scenes[0].is_continuation);
    }

    #[test]
    fn test_parse_continuation_scene() {
        let source = "＊挨拶\n  Alice：こんにちは\n＊\n  Bob：やあ\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = file.global_scene_scopes();
        assert_eq!(scenes.len(), 2);
        assert_eq!(scenes[0].name, "挨拶");
        assert!(!scenes[0].is_continuation);
        assert_eq!(scenes[1].name, "挨拶");
        assert!(scenes[1].is_continuation);
    }

    #[test]
    fn test_parse_unnamed_scene_at_start_error() {
        let source = "＊\n  Alice：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_err());
        if let Err(PastaError::ParseError { message, .. }) = result {
            assert!(message.contains("Unnamed global scene at start of file"));
        }
    }

    #[test]
    fn test_parse_file_scope() {
        let source = "&author：テスト\n＊挨拶\n  Alice：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let attrs = file.file_attrs();
        assert_eq!(attrs.len(), 1);
        assert_eq!(attrs[0].key, "author");
    }

    #[test]
    fn test_parse_continue_action_line() {
        let source = "＊挨拶\n  Alice：こんにちは\n  ：続きの台詞\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = file.global_scene_scopes();
        assert_eq!(scenes.len(), 1);
        let local_scene = &scenes[0].local_scenes[0];
        assert!(local_scene.items.len() >= 2);
        // First item should be ActionLine, second should be ContinueAction
        assert!(matches!(
            local_scene.items[0],
            LocalSceneItem::ActionLine(_)
        ));
        assert!(matches!(
            local_scene.items[1],
            LocalSceneItem::ContinueAction(_)
        ));
    }

    #[test]
    fn test_parse_code_block() {
        let source = "＊挨拶\n  Alice：こんにちは\n```rune\nlet x = 1;\n```\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        assert_eq!(file.global_scene_scopes().len(), 1);
        // Code blocks may be in global or local scope depending on grammar
    }

    #[test]
    fn test_pest_parser_compiles() {
        // Verify that PastaParser2 can parse the file rule
        let result = PastaParser2::parse(Rule::file, "");
        assert!(result.is_ok());
    }
}
