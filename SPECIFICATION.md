# Pasta DSL 文法仕様書

このドキュメントは、Pasta スクリプト言語の完全な文法定義です。設計フェーズで詳細化され、実装フェーズで参照されます。

**関連ドキュメント**:
- [README.md](README.md) - プロジェクト概要
- [GRAMMAR.md](GRAMMAR.md) - 学習用クイックリファレンス
- [AGENTS.md](AGENTS.md) - AI開発支援

---

## 1. 文法モデルの基本原則

### 1.1 行指向文法
Pasta スクリプトは**行指向文法**です。行頭の数文字により行属性が確定します。

**例外**:
- Rune コードブロック：複数行にわたりコードブロックを形成する唯一の例外

### 1.2 ファイル構造（俯瞰）
```text
ファイル
├─ グローバルシーン (＊ 或いは *)
│  ├─ 単語定義行 (＠)
│  └─ Rune コードブロック
├─ グローバル単語定義 (＠)
└─ コメント行 (＃)
```

### 1.3 式（Expression）のサポート

Pasta DSL では**式（Expression）を記述できます**。式は変数代入、関数引数、条件式などで使用されます。

#### 式の構文

| 要素     | pasta2.pest規則                                                                   | 説明                                     |
| -------- | --------------------------------------------------------------------------------- | ---------------------------------------- |
| 式       | `expr = { term ~ s ~ bin* }`                                                      | 項と二項演算の組み合わせ                 |
| 項       | `term = { paren_expr \| fn_call \| var_ref \| number_literal \| string_literal }` | 括弧式、関数呼び出し、変数参照、リテラル |
| 二項演算 | `bin = { bin_op ~ s ~ term ~ s }`                                                 | 演算子と右辺項                           |
| 演算子   | `bin_op = { add_op \| sub_op \| mul_op \| div_op \| modulo_op }`                  | 算術演算子                               |

#### 対応演算子

| 種別 | 演算子（全角/半角） |
| ---- | ------------------- |
| 加算 | `+` / `＋`          |
| 減算 | `-` / `－`          |
| 乗算 | `*` / `＊` / `×`    |
| 除算 | `/` / `／` / `÷`    |
| 剰余 | `%` / `％`          |

#### 使用例

```pasta
＄count＝10 + 5          # 算術式
＄result＝＄a * ＄b       # 変数を含む式
＠func（＄x + 1）         # 関数引数での式
＄nested＝（＄a + ＄b）* 2  # 括弧による優先順位制御
```

#### 複雑な演算

より複雑な演算や条件判定が必要な場合は、Rune ブロックで関数を定義することも可能です。

````pasta
```rune
fn calculate(ctx) {
    let result = 10 + 20 * 3;
    result
}
```
＄result＝＠calculate()
````

---

## 2. キーワード・マーカー定義

### 2.1 基本要素

#### 改行（NEWLINE）
```pest
改行 ::= "\r\n" | "\n" | "\r"
```

**セマンティクス**:
- 行の終わりを明示する
- 行指向文法では改行により行属性が確定する
- すべての行要素は改行で終わる

#### 空白（WHITE_SPACE 文字クラス）
Pasta では空白をトークンとして扱う可能性があるため、Pest の `WHITE_SPACE` 文字クラスを使用します。ただし、Pasta は行指向文法であるため、改行文字（`\r`, `\n`）は空白から除外します。

**重要**: これは Pest の WHITESPACE ルール（トークン自動スキップ）ではなく、明示的に処理される文字クラスです。

**構成** (改行を除外):
- 半角スペース：` `（U+0020）
- タブ：`\t`（U+0009）
- 全角スペース：`　`（U+3000）
- その他 Unicode 空白：U+00A0, U+1680, U+2000-U+200A, U+202F, U+205F

**セマンティクス**:
- 空白が許可される文脈において、1つ以上の連続白文字（改行を除く）はすべて消費されて、1つの「空白」トークンとして扱われます
- 改行は意図的に除外され、行の区切り文字として機能します
- 空白は有効なトークン区切り文字であり、Pest の自動スキップ対象ではありません

#### コロン（Colon）
```pest
コロン ::= "：" | ":"
```

**セマンティクス**: キー・値ペア形式（key ： value）の汎用区切り文字

**設計原則**: コロンは**キー：バリュー関係**を表す場合にのみ使用します。比較・フィルター条件には比較演算子（＝、＞、＜など）を使用します。

**用途**:
- 変数代入：`＄var_name ： value`
- 単語定義：`＠word_name ： value1、value2`
- 属性定義：`＆key ： value`
- アクション行：`actor ： action`
- 引数リスト（関数呼び出し）：`＠func（arg1：value1　arg2：value2）`

#### 識別子（Identifier）
```pest
識別子 ::= { XID_START ~ XID_CONTINUE* }
```

**XID_START**: Unicode Identifier Start
- ASCII: `a-z`, `A-Z`, `_`
- 日本語: 平仮名、カタカナ、漢字、ハングル等

**XID_CONTINUE**: Unicode Identifier Continue
- XID_START の全て + ASCII digits + 結合記号

**制約**:
- 予約パターン `__*__` は未使用（システム予約）
- 例：`__start__`, `__word_test__`

**切り出し規則（最長一致）**:
- 空白による区切りが無い場合、識別子は「識別子に含まれない文字」が現れるまでを最長一致で切り出す
- 例：`＠挨拶、みんな！` → 識別子は「挨拶」、以降は通常テキスト「、みんな！」

#### インデント（Indent）
```pest
インデント ::= WHITE_SPACE+
```

**セマンティクス**: 行頭に存在する1つ以上の連続した空白文字。行がグローバルレベルか下層レベルかを区別します。

**重要**: インデントの有無のみが判定基準です。
- インデント深さの判定は**不要**。深さを測定・比較する必要はありません
- 単純な「有（any positive indent）/ 無（no indent）」のバイナリ判定で十分

**用途**:
- インデントなし = グローバルレベル（グローバルシーン、グローバル単語定義など）
- インデントあり（深さ問わず） = 下層レベル（グローバルシーン直下のすべての行）

**定義の参照**: [2.1 空白（WHITE_SPACE 文字クラス）](#空白white_space-文字クラス)に定義されるWHITE_SPACE文字クラスを使用。

**例**:
```pasta
＊会話               ← インデントなし（グローバルレベル）
  ＆author：Alice    ← インデントあり（下層レベル）
  ・選択肢1         ← インデントあり（下層レベル）
  Alice：おはよう    ← インデントあり（下層レベル）
```

---

### 2.2 シーン・マーカー

#### グローバルシーン（Global Label Marker）
```text
グローバルシーンマーカー ::= "＊" | "*"
使用例: ＊会話 或いは *conversation
```

#### ローカルシーン（Local Label Marker）
```text
ローカルシーンマーカー ::= "・" | "-"
使用例: ・選択肢1 或いは -choice1
```

#### 属性（Attribute Marker）
```text
属性マーカー ::= "＆" | "&"
使用例: ＆author：Alice
```

---

### 2.3 変数・関数

#### 単語登録・参照・呼び出し（At Marker）
```pest
マーカー ::= "＠" | "@"
```

**3つの用法**:

| 用法                     | 構文                                    | 説明                         |
| ------------------------ | --------------------------------------- | ---------------------------- |
| 単語登録                 | `＠word_name：value1、value2`           | グローバル単語辞書に登録     |
| 単語参照                 | `＠word_name`                           | 登録済み単語値を参照         |
| 単語参照（動的）         | `＠＄var_name`                          | 変数値を単語名として間接参照 |
| 関数呼び出し             | `＠func_name()`                         | 関数を呼び出し（引数なし）   |
| 関数呼び出し（引数付き） | `＠func_name（arg1：val1　arg2：val2）` | 名前付き引数で呼び出し       |

#### 変数宣言・代入（Dollar Marker）
```text
マーカー ::= "＄" | "$"
使用例: ＄my_var ： 10
```

#### 変数スコープ修飾子
```text
スコープ修飾 ::= グローバルシーンマーカー
使用例: ＄＊global_var  （グローバル変数）
       ＄local_var      （ローカル変数）
```

---

### 2.4 制御フロー

#### Call マーカー
```pest
Callマーカー ::= "＞" | ">"
```

**セマンティクス**: 指定シーンを呼び出し、実行後に戻る

**構文**:
```pasta
＞call_target [＆filter1＝value1＆filter2＝value2...] [arg_list]
```

詳細は [4. Call の詳細仕様](#4-call-の詳細仕様) を参照

---

### 2.5 音声・会話

#### Sakura スクリプト エスケープ
```pest
エスケープ ::= "\"
```

**重要**: Sakura スクリプトは半角ベースの記法です。エスケープ文字は厳密に半角バックスラッシュ（\）のみを使用します。

詳細は [7. Sakura スクリプト仕様](#7-sakura-スクリプト仕様) を参照

---

### 2.6 Rune コードブロック

#### ブロック開始
```pest
開始マーカー ::= "```" | "```rune"
```

**重要**: rune 接尾辞は任意。接尾辞を付ける場合、許可される値は「rune」のみ。

#### ブロック終了
```pest
終了マーカー ::= "```"
```

**セマンティクス**: 複数行にわたり Rune VM へ直接実行されるコード

**インデント**: Rune ブロックはインデント不要です。構造上は直前のグローバルシーンに属します（インデントの有無に関わらずグローバルシーン配下として扱われます）。

**処理モデル**:
- **パーサー層（Pest）**: Runeブロックの内容は透過的に処理されます。開始マーカー `\`\`\`` または `\`\`\`rune` と終了マーカー `\`\`\`` の間をそのまま抽出するのみで、内部の文法は検証しません。
- **トランスパイラー層**: 抽出されたRuneコード文字列が、「**Rune関数定義のみからなる正式なコード**」として成立することを検証・コンパイルします。ステートメント（変数宣言、代入、制御フローなど）は許可されません。
- **許可される内容**: 関数定義（`fn ...`）のみ。例：`fn on_event() { ... }`, `fn update_state() { ... }`
- **許可されない内容**: `let x = 10;` のような変数宣言、直接的なステートメント、トップレベルの式など。
- **エラーハンドリング**: Rune文法に誤りがある場合、または関数定義以外のコードが含まれる場合、**トランスパイラー層以降でコンパイルエラーが発生**します。パーサー層ではエラーとなりません。

**例**:
````pasta
＊会話
```rune
fn on_init() {
  ctx.flag("talked", true);
}
fn on_event() {
  for i in 0..10 {
    yield ctx.event("loop", i);
  }
}
```
````

または：
````pasta
＊会話
```
fn update_state() {
  ctx.score = ctx.score + 1;
}
```
````

---

### 2.7 演算子

**設計原則**: すべての演算子は全角・半角の両方の形式を許容します。両者は同等に扱われます。

**重要**: 演算子は**将来予約**です。現時点では、Pasta DSL 内で式を記述できません（1.3参照）。演算子は将来の式サポートのために定義されていますが、現在は使用できません。

#### 算術演算子

| 演算 | 全角        | 半角  | 備考                             |
| ---- | ----------- | ----- | -------------------------------- |
| 加算 | 「＋」      | 「+」 |                                  |
| 減算 | 「－」      | 「-」 | 数値の負号と区別注意             |
| 乗算 | 「＊」「×」 | 「*」 | 「＊」はシーンマーカーと同じ文字 |
| 除算 | 「／」「÷」 | 「/」 |                                  |
| 剰余 | 「％」      | 「%」 |                                  |

#### 比較演算子

**セマンティクス**: 全角・半角は同等に扱われます。

| 演算                   | 全角     | 半角   | 備考                    |
| ---------------------- | -------- | ------ | ----------------------- |
| 等値                   | 「＝＝」 | 「==」 |                         |
| 不等                   | 「！＝」 | 「!=」 |                         |
| より小さい             | 「＜」   | 「<」  |                         |
| より大きい             | 「＞」   | 「>」  | Call マーカーと区別注意 |
| より小さいまたは等しい | 「＜＝」 | 「<=」 |                         |
| より大きいまたは等しい | 「＞＝」 | 「>=」 |                         |

#### 括弧

| 種類   | 全角   | 半角  |
| ------ | ------ | ----- |
| 左括弧 | 「（」 | 「(」 |
| 右括弧 | 「）」 | 「)」 |

---

### 2.8 リテラル・文字列

#### 日本語文字列
```
日本語文字列 ::= "「" ~ content ~ "」"
例: 「こんにちは」
```

#### 英語文字列
```
英語文字列 ::= "\"" ~ content ~ "\""
例: "Hello"
```

**エスケープ**: バックスラッシュ `\` でエスケープ可能
- `\n` → 改行
- `\\` → バックスラッシュ
- `\"` → ダブルクォート

#### 数値リテラル
```
数値 ::= ["-" | "－"] ~ 数字+ ~ ["." | "．" ~ 数字+]?

例:
  10
  -5
  3.14
  -2.5
```

**数字**: ASCII 数字（0-9）または全角数字（０-９）

---

### 2.9 単語値の区切り文字

#### 区切り文字
```
区切り ::= WHITE_SPACE+
```

**セマンティクス**: 単語定義の値リストを区切る。1つ以上の連続した空白文字。

**定義の参照**: [2.1 空白（WHITE_SPACE 文字クラス）](#空白white_space-文字クラス)に定義されるWHITE_SPACE文字クラスを使用。

**例**:
```
＠fruits：apple　banana　orange
＠numbers：1　2　3
＠items：value1  value2	value3
```

注：全角スペース「　」、半角スペース「 」、タブ「\t」など、いずれの空白文字でも区切り文字として機能します。

---

## 2.10 コメント

#### コメント行
```
コメント ::= "#" | "＃" ~ content ~ NEWLINE
```

**セマンティクス**: 行末までコメント（処理されない）

**例**:
```
# これはコメント
＃全角シャープでもOK
```

---

## 3. 行とブロック構造

### 2.11.1 行（Line）の定義

Pasta は行指向文法です。各行は改行（NEWLINE）で終わり、行頭の文字（マーカー）により行の型が決定されます。

**行の構成**:
```
行 ::= [インデント] マーカー 内容 NEWLINE
または
行 ::= [インデント] 内容 NEWLINE  （属性行、発言行など）
```

### 2.11.2 行の種類

インデントの有無で、行の構造を二分類します。

#### インデント不要の行構造（行頭にインデントなし）

| 行種               | マーカー                  | 説明                                                   | 例                        |
| ------------------ | ------------------------- | ------------------------------------------------------ | ------------------------- |
| グローバルシーン   | `＊` または `*`           | グローバルブロックを開始                               | `＊会話`                  |
| グローバル単語定義 | `＠` または `@`           | ファイル全体で参照可能な単語定義                       | `＠fruits：apple　banana` |
| Rune ブロック      | ``` ``` または ```rune``` | グローバルシーンに属する複数行コード（インデント不要） | ` ```rune ... ``` `       |
| コメント           | `#` または `＃`           | コメント（処理されない）                               | `# これはコメント`        |

#### インデントが必要な行構造（行頭にインデントあり）

| 行種             | マーカー         | 説明                                       | 例                          |
| ---------------- | ---------------- | ------------------------------------------ | --------------------------- |
| ローカルシーン   | `・` または `-`  | グローバルシーン配下のローカルブロック開始 | `  ・選択肢1`               |
| 属性定義         | `＆` または `&`  | シーンにメタデータを付与                   | `  ＆author：Alice`         |
| 発言行           | （マーカーなし） | キャラクター発言                           | `  Alice：こんにちは`       |
| Call             | `＞` または `>`  | シーンを呼び出す                           | `  ＞シーン名`              |
| 変数代入         | `＄` または `$`  | 変数を宣言・代入                           | `  ＄my_var ： 10`          |
| ローカル単語定義 | `＠` または `@`  | 親シーン内で参照可能な単語定義             | `  ＠fruits：apple　banana` |

注記: コメント行はインデントあり・なしの両方で許容されます（意味解釈は常に「コメント」）。

### 2.11.3 ブロック構造

Pasta スクリプトは階層的なブロック構造を持ちます。

#### グローバルブロック構造

```
グローバルブロック
  ├─ グローバル単語行（＠）*
  └─ グローバルシーンブロック（＊）+
```

**セマンティクス**:
- グローバル単語定義（0個以上）と グローバルシーンブロック（1個以上）で構成
- ファイルレベルのスコープを形成

#### グローバルシーンブロック構造

```
＊グローバル名
  ＆属性行 *
  [暗黙ローカル開始ブロック(__start__)]
  ・ローカルシーンブロック *
```

**構成要素**:
1. **グローバルシーン行**: `＊グローバル名`（宣言）
2. **属性行**: ０個以上の `＆key：value` （グローバルシーン全体のメタデータ）
3. **暗黙ローカル開始ブロック**: Rune ブロック、発言行、制御フロー行、変数代入行を格納可能（ローカルシーン宣言なし）
4. **ローカルブロック**: ０個以上の明示的ローカルシーンブロック（`・ローカルシーン`）

**暗黙ローカル開始ブロック（`__start__`）**:
- ローカルシーン名が `__start__` に相当する特別なブロック
- ローカルシーン宣言行は不要（暗黙的に開始）
- Call でグローバルシーンを呼び出す際に、`__start__` ブロックが実行される
- Rune ブロックはここに格納可能

#### ローカルブロック構造

```
・ローカル名
  [属性行 *]
  (変数代入行 | 会話行 | Call行)*
```

**構成要素**:
1. **ローカルシーン行**: `・ローカル名`（宣言）
2. **属性行**: ０個以上の `＆key：value` （ローカルシーン全体のメタデータ）
3. **コンテンツ行**: ０個以上の以下のいずれか
   - 変数代入行（`＄`）
   - アクション行（actor：action）
   - Call 行（`＞`）

**セマンティクス**:
- ローカルシーンの実行本体を構成
- Call 行は実行後に当ローカルブロック内で処理を継続

#### Rune ブロックの配置

Rune ブロックは暗黙ローカル開始ブロック（`__start__`）内に配置されます。

````
＊グローバル名
  ```rune
  fn on_event() {
    for i in 0..10 {
      yield ctx.event("loop", i);
    }
  }
  ```
  Alice：こんにちは
````

**処理順序**:
- グローバルシーンが Call の対象になると、暗黙 `__start__` が実行される
- 暗黙 `__start__` 内の Rune ブロック（存在する場合）が最初に実行
- その後、同一ブロック内の発言行、Call 行が順に実行

**制約**:
- Rune ブロックはインデント不要（配置上は直前のグローバルシーン配下）
- **関数定義のみ許可**：Rune ブロック内には `fn ...` で始まる関数定義のみを記述可能。変数宣言（`let`）やトップレベルのステートメントは許可されません
- 複数の Rune ブロックが暗黙 `__start__` 内に存在する場合、上から順に関数が定義される
- パーサーは内部を解釈しません。**トランスパイラーが関数定義のみの正式なコード**として検証し、文法エラーまたは関数定義以外のコードが検出された場合、トランスパイラー層で報告されます

#### 例

**例1: 属性 + 暗黙ローカルスタート + Rune関数定義**
```
＊会話
  ＆author：Alice
  ```rune
  fn initialize() {
    ctx.flag("talked", true);
  }
  ```
  こんにちは
```

**例2: 属性 + ローカルシーンブロック**
```
＊選択肢
  ＆genre：choice
  ・選択肢1
    Alice：選択肢1を選びました
  ・選択肢2
    Alice：選択肢2を選びました
```

**例3: 暗黙スタート + 明示ローカルシーン**
```
＊複合シーン
  Alice：シーンが開始されました
  ・分岐A
    Bob：Aを選びました
  ・分岐B
    Bob：Bを選びました
```

### 2.11.4 インデント（Indentation）

インデントは行の属するレベルを示します。

**インデント規則**:
- インデントなし = グローバルレベル（グローバルシーン、グローバル単語定義など）
- インデントあり = 下層レベル（グローバルシーン直下のすべての行：ローカルシーン、属性行、発言行など）
- 例外: Rune ブロックはインデント不要だが、構造上は直前のグローバルシーンに属する

**重要**:
- インデント深さの判定は**不要**です
- パーサーは「行頭に空白があるか・ないか」のバイナリチェックのみで十分
- インデント深さを測定・比較・検証する必要はありません

**例**:
```pasta
＊会話               ← インデントなし（グローバルレベル）
  ＆author：Alice    ← インデントあり（下層レベル）
  ・選択肢1         ← インデントあり（下層レベル）
  Alice：こんにちは ← インデントあり（下層レベル）

＠fruits：apple orange ← インデントなし（グローバルレベル）
```

---

## 4. Call の詳細仕様

### 4.1 Call ターゲットの形式

Call は以下の2パターンのターゲット形式をサポート：

#### パターン1: シーン参照
```text
call_target ::= call_marker ~ id
例: ＞選択肢1
   >choice1
```

**セマンティクス**: 現在のグローバルシーンスコープから参照できるローカルシーン + グローバルシーン全てから、指定名で**前方一致検索**してシーンを呼び出す

**スコープ解決ルール**（10.3 単語参照と同一仕様）:
- Call 文にスコープ修飾子は不要
- `＞scene_name` で、現在のグローバルシーンスコープ内のローカルシーン + グローバルシーンの全候補から検索
- 異なるグローバルシーンスコープでは、同じシーン名でも異なる候補が検索される（ローカルシーンが異なるため）
- 参照：[10.3 単語参照](#103-単語参照)と共通のスコープ解決アルゴリズム

**補足**: グローバルシーン呼び出しの概念（`>*シーン`）は廃止され、`>シーン` に統一されました。

#### パターン2: 動的ターゲット
```text
call_target ::= call_marker ~ var_ref
例: ＞＄target_label
   >$dynamic_choice
```

**セマンティクス**: 変数の値をシーン名として解決

#### 4.1.3 前方一致によるターゲット解決

Call/単語検索において、ターゲットの候補列挙は**前方一致**で行われます。

**例**:
以下のグローバルシーンがあるとき：
```pasta
＊挨拶朝
＊挨拶昼
```

- `＞挨拶` では「挨拶朝」「挨拶昼」の両方が候補
- `＞挨拶朝` では「挨拶朝」のみが候補

**設計原則**: パーサーレベルではターゲット文字列を単に抽出するのみ。候補の列挙とランダム選択の詳細な挙動については、トランスパイラー・ランタイム層の実装に委ねられます。

#### 4.1.4 スコープ解決アルゴリズム

Call 文と単語参照（`＠`）は、同一のスコープ解決アルゴリズムを使用します。

**2段階検索**:
1. **ローカル検索**: 現在のグローバルシーンスコープ内のローカルシーン/単語を、指定プレフィックスで前方一致検索
2. **グローバル検索**: すべてのグローバルシーン/単語を、指定プレフィックスで前方一致検索（ローカル専用エントリを除外）
3. **マージ**: 両検索結果を結合して候補リストを生成
4. **選択**: 候補リストからランダムに1つを選択（キャッシュベースの順次消費）

**例**:
```pasta
＊会話
  ＠返答
    ＠挨拶：こんにちは　おはよう

  ＊選択肢
    ―選択肢1

＊挨拶グローバル
  ―グローバル挨拶です
```

グローバルシーン「会話」内から `＞選択肢` を呼び出した場合：
- ローカル検索: `:会話_1:選択肢` で前方一致 → `会話/選択肢` がマッチ
- グローバル検索: `選択肢` で前方一致 → グローバルシーン「選択肢...」があればマッチ
- 両候補がマージされ、ランダム選択される

**参照**: 単語参照のスコープ解決については [10.3 単語参照](#103-単語参照) を参照

---

### 4.2 フィルター（属性フィルター）

**構文**:
```text
filter_list ::= ("＆" ~ key ~ 比較演算子 ~ value)+
現在: ＆key＝value
将来: ＆score＞50　＆level＜10　など比較演算子ベースに拡張予定

例: ＞シーン名＆author＝Alice＆genre＝comedy
   ＠単語名＆category＝food＆season＝summer
```

**セマンティクス**: ターゲット選択時に属性で絞り込み（将来予約）

**適用範囲**: Callだけでなく、会話文内の単語呼び出し（＠）でも同様に使用可能。基本的な記述ルールは共通。

**設計原則**: フィルターは比較・条件判定のため、コロンではなく比較演算子（＝、＞、＜など）を使用

**現在**: フィルター機能は将来用に宣言; 現在は無視

---

### 4.3 引数リスト

**構文**:
```pest
arg_list ::= "（" ~ argument* ~ "）"
argument ::= 名前付き引数
名前付き引数 ::= name ~ "：" ~ value
区切り文字 ::= 空白（"　" | "\t" | " "）
```

**例**:
```pasta
＠関数呼び出し（引数１：値１　引数２：値２）
＠calculate（x：10　y：20）
```

**実装状態**:
- ASTレベルでの解釈は対応
- トランスパイラー層以降の実装は順次対応予定

---

## 5. リテラル型

### 5.1 概要
変数、関数引数、属性値で使用可能な型。

### 5.2 型変換ルール

リテラル値は以下の優先順位で型変換される：

1. **bool型**: `true` / `false` → bool
2. **String型（引用符あり）**: `「...」`で囲まれている → String
3. **f64型**: 小数点が含まれる数値 → f64
4. **i64型**: 小数点が無い数値 → i64
5. **String型（その他）**: 上記以外 → String

**空白の扱い**:
- 引用符`「」`で囲まれている場合: 空白も文字列の一部
- 引用符なしの場合: 空白は区切り文字として認識され、文字列に含まれない

**例**:
```
true           → bool
false          → bool
「こんにちは」   → String (空白含む)
Hello          → String
3.14           → f64
42             → i64
hello world    → String "hello" と String "world" (2つの値)
「hello world」 → String "hello world" (1つの値)
```

---

## 6. アクション行（Action Line）

### 6.1 基本構文
```
actor ： action [NEWLINE continuation_line*]
```

### 6.2 Actor（アクター）
**形式**: コロン前のテキスト（任意の非改行文字）

**説明**: アクター名を指定。会話テキストだけでなく、Sakuraスクリプトによる表情指定など、アクション全般を制御。

**例**:
```
Alice：...
キャラクターA：...
```

### 6.3 Action（アクション）

アクション内容は通常テキストと**インライン要素**の組み合わせで構成される。

#### インライン要素

アクション行内に埋め込み可能な要素：

| 要素                 | 構文                 | 説明                         |
| -------------------- | -------------------- | ---------------------------- |
| 通常テキスト         | `こんにちは`         | 任意の文字列                 |
| 単語参照             | `＠word_name`        | 登録済み単語からランダム選択 |
| 単語参照（動的）     | `＠＄var_name`       | 変数値を単語名として参照     |
| ＠エスケープ         | `＠＠`               | リテラルの「＠」を1文字出力  |
| 変数参照             | `＄var_name`         | 変数値を展開                 |
| 関数呼び出し         | `＠func_name()`      | Rune関数を呼び出し           |
| 関数呼び出し（引数） | `＠func（x：10）`    | 名前付き引数で呼び出し       |
| Sakura スクリプト    | `\n`, `\w8`, `\s[0]` | 表情・タイミング制御         |

Sakura スクリプトはアクション行のインライン要素の一つであり、詳細は [7. Sakura スクリプト仕様](#7-sakura-スクリプト仕様) を参照。

**インライン判定ルール**: 行を左から右へ走査し、マーカー文字列（例：`\`、`＠`、`＄`）で分岐して各インライン要素を最長一致で切り出す。いずれのインライン要素構文にも一致しない場合のみ、残余を通常テキストとして確定する。

**例**:
```
Alice：こんにちは、＄player_nameさん！\w8
Bob：今日の天気は＠weather_wordsですね\n
Carol：＠greet（time：morning）
```

**重要**: 変数宣言（`＄var：value`）は専用の変数宣言行で行う。アクション内では変数参照（`＄var`）のみ可能。

#### インライン要素の区切り文字

**目的**: アクション内のインライン要素（＠、＄）の終端と区切りの扱いを定義する。

##### 空白による区切り

インライン要素の識別子認識において、空白は**トークン区切り**として利用できる。

```
＠挨拶　みんな！         → 単語参照「挨拶」+ 通常テキスト「みんな！」
＠挨拶　　　　みんな！   → 同じ出力（空白数は無関係）
＄name　さん            → 変数参照「name」+ 通常テキスト「さん」
```

**ルール**:
- 空白はトークン区切りとして認識され、空白数に関わらず1トークンとして扱う
- トークン区切りの空白は出力に含まれない
- 空白がない場合は最長一致で識別子を切り出す（識別子に含まれない文字が現れるまで）

##### 空白なしの場合（最長一致）

空白で区切られない場合、識別子（前述の「識別子（Identifier）」定義に従う）として認識できない文字が現れるまでを**最長一致**で切り出す。

```
＠挨拶、みんな！   → インライン単語「＠挨拶」 + 通常テキスト「、みんな！」
＄name!          → 変数参照「＄name」 + 通常テキスト「!」
＠weather_wordsですね → 最長一致により識別子「＠weather_wordsですね」として扱われる（意図しない吸収の例）
※ 正しく分割したい場合は区切りを入れる：
  - 空白で分割: 「＠weather_words　ですね」
  - 非識別子記号で分割: 「＠weather_words、ですね」（読点「、」は識別子に含まれない）
```

**備考**: インライン要素の一覧は 6.3 を参照。行継続のルールは 6.4 を参照。

---

### 6.4 行継続
複数行にわたるアクション：

```
Alice：長い台詞は
  複数行に分けて
  記述できます
```

**構文**:
```
continuation_line ::= INDENT ~ !(statement_marker) ~ content
statement_marker ::= "＄" | "＠" | "＞" | "＆" | "＊" | "・"
```

**セマンティクス**: インデント付き行は前行の続きとして連結

**制約**: 継続行は行マーカー（＄＠＞＆＊・）で始めてはならない。これらで始まる場合は別の行種として解釈される。

---

## 6.5 改行

### 6.5.1 概要
アクション行のテキスト内における改行の取り扱いを定義する。

### 6.5.2 正規の改行（Sakura）
- Sakura スクリプトの `\n` は常に「改行」として解釈する（7.3 参照）。
- 出力時に改行文字として挿入される。

### 6.5.3 糖衣構文（継続行内の空行）
- 6.4 で定義される「行継続」領域において、インデントのみで内容のない行（空白だけ、または純粋な空行）を「改行」として解釈する。
- 連続する空行は、その数に応じた連続改行として出力される。

**文法追加**:
```
continuation_line_newline ::= INDENT ~ NEWLINE
```

**セマンティクス**:
- `continuation_line_newline` は 1 改行として動作する。
- 空白（INDENT）は出力には含まれない（2.1 の原則継承）。

**例**:
```
Alice：１行目。
  １行目の続き。
  
  ２行目。
```
→ 出力は「１行目。\n２行目。」（空行が 1 改行として解釈）

### 6.5.4 非継続領域の空行
- 継続行以外（インデントなしの空行、シーン直後の空行など）は、改行としては解釈しない。レイアウト目的の空白として無視する。

**備考**:
- 詳細な整形やタイミング制御は Sakura スクリプトのコマンド（例：`\w`）を推奨。
- 改行仕様は 6.4（行継続）と併せて適用される。

---

## 7. Sakura スクリプト仕様

### 7.1 概要
Sakura スクリプトは、アクション行内にインラインで埋め込まれる「\」から始まるコマンドトークンです。Pasta はコマンドの種類や意味を解釈しません。必要なのは**コマンド記述ルール（字句構造）**のみで、検出後はそのまま透過します。

### 7.2 エスケープ文字
```pest
エスケープ ::= "\""
```

**重要**: 厳密に半角バックスラッシュ（\）のみ。全角は不可。

### 7.3 コマンドの字句構造（簡略版）

- 目的: 「\」から始まるコマンドの最小必要ルールのみ定義します。コマンドの意味は解釈しません（未知トークンも受理）。

**構文（字句）**:
```pest
sakura_command   ::= "\" ~ sakura_token ~ bracket_content?
sakura_token     ::= [!_a-zA-Z0-9]+     // 数字開始可、'!' と '_' を含めたASCIIトークン
bracket_content  ::= "[" ~ bracket_chars ~ "]"
bracket_chars    ::= ( "\\]" | [^\]] )* // 非エスケープな ']' で閉じる。 '\]' は文字 ']'。
```

**説明**:
- `sakura_token` は ASCII 英数字 + `_` + `!` の連続。先頭が数字でもよい。
- 角括弧内容は**非ネスト**前提で、最初の「非エスケープな `]`」で閉じます（`\]`は内容文字として扱う）。
- 角括弧内で `,` や `"` を値に含めるための ukadoc の**引用規則**（第2引数以降の `"..."`、内部 `"` を二重にする）はそのまま透過します。Pasta は中身を構文解析しません。

**制約と代替方針**:
- Pasta はさくらスクリプトの複雑な構文（入れ子、特殊な引数構成、高度なエスケープの相互作用）を検出・解釈しません。
- そのような複雑さが必要な場合は、Rune 関数を呼び出して必要なトークン列（さくらスクリプトを含む文字列）を生成し、アクション行へ挿入する運用を推奨します。
- 例: `＠emit_complex_sakura()` が `"\![embed,OnTalk]"` 等の文字列を返し、それをアクションに連結して使用する。

### 7.4 文字種（簡略）

- コマンドトークンは**ASCII**（英数字・`_`・`!`）のみを対象とします。
- 括弧は**半角**の `[` と `]` を対象とします（全角括弧はコマンド括弧として扱わない）。
- エスケープは**半角**バックスラッシュ `\` のみ（全角不可）。

### 7.5 使用例

```pasta
Alice：こんにちは\w8。\n返事してください。
Bob：\![happy]了解しました。
```

---

## 8. 属性（Attribute）

### 8.1 構文
```pest
属性行 ::= インデント ~ "＆" ~ key ~ "：" ~ value ~ NEWLINE
```

### 8.2 配置ルール

属性行は**シーン定義の直後にのみ配置可能**：

- **グローバルシーンの直後**: グローバルシーンに属性を付与
- **ローカルシーンの直後**: ローカルシーンに属性を付与
- **複数配置可能**: 同じシーンに複数の属性を連続して記述

**例**:
```pasta
＊グローバルシーン
  ＆author：Alice
  ＆genre：comedy
  ・ローカルシーン
    ＆priority：high
    ＆difficulty：3
    Alice：台詞内容
```

**セマンティクス**: 直前のシーンにメタデータを付与

**制約**: 属性行はシーン行の直後以外には配置できない。アクション行や変数代入行の後に属性行を置くことは文法エラー。

### 8.3 ファイルレベル属性（将来予約）

**構文**:
```pest
file_level_attribute ::= "＆" ~ key ~ "：" ~ value ~ NEWLINE
```

**配置ルール**: ファイル冒頭、すべてのグローバルシーン宣言より前に、インデントなしで配置

**セマンティクス**: ファイルレベル属性は、当該ファイル内のすべてのグローバルシーンに自動的に継承される

**例**:
```pasta
＆警報レベル：レッド

＊会話１
  ＆温度：暑い

＊会話２
  ＆温度：寒い
```

**結果**:
- グローバルシーン「会話１」: `＆警報レベル：レッド　＆温度：暑い`
- グローバルシーン「会話２」: `＆警報レベル：レッド　＆温度：寒い`

**実装状態**: 将来予約機能。現在は構文のみ許容し、セマンティクス実装は順次対応予定。

---

## 9. 変数・スコープ

### 9.1 変数型

#### グローバル変数

グローバル変数は永続的に有効な変数です。

| 構文 | pasta2.pest規則                                            | 説明             |
| ---- | ---------------------------------------------------------- | ---------------- |
| 参照 | `var_ref_global = { var_marker ~ global_marker ~ id ~ s }` | `＄＊変数名`     |
| 代入 | `var_set_global = { var_marker ~ global_marker ~ set }`    | `＄＊変数名＝値` |

```pasta
宣言: ＄＊var_name＝value
参照: ＄＊var_name
```

**スコープ**: 永続的

#### ローカル変数

ローカル変数は一連のシーンが終わるまで有効な変数です。

| 構文 | pasta2.pest規則                           | 説明           |
| ---- | ----------------------------------------- | -------------- |
| 参照 | `var_ref_local = { var_marker ~ id ~ s }` | `＄変数名`     |
| 代入 | `var_set_local = { var_marker ~ set }`    | `＄変数名＝値` |

```pasta
宣言: ＄var_name＝value
参照: ＄var_name
```

**スコープ**: 一連のシーンが終わるまで

#### 使用例

```pasta
＄ローカル変数＝10       # ローカル変数代入（一連のシーンが終わるまで有効）
＄＊グローバル変数＝100  # グローバル変数代入（永続的）
Alice：値は ＄ローカル変数 です
Bob：値は ＄＊グローバル変数 です
```

### 9.2 変数代入の制約

変数代入では**式を使用できます**（1.3参照）。代入可能な値は以下です：

#### 許可される値の型

| 値の種類                 | 構文例                           | 説明                   |
| ------------------------ | -------------------------------- | ---------------------- |
| リテラル値               | `＄score＝100`                   | 数値、文字列リテラル   |
| 単語参照                 | `＄value＝＠word_name`           | 登録済み単語の参照     |
| 変数参照                 | `＄new_var＝＄old_var`           | 他の変数の値をコピー   |
| 式                       | `＄result＝＄a + ＄b * 2`        | 算術式                 |
| 関数呼び出し             | `＄result＝＠calculate()`        | 関数の戻り値           |
| 関数呼び出し             | `＄result ： ＠calculate()`      | Rune 関数の戻り値      |
| 関数呼び出し（引数付き） | `＄sum ： ＠add（x：10　y：20）` | 名前付き引数で呼び出し |

#### 許可されない構文例
```pasta
# ❌ 式は使用できない
＄result ： 10 + 20
＄flag ： ＄x > 5
＄value ： (＄a + ＄b) * 2
```

#### 代替方法：Rune 関数を使用
````pasta
```rune
fn add(ctx, x, y) {
    x + y
}

fn is_greater(ctx, x, threshold) {
    x > threshold
}
```

＄result ： ＀add（x：10　y：20）
＄flag ： ＠is_greater（x：＠score　threshold：5）
````

---

## 10. 単語定義（Word Definition）

### 10.1 グローバル単語定義
```pasta
＠word_name ： value1、value2、...
```

**セマンティクス**: ファイル全体で参照可能な辞書エントリ

### 10.2 ローカル単語定義
```pasta
  ＠word_name ： value1、value2、...
```

**セマンティクス**: 親シーン内で参照可能

### 10.3 単語参照

**構文**:
```text
会話行内: ＠word_name
Rune コード内: pasta::word_lookup(ctx, "word_name")
```

**スコープ解決ルール**（4.1.4 Call スコープ解決と同一仕様）:
- 単語参照にスコープ修飾子は不要
- `＠word_name` で、現在のグローバルシーンスコープ内のローカル単語 + グローバル単語の全候補から**前方一致検索**
- 異なるグローバルシーンスコープでは、同じ単語名でも異なる結果を返す可能性がある（ローカル単語が異なるため）
- 参照：[4.1.4 スコープ解決アルゴリズム](#414-スコープ解決アルゴリズム)と共通のスコープ解決アルゴリズム

**動的単語参照**:
- `＠＄var_name` 形式で、変数値を単語名として間接参照可能
- セマンティクス：`＄var_name` で取得した値を単語名として `＠単語検索` を実行
- **実装状態**：文法定義済み、実装は将来予定

**制限（v1）**:
- 多段階参照（例：`＠＠word`、`＠＠＠word`）は廃止（非対応）。
- `＠＠` はリテラルの「＠」1文字を埋め込むためのエスケープとしてのみ使用する。
- 多段解決が必要な場合は関数呼び出し（例：`＠resolve(word：... )`）で代替する。

---

## 11. 未確定事項・検討中の仕様

### 11.2 インライン単語参照の多段階解決（廃止）
- `＠＠word` のような多段階解決は採用しない。
- `＠＠` はリテラルの「＠」を出力するエスケープとしてのみ使用。
- 追加の解決が必要な場合は関数呼び出しで代替する。

### 11.3 チェーントーク（DSL非採用）
- チェーントーク専用の DSL 構文は採用しない。
- 代替: グローバルシーンにチェイン用シーンを定義し、`＞チェイン` などで呼び出してチェイン処理を行う。
- チェイン固有の出力や関数定義は、当該シーン配下（暗黙 __start__ 含む）に記述する。

### 11.4 ローカルシーンのパラメータ（将来検討）
- グローバルシーン、ローカルシーンともにパラメータ付き構文は現時点で未定義。
- 将来的に検討する可能性はあるが、現在は対応予定なし。
- 必要な場合は、変数経由でパラメータ相当の値を渡す運用で代替可能。

### 11.5 フィルター機能の詳細（初期版対応なし）
- フィルター機能は初期版では対応しない。
- 複数フィルターのOR/AND結合方法などは将来的に検討する可能性がある。
- 現在は構文のみ定義されているが（4.2参照）、セマンティクス実装は将来予定。

### 11.6 単語定義の値の型変換ルール（初期版）
- 単語は文字列のみを登録する（将来拡張は未定）。
- 値は「」で囲んだ空白を含む文字列、または空白を含まない文字列のいずれか。
- 数値は含めない（単語定義には 5.2 の型変換を適用しない）。
- 例:
  - `＠fruits：apple　banana　orange`（すべて文字列）
  - `＠greet： 「おはようございます」 「こんにちは」`（引用符で空白を含む文字列）
  - `＠numbers：1　2　3`（文字列として扱う）


### 11.7 動的単語参照（＠＄var_name）の実装スケジュール
- 文法予約のみ。現仕様の完全動作確認が完了するまでは着手しない。
- 優先度は低く、「忘れていなければいつか実装する」レベル。
- 未実装期間の扱いは、無視または警告ログで通知する方針を設計で検討。

### 11.8 Callの戻り値と変数代入（DSL非定義）
- 戻り値の定義はトランスパイラ/ランタイムの領域で扱う。DSLでは規定しない。
- すべての関数は yield によるトークン生成装置であり、戻り値は単一値ではなく yield による列挙値となる。
- 代入例（`＄result ： ＞some_label`）の可否は DSL 範囲外。必要ならランタイム設計でガイドを用意。

### 11.9 ローカル変数のスコープ詳細（トランスパイラ/ランタイム）
- すべての関数の第一引数には連想配列 `ctx` を渡す。
- `ctx.local` にローカル値、`ctx.global` にグローバル値を保存する方針。
- ローカル値は1回の会話セッション終了時にクリアされる。
- 具体的な可視性・寿命はトランスパイラ/ランタイム設計で確定。

### 11.10 属性値の型解釈
- 属性の `value` は 5.2 のリテラル型変換ルールに従う。
- フィルター（4.2）との比較演算の整合性はこの前提で設計。

### 11.11 前方一致時の複数候補選択ルール（DSL非定義）
- 候補選択アルゴリズムはトランスパイラ/ランタイムの領域。DSLでは規定しない。

### 11.12 引数リストの値の型解釈
- 引数の `value` は 5.2 のリテラル型変換ルールに従う。
- 引数内のインライン要素の可否は別途設計（現時点では文字列/リテラルのみ推奨）。

### 11.13 行継続のインデント深さ制約
- インデント深さは判定不要。
- 直前行がアクション行または継続行であれば継続として扱う。

### 11.14 コメント行の配置可能位置
- コメント行はあらゆる位置に配置可能。
- コメント行は DSL として無視される（構造・セマンティクスに影響しない）。

### 11.15 識別子と予約語の制限（DSL外）
- DSLとしての制限は設けない。
- 実質的に Rune 言語のキーワードは変数・関数として使用不可。
- パーサー層ではエラーにしないが、トランスパイラ/ランタイム層でコンパイルエラーになる。

### 11.16 Sakuraスクリプト括弧内のエスケープ（確定）
- 参照: 伺か ukadoc「さくらスクリプトのエスケープ」
  - https://ssp.shillest.net/ukadoc/manual/list_sakura_script.html#notes_escape
- 基本エスケープ（Sakura 側仕様）:
  - 「\」を文字として表示する場合は「\\」と記述する。
  - 環境変数タグの「%」を文字として扱う場合は「\%」と記述する。
- 角括弧引数内の閉じ括弧「]」の扱い:
  - 「スクウェアブラケット内に引数を持つタグ（例: \q[...], \![...], \s[...], \_b[...], など）のみ」で、「]」を文字として含めたい場合は「\]」と書ける（ukadoc 規定）。
  - Pasta パーサーは当該エスケープをそのまま透過し、Sakura 側の解釈に委ねる。
- 角括弧内で「,」を値として含めたい場合の書式:
  - 「複数の引数を持つタグの第2引数以降」で、その引数の内容として「,」を含めたい場合、当該引数全体をダブルクォートで囲う。例: `\![raise,OnTest,"100,2"]`（ukadoc 規定）。
- 引数にダブルクォート（"）を含めたい場合の書式:
  - 引数全体をダブルクォートで囲み、内部の `"` は二重にする。例: `\![call,ghost,"the ""MobileMaster"""]`（ukadoc 規定）。
- バックスラッシュの制約（Pasta 側再掲）:
  - Sakura スクリプトのエスケープは厳密に「半角バックスラッシュ（\）」のみを認める（2.5 / 7.2 の原則）。全角バックスラッシュは不可。
- 括弧のネストと「[」の扱い:
  - ukadoc では「[」のエスケープ規定はなく、閉じ括弧ではないため通常はそのまま記述できる。
  - ネスト構文（`[[...]]` 等）は Sakura の標準仕様に含まれない前提とし、Pasta は「非ネスト」を前提に `[...]` を字句的に1塊として透過処理する。
- 実装ポリシー（Pasta パーサー）:
  - 括弧内容の詳細は解釈しない。字句的に `[` から最初の非エスケープな `]` までを抽出し、`\]`・クォート規則の存在を妨げない。
  - 7.3 の `bracket_content` はこの前提で成立するものとする。
- テスト観点（例示）:
  - `\q[タイトル,ID]`（基本形）
  - `\q[タイトル,OnID,r0,r1]`（第2引数以降のカンマを含む値は引用で包める）
  - `\![raise,OnTest,"100,2"]`（カンマ含む第2引数）
  - `\![call,ghost,"the ""MobileMaster"""]`（ダブルクォートを値に含める）
  - `\s[0\]]`（括弧内で `]` を文字として含めるための `\]`）


### 11.17 ファイルエンコーディングとBOM
- エンコーディングは UTF-8 固定。
- BOM 無しでも動作すること。BOM は許容。

### 11.18 ファイルレベル属性の継承詳細
- ファイルレベル属性はグローバルシーンに継承されるが、グローバルシーン側で同一属性が定義されれば上書き。
- ファイルレベル属性はローカルシーンには影響しない。

### 11.19 空行の配置と解釈
- 意味のない位置における空行はコメント行と同じ扱い（無視）。
- 継続領域の空行は 6.5.3 の規則に従う。

### 11.20 全角・半角混在時の正規化
- パーサーレベルでは正規化（全角・半角の同等化）を行う。
- キーワード文字列は AST には現れないため正規化の影響は限定的。
- 例外: `＠＠` と `@@` は正規化しない（それぞれの意味を保持）。

---

## 12. 参考資料

- `src/parser/pasta.pest` - PEG 文法定義
- `GRAMMAR.md` - ユーザー向けドキュメント（改訂予定）
- `pest-grammar-alignment-analysis.md` - 現状分析資料

---

**更新履歴**:

| 日付       | 版  | 変更               |
| ---------- | --- | ------------------ |
| 2025-12-18 | 1.0 | 初版作成（ひな形） |

