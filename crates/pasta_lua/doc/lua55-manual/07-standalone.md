[← 前へ: 6 – 標準ライブラリ](06-standard-libraries.md) | [目次](./README.md) | [次へ: 8 – 非互換性 →](08-incompatibilities.md)

---

# 7 – Luaスタンドアロン

> **Source**: Lua 5.5 Reference Manual - Chapter 7 (Lua Standalone)
> **Translation**: AI-generated based on Lua 5.4 Japanese reference with Lua 5.5 updates
> **Glossary**: See [GLOSSARY.md](GLOSSARY.md) for terminology

---

LuaはホストCプログラムに組み込むための拡張言語として設計されていますが、スタンドアロン言語としても頻繁に使用されます。スタンドアロン言語としてのLuaのインタープリター（単に`lua`と呼ばれる）は、標準ディストリビューションに付属しています。スタンドアロンインタープリターには、すべての標準ライブラリが含まれています。その使い方は次のとおりです：

```
lua [options] [script [args]]
```

## オプション

| オプション | 説明 |
|-----------|------|
| `-e stat` | 文字列`stat`を実行 |
| `-i` | `script`の実行後に対話モードに入る |
| `-l mod` | `mod`を「require」し、結果をグローバル`mod`に割り当てる |
| `-l g=mod` | `mod`を「require」し、結果をグローバル`g`に割り当てる |
| `-v` | バージョン情報を出力 |
| `-E` | 環境変数を無視 |
| `-W` | 警告をオンにする |
| `--` | オプションの処理を停止 |
| `-` | `stdin`をファイルとして実行し、オプションの処理を停止 |

---

## 基本的な動作

オプションを処理した後、`lua`は指定された*script*を実行します。引数なしで呼び出された場合：

- 標準入力（`stdin`）がターミナルである場合は`lua -v -i`として動作
- そうでない場合は`lua -`として動作

---

## 環境変数

### LUA_INIT_5_5 / LUA_INIT

> **Lua 5.5 変更点**: 環境変数名が`LUA_INIT_5_4`から`LUA_INIT_5_5`に変更されました。

オプション`-E`なしで呼び出された場合、インタープリターは、引数を実行する前に環境変数`LUA_INIT_5_5`（またはバージョン付きの名前が定義されていない場合は`LUA_INIT`）を確認します。

- 変数の内容が`@filename`の形式の場合、`lua`はそのファイルを実行
- それ以外の場合、`lua`は文字列自体を実行

### -E オプション

オプション`-E`を指定して呼び出された場合、Luaは環境変数を参照しません。特に、`package.path`と`package.cpath`の値は、`luaconf.h`で定義されたデフォルトパスで設定されます。

このオプションがオンであることをライブラリに通知するため、スタンドアロンインタープリターはレジストリのフィールド`"LUA_NOENV"`をtrue値に設定します。他のライブラリも同じ目的でこのフィールドを参照できます。

---

## オプションの処理順序

オプション`-e`、`-l`、および`-W`は、表示される順序で処理されます。たとえば、次のような呼び出しでは：

```bash
$ lua -e 'a=1' -llib1 script.lua
```

1. 最初に`a`を1に設定
2. 次にライブラリ`lib1`をrequire
3. 最後に引数なしでファイル`script.lua`を実行

（ここで`$`はシェルプロンプトです。プロンプトは異なる場合があります。）

---

## コマンドライン引数テーブル

コードを実行する前に、`lua`は、`arg`という名前のグローバルテーブルにすべてのコマンドライン引数を収集します：

- スクリプト名はインデックス0
- スクリプト名の後の最初の引数はインデックス1
- スクリプト名より前の引数（インタープリター名とオプション）は負のインデックス

たとえば、次の呼び出しでは：

```bash
$ lua -la b.lua t1 t2
```

テーブルは次のようになります：

```lua
arg = { [-2] = "lua", [-1] = "-la",
        [0] = "b.lua",
        [1] = "t1", [2] = "t2" }
```

呼び出しにスクリプトがない場合、インタープリター名はインデックス0になり、その後に他の引数が続きます。たとえば、次の呼び出しでは：

```bash
$ lua -e "print(arg[1])"
```

「`-e`」が出力されます。

スクリプトがある場合、スクリプトは引数`arg[1]`、···、`arg[#arg]`で呼び出されます。Luaのすべてのチャンクと同様に、スクリプトは可変長引数関数としてコンパイルされます。

---

## 対話モード

対話モードでは、Luaは繰り返しプロンプトを表示して行を待ちます。行を読み取った後：

1. Luaは最初にその行を**式**として解釈しようとする
2. 成功した場合は、その値を出力
3. それ以外の場合は、その行を**チャンク**として解釈

不完全なチャンクを記述した場合、インタープリターは別のプロンプトを発行して完了を待ちます。

### ローカル変数に関する警告（Lua 5.5 新機能）

> **Lua 5.5 新機能**: 対話モードでのローカル変数に関する警告が追加されました。

完全な行はそれぞれ新しいチャンクとして読み込まれるため、ローカル変数は行をまたいで存続しません。混乱を避けるため、インタープリターは行が予約語**local**で始まる場合に警告を出します：

```lua
> x = 20      -- グローバル 'x'
> local x = 10; print(x)
    --> warning: locals do not survive across lines in interactive mode
    --> 10
> print(x)     -- グローバル 'x' に戻る
    --> 20
> do       -- 不完全なチャンク
>> local x = 10; print(x)    -- '>>' は行の継続を促す
>> print(x)
>> end     -- チャンク完了
   --> 10
   --> 10
```

### プロンプトのカスタマイズ

グローバル変数`_PROMPT`に文字列が含まれている場合、その値はプロンプトとして使用されます。同様に、グローバル変数`_PROMPT2`に文字列が含まれている場合、その値はセカンダリプロンプトとして使用されます（不完全なステートメント中に発行されます）。

---

## エラー処理

スクリプトで保護されていないエラーが発生した場合、インタープリターは標準エラーストリームにエラーを報告します：

- エラーオブジェクトが文字列ではなく、メタメソッド`__tostring`を持つ場合、インタープリターはこのメタメソッドを呼び出して最終的なメッセージを生成
- それ以外の場合、インタープリターはエラーオブジェクトを文字列に変換し、スタックトレースバックを追加

警告がオンの場合、警告は単に標準エラー出力に出力されます。

---

## 終了処理

正常に終了すると、インタープリターはメインのLuaステートを閉じます（`lua_close`を参照）。スクリプトは、`os.exit`を呼び出して終了することにより、このステップを回避できます。

---

## Unixでのスクリプトとしての使用

UnixシステムでLuaをスクリプトインタープリターとして使用できるようにするために、Luaはファイルチャンクの最初の行が`#`で始まる場合、その行をスキップします。

したがって、Luaスクリプトは、`chmod +x`と`#!`形式を使用して、次のように実行可能プログラムにすることができます：

```bash
#!/usr/local/bin/lua
```

もちろん、Luaインタープリターの場所はマシンによって異なる場合があります。`lua`が`PATH`にある場合：

```bash
#!/usr/bin/env lua
```

がよりポータブルなソリューションになります。

---

## Lua 5.5 での変更点

1. **環境変数**: `LUA_INIT_5_4` → `LUA_INIT_5_5`
2. **local警告**: 対話モードで`local`で始まる行に対して警告を出力する機能が追加
3. **レジストリフィールド**: `-E`オプション時に`"LUA_NOENV"`フィールドをレジストリに設定する動作が明文化
