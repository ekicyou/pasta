# 2 – 基本概念

[← 前へ: 1 – 序論](01-introduction.md) | [目次](./README.md) | [次へ: 3 – 言語 →](03-language.md)

---

このセクションでは、言語の基本概念について説明します。

## 2.1 – 値と型

Luaは**動的型付け言語**です。これは、変数には型がなく、値にのみ型があることを意味します。言語に型定義はありません。すべての値は独自の型を持ちます。

Luaのすべての値は、**第一級の値**です。これは、すべての値を変数に格納したり、他の関数に引数として渡したり、結果として返したりできることを意味します。

Luaには、*nil*、*boolean*、*number*、*string*、*function*、*userdata*、*thread*、*table*の8つの基本型があります。型*nil*には、他の任意の値とは異なることを主な特性とする単一の値**nil**があります。これは、しばしば有用な値の欠如を表します。型*boolean*には、**false**と**true**の2つの値があります。**nil**と**false**の両方が条件を偽にします。これらは総称して**偽の値**と呼ばれます。その他の任意の値は条件を真にします。名前にもかかわらず、**false**は、**nil**の代替としてよく使用されます。主な違いは、**false**がテーブル内の通常の値のように振る舞うのに対し、テーブル内の**nil**は欠落したキーを表すことです。

型*number*は、*integer*と*float*の2つのサブタイプを使用して、整数と実数（浮動小数点）数の両方を表します。標準のLuaは、64ビット整数と倍精度（64ビット）浮動小数点を使用しますが、32ビット整数および/または単精度（32ビット）浮動小数点を使用するようにLuaをコンパイルすることもできます。整数と浮動小数点の両方に32ビットを使用するオプションは、小型マシンや組み込みシステムにとって特に魅力的です。（ファイル`luaconf.h`のマクロ`LUA_32BITS`を参照してください。）

特に明記しない限り、整数値を操作する際のオーバーフローは、通常の2の補数演算の規則に従って**折り返され**ます。（言い換えれば、実際の結果は、数学的結果に対して *2ⁿ* を法とする等しい、表現可能な一意の整数です。ここで、*n* は整数型のビット数です。）

Luaには、各サブタイプがいつ使用されるかについての明示的な規則がありますが、必要に応じて自動的に変換も行われます（[§3.4.3](03-language.md#343--強制変換と変換)を参照）。したがって、プログラマーは、整数と浮動小数点の違いをほとんど無視するか、各数値の表現を完全に制御することを選択できます。

型*string*は、不変のバイトシーケンスを表します。Luaは**8ビットクリーン**です。文字列には、埋め込みゼロ（`'\0'`）を含む任意の8ビット値を含めることができます。Luaは**エンコーディングに依存しません**。文字列の内容に関する仮定は行いません。Luaの任意の文字列の長さは、Lua整数に収まる必要があります。

Luaは、Luaで記述された関数とCで記述された関数を呼び出し（および操作）できます（[§3.4.10](03-language.md#3410--関数呼び出し)を参照）。どちらも型*function*で表されます。

型*userdata*は、任意のCデータをLua変数に格納できるようにするために提供されています。userdata値は、生のメモリのブロックを表します。userdataには、2つの種類があります。**フルuserdata**は、Luaが管理するメモリブロックを持つオブジェクトであり、**ライトuserdata**は、単にCポインター値です。userdataには、Luaでの割り当てと同一性テストを除いて、定義済みの操作はありません。**メタテーブル**を使用することにより、プログラマーはフルuserdata値の操作を定義できます（[§2.4](#24--メタテーブルとメタメソッド)を参照）。userdata値はLuaで作成または変更することはできず、C APIでのみ可能です。これにより、ホストプログラムおよびCライブラリが所有するデータの整合性が保証されます。

型*thread*は、独立した実行スレッドを表し、コルーチンを実装するために使用されます（[§2.6](#26--コルーチン)を参照）。Luaスレッドは、オペレーティングシステムのスレッドとは関係ありません。Luaは、ネイティブでスレッドをサポートしていないシステムでも、すべてのシステムでコルーチンをサポートします。

型*table*は、連想配列を実装します。つまり、インデックスとして数値だけでなく、**nil**およびNaNを除く任意のLua値を持つことができる配列です。（*Not a Number*は、`0/0`などの未定義の数値結果を表すためにIEEE 754標準で使用される特別な浮動小数点値です。）テーブルは**異種**にすることができます。つまり、すべての型（**nil**を除く）の値を含めることができます。値**nil**に関連付けられているキーは、テーブルの一部とは見なされません。逆に、テーブルの一部ではないキーには、関連付けられた値**nil**があります。

テーブルはLuaの唯一のデータ構造メカニズムです。これらは、通常の配列、リスト、シンボルテーブル、セット、レコード、グラフ、ツリーなどを表すために使用できます。レコードを表すために、Luaはフィールド名をインデックスとして使用します。言語は、`a.name`を`a["name"]`の糖衣構文として提供することにより、この表現をサポートしています。Luaでテーブルを作成するには、いくつかの便利な方法があります（[§3.4.9](03-language.md#349--テーブルコンストラクタ)を参照）。

インデックスと同様に、テーブルフィールドの値は任意の型にできます。特に、関数は第一級の値であるため、テーブルフィールドには関数を含めることができます。したがって、テーブルは**メソッド**も持つことができます（[§3.4.11](03-language.md#3411--関数定義)を参照）。

テーブルのインデックス作成は、言語の**生の等価性**の定義に従います。`a[i]`と`a[j]`という式は、`i`と`j`が生の等しい（つまり、メタメソッドなしで等しい）場合にのみ、同じテーブル要素を示します。特に、整数値を持つ浮動小数点数は、それぞれの整数と等しくなります（例：`1.0 == 1`）。あいまいさを回避するために、整数と等しいキーとして使用される浮動小数点数は、その整数に変換されます。たとえば、`a[2.0] = true`と記述した場合、テーブルに挿入される実際のキーは整数`2`になります。

テーブル、関数、スレッド、（フル）userdata値は**オブジェクト**です。変数は、これらの値を実際には*含ま*ず、それらへの**参照**のみを*含み*ます。割り当て、パラメーター渡し、関数の戻り値は、常にこのような値への参照を操作します。これらの操作は、いかなる種類のコピーも意味しません。

ライブラリ関数[`type`](06-standard-libraries.md#type)は、指定された値の型を記述する文字列を返します（[`type`](06-standard-libraries.md#type)を参照）。

## 2.2 – スコープ、変数、および環境

Luaは**レキシカルスコープ言語**です。変数のスコープは、その変数の宣言の後の最初のステートメントから始まり、その宣言を含む最も内側のブロックの最後まで続きます。例を考えてみましょう：

```lua
x = 10                -- グローバル変数
do                    -- 新しいブロック
  local x = x         -- 値10を持つ新しい'x'
  print(x)            --> 10
  x = x+1
  do                  -- 別のブロック
    local x = x+1     -- 別の'x'
    print(x)          --> 12
  end
  print(x)            --> 11
end
print(x)              --> 10  (グローバル変数)
```

`local x = x`のような宣言では、宣言されている新しい`x`はまだスコープに入っていないため、2番目の`x`は外側の変数を参照することに注意してください。

**レキシカルスコープ**のため、ローカル変数は、そのスコープ内で定義された関数から自由にアクセスできます。内部関数によって使用されるローカル変数は、その内部関数内で**アップバリュー**または**外部ローカル変数**と呼ばれます。

`local`ステートメントは、明示的に新しいローカル変数を宣言し、オプションでそれに初期値を割り当てます。`global`ステートメントは、ブロック内でグローバル変数を明示的に宣言し、オプションでそれに初期値を割り当てます。（`local`と`global`についての詳細は[§3.3.7](03-language.md#337--ローカル宣言とグローバル宣言)を参照してください。）

`local`または`global`で宣言されていない名前は、**自由名**と呼ばれます。コンパイル時に、自由名`var`への各参照は`_ENV.var`に変換されます。さらに、すべてのチャンクは`_ENV`という名前の外部ローカル変数のスコープでコンパイルされるため（[§3.3.2](03-language.md#332--チャンク)を参照）、`_ENV`自体はチャンク内の自由名になることはありません。

自由名の変換にもかかわらず、`_ENV`は完全に通常の名前です。特に、新しい変数やパラメータをその名前で定義できます。自由名への各参照は、プログラムのその時点で可視である`_ENV`を使用します。これはLuaの通常の可視性ルールに従います（[§3.5](03-language.md#35--可視性ルール)を参照）。

`_ENV`の値として使用されるテーブルはすべて、**環境**と呼ばれます。

Luaは、**グローバル環境**と呼ばれる特別な環境を保持します。この値は、Cレジストリの特別なインデックスに保持されます（[§4.3](04-c-api.md#43--レジストリ)を参照）。Luaでは、グローバル変数[`_G`](06-standard-libraries.md#_G)はこの同じ値で初期化されます。（[`_G`](06-standard-libraries.md#_G)は内部で使用されないため、その値を変更しても、自分のコードにのみ影響します。）

Luaがチャンクをロードすると、その`_ENV`変数のデフォルト値はグローバル環境になります（[`load`](06-standard-libraries.md#load)を参照）。したがって、デフォルトでは、Luaコード内の自由名はグローバル環境のエントリを参照するため、**グローバル変数**とも呼ばれます。さらに、すべての標準ライブラリはグローバル環境にロードされ、そこにある一部の関数はその環境で動作します。[`load`](06-standard-libraries.md#load)（または[`loadfile`](06-standard-libraries.md#loadfile)）を使用して、別の環境でチャンクをロードできます。（Cでは、チャンクをロードしてから、最初のアップバリューの値を変更する必要があります。[`lua_setupvalue`](04-c-api.md#lua_setupvalue)を参照してください。）

## 2.3 – エラー処理

Luaのいくつかの操作は、エラーを**発生**させる可能性があります。エラーはプログラムの通常の流れを中断しますが、エラーを**キャッチ**することで続行できます。

Luaコードは、[`error`](06-standard-libraries.md#error)関数を呼び出すことで、明示的にエラーを発生させることができます。（この関数は決して戻りません。）

Luaでエラーをキャッチするには、[`pcall`](06-standard-libraries.md#pcall)（または[`xpcall`](06-standard-libraries.md#xpcall)）を使用して、**保護された呼び出し**を行うことができます。関数[`pcall`](06-standard-libraries.md#pcall)は、指定された関数を**保護モード**で呼び出します。関数の実行中にエラーが発生すると、実行が停止し、制御はすぐに`pcall`に戻り、`pcall`はステータスコードを返します。

Luaは埋め込み拡張言語であるため、Luaコードはホストプログラム内のCコードからの呼び出しによって実行を開始します。（Luaをスタンドアロンで使用する場合、`lua`アプリケーションがホストプログラムです。）通常、この呼び出しは保護されています。したがって、Luaチャンクのコンパイルまたは実行中に、保護されていないエラーが発生すると、制御はホストに戻り、ホストはエラーメッセージの出力などの適切な対策を講じることができます。

エラーが発生すると、エラーに関する情報を含む**エラーオブジェクト**が伝播されます。Lua自体はエラーオブジェクトが文字列であるエラーのみを生成しますが、プログラムは任意の値を持つエラーオブジェクトを生成できます。そのようなエラーオブジェクトを処理するのは、Luaプログラムまたはそのホストの責任です。歴史的な理由から、エラーオブジェクトは文字列である必要はないにもかかわらず、しばしば**エラーメッセージ**と呼ばれます。

[`xpcall`](06-standard-libraries.md#xpcall)（またはCでは[`lua_pcall`](04-c-api.md#lua_pcall)）を使用する場合、エラーが発生した場合に呼び出される**メッセージハンドラ**を指定できます。この関数は、元のエラーオブジェクトで呼び出され、新しいエラーオブジェクトを返します。スタックがアンワインドされる前に呼び出されるため、スタックを検査したり、スタックトレースバックを作成したりするなど、エラーに関する詳細情報を収集できます。このメッセージハンドラは、保護された呼び出しによって引き続き保護されています。したがって、メッセージハンドラ内のエラーは、メッセージハンドラを再度呼び出します。このループが長すぎると、Luaはループを中断し、適切なメッセージを返します。メッセージハンドラは、通常実行時のエラーに対してのみ呼び出されます。メモリ割り当てエラーや、ファイナライザまたはその他のメッセージハンドラの実行中のエラーに対しては呼び出されません。

Luaは、**警告**のシステムも提供しています（[`warn`](06-standard-libraries.md#warn)を参照）。エラーとは異なり、警告はプログラムの実行を妨げることはありません。通常、ユーザーにメッセージを生成するだけですが、この動作はCから適応させることができます（[`lua_setwarnf`](04-c-api.md#lua_setwarnf)を参照）。

## 2.4 – メタテーブルとメタメソッド

Luaのすべての値は、**メタテーブル**を持つことができます。この*メタテーブル*は、特定のイベント下で元の値の動作を定義する通常のLuaテーブルです。メタテーブルに特定のフィールドを設定することで、値の動作のいくつかの側面を変更できます。たとえば、数値以外の値が加算のオペランドである場合、Luaは値のメタテーブルの`__add`フィールドの関数をチェックします。見つかった場合、Luaはこの関数を呼び出して加算を実行します。

メタテーブル内の各イベントのキーは、イベント名の前に2つのアンダースコアが付いた文字列です。対応する値は**メタ値**と呼ばれます。ほとんどのイベントの場合、メタ値は関数である必要があり、その関数は**メタメソッド**と呼ばれます。前の例では、キーは文字列"`__add`"であり、メタメソッドは加算を実行する関数です。特に断りのない限り、メタメソッドは実際には任意の呼び出し可能な値であり、それは関数または`__call`メタメソッドを持つ値のいずれかです。

[`getmetatable`](06-standard-libraries.md#getmetatable)関数を使用して、任意の値のメタテーブルをクエリできます。Luaは、生のアクセス（[`rawget`](06-standard-libraries.md#rawget)を参照）を使用してメタテーブル内のメタメソッドをクエリします。

[`setmetatable`](06-standard-libraries.md#setmetatable)関数を使用して、テーブルのメタテーブルを置き換えることができます。デバッグライブラリ（[§6.10](06-standard-libraries.md#610--デバッグライブラリ)）を使用する場合を除き、Luaコードから他の型のメタテーブルを変更することはできません。

複数のテーブルやユーザーデータがメタテーブルを共有できますが、テーブルとフルユーザーデータは個別のメタテーブルを持ちます。他のすべての型の値は、型ごとに1つのメタテーブルを共有します。つまり、すべての数値に1つのメタテーブル、すべての文字列に1つのメタテーブルなどがあります。デフォルトでは、値はメタテーブルを持ちませんが、文字列ライブラリは文字列型にメタテーブルを設定します（[§6.4](06-standard-libraries.md#64--文字列操作)を参照）。

メタテーブルによって制御される操作の詳細なリストを次に示します。各イベントは、対応するキーによって識別されます。慣例により、Luaで使用されるすべてのメタテーブルキーは、2つのアンダースコアに続けて小文字のラテン文字で構成されています。

- **`__add`:** 加算（`+`）操作。加算のオペランドが数値でない場合、Luaはメタメソッドを呼び出そうとします。まず最初のオペランドをチェックします（それが数値であっても）。そのオペランドが`__add`のメタメソッドを定義していない場合、Luaは2番目のオペランドをチェックします。Luaがメタメソッドを見つけることができる場合、Luaは2つのオペランドを引数としてメタメソッドを呼び出し、呼び出しの結果（1つの値に調整）が操作の結果になります。それ以外の場合、メタメソッドが見つからないと、Luaはエラーを発生させます。

- **`__sub`:** 減算（`-`）操作。加算操作と同様の動作。

- **`__mul`:** 乗算（`*`）操作。加算操作と同様の動作。

- **`__div`:** 除算（`/`）操作。加算操作と同様の動作。

- **`__mod`:** モジュロ（`%`）操作。加算操作と同様の動作。

- **`__pow`:** 指数（`^`）操作。加算操作と同様の動作。

- **`__unm`:** 否定（単項`-`）操作。加算操作と同様の動作。

- **`__idiv`:** 床除算（`//`）操作。加算操作と同様の動作。

- **`__band`:** ビット単位AND（`&`）操作。加算操作と同様の動作ですが、オペランドが整数でも整数に強制変換可能な浮動小数点数でもない場合、Luaはメタメソッドを試行します（[§3.4.3](03-language.md#343--強制変換と変換)を参照）。

- **`__bor`:** ビット単位OR（`|`）操作。ビット単位AND操作と同様の動作。

- **`__bxor`:** ビット単位排他的OR（バイナリ`~`）操作。ビット単位AND操作と同様の動作。

- **`__bnot`:** ビット単位NOT（単項`~`）操作。ビット単位AND操作と同様の動作。

- **`__shl`:** ビット単位左シフト（`<<`）操作。ビット単位AND操作と同様の動作。

- **`__shr`:** ビット単位右シフト（`>>`）操作。ビット単位AND操作と同様の動作。

- **`__concat`:** 連結（`..`）操作。加算操作と同様の動作ですが、オペランドが文字列でも数値でもない場合（常に文字列に強制変換可能）、Luaはメタメソッドを試行します。

- **`__len`:** 長さ（`#`）操作。オブジェクトが文字列でない場合、Luaはそのメタメソッドを試行します。メタメソッドがある場合、Luaはオブジェクトを引数として呼び出し、呼び出しの結果（常に1つの値に調整）が操作の結果になります。メタメソッドはないが、オブジェクトがテーブルの場合、Luaはテーブルの長さの操作を使用します（[§3.4.7](03-language.md#347--長さ演算子)を参照）。それ以外の場合、Luaはエラーを発生させます。

- **`__eq`:** 等しい（`==`）操作。加算操作と同様の動作ですが、比較対象の値がテーブルまたはフルユーザーデータであり、原始的に等しくない場合にのみ、Luaはメタメソッドを試行します。呼び出しの結果は常にブール値に変換されます。

- **`__lt`:** より小さい（`<`）操作。加算操作と同様の動作ですが、比較対象の値が数値でも文字列でもない場合にのみ、Luaはメタメソッドを試行します。さらに、呼び出しの結果は常にブール値に変換されます。

- **`__le`:** 以下（`<=`）操作。より小さい操作と同様の動作。

- **`__index`:** インデックスアクセス操作`table[key]`。このイベントは、`table`がテーブルではない場合、または`key`が`table`に存在しない場合に発生します。メタ値は、`table`のメタテーブルで検索されます。

  このイベントのメタ値は、関数、テーブル、または`__index`メタ値を持つ任意の値のいずれかです。関数である場合は、`table`と`key`を引数として呼び出され、呼び出しの結果（1つの値に調整）が操作の結果になります。それ以外の場合、最終的な結果は、このメタ値を`key`でインデックス付けした結果です。このインデックス付けは生ではなく、通常どおりに行われるため、別の`__index`メタ値をトリガーする可能性があります。

- **`__newindex`:** インデックス割り当て`table[key] = value`。インデックスイベントと同様に、このイベントは、`table`がテーブルではない場合、または`key`が`table`に存在しない場合に発生します。メタ値は、`table`のメタテーブルで検索されます。

  インデックス付けと同様に、このイベントのメタ値は、関数、テーブル、または`__newindex`メタ値を持つ任意の値のいずれかです。関数である場合、`table`、`key`、および`value`を引数として呼び出されます。それ以外の場合、Luaはこのメタ値に対して、同じキーと値を使用してインデックス割り当てを繰り返します。この割り当ては生ではなく、通常どおりに行われるため、別の`__newindex`メタ値をトリガーする可能性があります。

  `__newindex`メタ値が呼び出されるたびに、Luaは原始的な割り当てを実行しません。必要な場合、メタメソッド自体が[`rawset`](06-standard-libraries.md#rawset)を呼び出して割り当てを行うことができます。

- **`__call`:** 呼び出し操作`func(args)`。このイベントは、Luaが関数以外の値（つまり、`func`が関数ではない）を呼び出そうとした場合に発生します。メタメソッドは、`func`で検索されます。存在する場合、メタメソッドは、最初の引数として`func`を、その後に元の呼び出しの引数（`args`）を付けて呼び出されます。呼び出しのすべての結果が操作の結果です。これは、複数の結果を許可する唯一のメタメソッドです。

前のリストに加えて、インタープリターはメタテーブルで次のキーも尊重します。`__gc`（[§2.5.3](#253--ガベージコレクションメタメソッド)を参照）、`__close`（[§3.3.8](03-language.md#338--to-be-closedな変数)を参照）、`__mode`（[§2.5.4](#254--ウィークテーブル)を参照）、および`__name`（`__name`エントリが文字列を含む場合、[`tostring`](06-standard-libraries.md#tostring)およびエラーメッセージで使用される場合があります）。

単項演算子（否定、長さ、ビット単位NOT）の場合、メタメソッドは計算され、最初のオペランドと等しいダミーの2番目のオペランドを使用して呼び出されます。この追加のオペランドは、Luaの内部を簡略化するためだけに使用され（これらの演算子をバイナリ演算のように動作させる）、将来のバージョンでは削除される可能性があります。ほとんどの場合、この追加のオペランドは無関係です。

メタテーブルは通常のテーブルであるため、上記で定義したイベント名だけでなく、任意のフィールドを含めることができます。標準ライブラリの一部の関数（例：[`tostring`](06-standard-libraries.md#tostring)）は、独自の目的のためにメタテーブルの他のフィールドを使用します。

一部のオブジェクトのメタテーブルとして設定する前に、必要なすべてのメタメソッドをテーブルに追加することをお勧めします。特に、`__gc`メタメソッドは、この順序に従う場合にのみ機能します（[§2.5.3](#253--ガベージコレクションメタメソッド)を参照）。オブジェクトのメタテーブルは、作成直後に設定することをお勧めします。

## 2.5 – ガベージコレクション

Luaは自動メモリ管理を実行します。これは、新しいオブジェクトのメモリを割り当てることや、オブジェクトが不要になったときにメモリを解放することを心配する必要がないことを意味します。Luaは、**ガベージコレクタ**を実行してすべての**デッドオブジェクト**を収集することにより、メモリを自動的に管理します。Luaで使用されるすべてのメモリは、自動管理の対象となります。文字列、テーブル、ユーザーデータ、関数、スレッド、内部構造などです。

オブジェクトは、ガベージコレクタが、プログラムの通常の実行においてそのオブジェクトが再びアクセスされないと確信できるとすぐに、*デッド*と見なされます。（ここでいう「通常の実行」には、デッドオブジェクトを復活させる可能性のあるファイナライザ（[§2.5.3](#253--ガベージコレクションメタメソッド)を参照）や、デバッグライブラリを使用した操作は含まれません。）コレクタがオブジェクトがデッドであると確信できるタイミングは、プログラマーの期待と一致しない場合があることに注意してください。保証されているのは、Luaがプログラムの通常の実行においてまだアクセスされる可能性のあるオブジェクトを収集しないこと、そしてLuaからアクセスできないオブジェクトは最終的に収集されるということです。（ここでいう*Luaからアクセスできない*とは、変数も他の生存しているオブジェクトもそのオブジェクトを参照していないことを意味します。）LuaはCコードに関する知識を持っていないため、グローバル環境（[§2.2](#22--スコープ変数および環境)参照）を含むレジストリ（[§4.3](04-c-api.md#43--レジストリ)参照）を通してアクセスできるオブジェクトを収集することはありません。

Luaのガベージコレクタ（GC）は、**インクリメンタルモード**と**ジェネレーショナルモード**の2つのモードで動作できます。

デフォルトのパラメータを使用したデフォルトのGCモードは、ほとんどの用途に適しています。しかし、メモリの割り当てと解放に多くの時間を費やしているプログラムでは、他の設定が役立つ場合があります。GCの動作は、プラットフォーム間および異なるLuaリリース間で移植性がないことに注意してください。したがって、最適な設定も移植性がないことになります。

GCモードとパラメータは、C言語では[`lua_gc`](04-c-api.md#lua_gc)を呼び出すことで、Luaでは[`collectgarbage`](06-standard-libraries.md#collectgarbage)を呼び出すことで変更できます。これらの関数を使用して、コレクタを直接制御することもできます（例えば、停止や再起動）。

### 2.5.1 – インクリメンタルガベージコレクション

インクリメンタルモードでは、各GCサイクルは、プログラムの実行とインターリーブされた小さなステップで**マークアンドスイープ**コレクションを実行します。このモードでは、コレクタは3つの数値を使用して、ガベージコレクションサイクルを制御します。すなわち、**ガベージコレクタの一時停止**、**ガベージコレクタのステップ乗数**、および**ガベージコレクタのステップサイズ**です。

ガベージコレクタの一時停止は、コレクタが新しいサイクルを開始するまでに待機する時間を制御します。コレクタは、メモリの使用量が前のコレクション後の使用量の*n%*に達すると、新しいサイクルを開始します。値が大きいほど、コレクタの積極性が低くなります。100以下の値は、コレクタが新しいサイクルを開始するのを待たないことを意味します。200の値は、コレクタが使用中のメモリの合計が2倍になるのを待ってから新しいサイクルを開始することを意味します。

ガベージコレクタのステップサイズは、各インクリメンタルステップのサイズを制御します。具体的には、インタプリタがステップを実行する前に何バイト割り当てるかです。値*n*は、インタプリタがステップ間で約*n*バイトを割り当てることを意味します。

ガベージコレクタのステップ乗数は、各インクリメンタルステップがどれだけの作業を行うかを制御します。値*n*は、割り当てられた各ワードに対して、インタプリタが*n%*の*作業単位*を実行することを意味します。作業単位は、おおよそ1つのスロットの走査または1つのオブジェクトのスイープに相当します。値が大きいほど、コレクタの積極性が高くなります。値が小さすぎると、コレクタが遅すぎてサイクルを完了できなくなる可能性があることに注意してください。特別なケースとして、ゼロ値は無制限の作業を意味し、事実上、非インクリメンタルなストップザワールドコレクタになります。

### 2.5.2 – ジェネレーショナルガベージコレクション

ジェネレーショナルモードでは、コレクタは頻繁に**マイナーコレクション**を実行し、これは最近作成されたオブジェクトのみを走査します。マイナーコレクションの後でもメモリ使用量が制限を超えている場合、コレクタはすべてのオブジェクトを走査する**メジャーコレクション**に移行します。その後、コレクタはマイナーコレクションに戻る正当性があると判断するまで、メジャーコレクションを続けます。

ジェネレーショナルモードでは、3つのパラメータを使用します。**マイナー乗数**、**マイナー-メジャー乗数**、および**メジャー-マイナー乗数**です。

マイナー乗数は、マイナーコレクションの頻度を制御します。マイナー乗数*x*の場合、新しいマイナーコレクションは、メモリ使用量が前のメジャーコレクション後の使用量よりも*x%*大きくなると実行されます。たとえば、乗数が20の場合、コレクタは、メモリ使用量が前のメジャーコレクション後の使用量よりも20%大きくなると、マイナーコレクションを実行します。

マイナー-メジャー乗数は、メジャーコレクションへの移行を制御します。乗数*x*の場合、古いオブジェクトからのバイト数が前のメジャーコレクション後の合計よりも*x%*大きくなると、コレクタはメジャーコレクションに移行します。たとえば、乗数が100の場合、古いバイト数が前のメジャーコレクション後の合計の2倍を超えると、コレクタはメジャーコレクションを実行します。特別なケースとして、0の値はコレクタがメジャーコレクションを行うのを停止します。

メジャー-マイナー乗数は、マイナーコレクションへの移行を制御します。乗数*x*の場合、メジャーコレクションが前のサイクル中に割り当てられたバイトの少なくとも*x%*を収集すると、コレクタはマイナーコレクションに戻ります。特に、乗数が0の場合、コレクタは1回のメジャーコレクションを行った直後にマイナーコレクションに戻ります。

### 2.5.3 – ガベージコレクションメタメソッド

テーブルに対して、またC APIを使用して、フルuserdataに対してガベージコレクションメタメソッドを設定できます（[§2.4](#24--メタテーブルとメタメソッド)を参照）。これらのメタメソッドは、**ファイナライザ**とも呼ばれ、対応するテーブルまたはuserdataがデッドであるとガベージコレクタが検出したときに呼び出されます。ファイナライザを使用すると、ファイル、ネットワーク、またはデータベース接続のクローズや独自のメモリの解放など、Luaのガベージコレクションを外部リソース管理と連携させることができます。

収集時にファイナライズされるオブジェクト（テーブルまたはuserdata）にするには、**ファイナライズ対象としてマーク**する必要があります。オブジェクトのメタテーブルを設定し、そのメタテーブルに`__gc`メタメソッドがある場合に、オブジェクトをファイナライズ対象としてマークします。`__gc`フィールドなしでメタテーブルを設定し、後でそのフィールドをメタテーブルに作成した場合、オブジェクトはファイナライズ対象としてマークされないことに注意してください。

マークされたオブジェクトがデッドになると、ガベージコレクタによってすぐに収集されるわけではありません。代わりに、Luaはそれをリストに入れます。コレクション後、Luaはそのリストを調べます。リスト内の各オブジェクトについて、Luaはそのオブジェクトの`__gc`メタメソッドをチェックします。存在する場合、Luaはオブジェクトを単一の引数として渡してそれを呼び出します。

各ガベージコレクションサイクルの終わりに、ファイナライザは、そのサイクルで収集されたオブジェクトのうち、プログラムで最後にマークされたオブジェクトに関連付けられたものが最初に呼び出されるという逆順で呼び出されます。各ファイナライザの実行は、通常のコードの実行中の任意の時点で発生する可能性があります。

収集されているオブジェクトはファイナライザによってまだ使用されている必要があるため、そのオブジェクト（およびそれを通してのみアクセス可能な他のオブジェクト）はLuaによって**復活**される必要があります。通常、この復活は一時的なものであり、オブジェクトのメモリは次のガベージコレクションサイクルで解放されます。ただし、ファイナライザがオブジェクトをグローバルな場所（例えば、グローバル変数）に格納する場合、復活は永続的になります。さらに、ファイナライザがファイナライズ対象のオブジェクトを再びファイナライズ対象としてマークした場合、そのファイナライザは、オブジェクトがデッドである次のサイクルで再び呼び出されます。いずれにしても、オブジェクトのメモリが解放されるのは、オブジェクトがデッドであり、ファイナライズ対象としてマークされていないGCサイクルでのみです。

状態を閉じるとき（[`lua_close`](04-c-api.md#lua_close)を参照）、Luaは、マークされた順序の逆順に従って、ファイナライズ対象としてマークされたすべてのオブジェクトのファイナライザを呼び出します。この段階で、ファイナライザが収集対象としてオブジェクトをマークした場合、これらのマークは効果がありません。

ファイナライザは、yieldしたり、ガベージコレクタを実行したりすることはできません。それらは予測不可能な時間に実行される可能性があるため、各ファイナライザを、関連付けられたリソースを適切に解放するために必要な最小限の操作に制限することをお勧めします。

ファイナライザの実行中にエラーが発生すると、警告が生成されます。エラーは伝播されません。

### 2.5.4 – ウィークテーブル

**ウィークテーブル**は、その要素が**ウィーク参照**であるテーブルです。ウィーク参照は、ガベージコレクタによって無視されます。言い換えれば、オブジェクトへの参照がウィーク参照のみである場合、ガベージコレクタはそのオブジェクトを収集します。

ウィークテーブルは、ウィークキー、ウィーク値、またはその両方を持つことができます。ウィーク値を持つテーブルは、その値のコレクションを許可しますが、キーのコレクションを防ぎます。ウィークキーとウィーク値の両方を持つテーブルは、キーと値の両方のコレクションを許可します。いずれの場合も、キーまたは値のいずれかが収集されると、ペア全体がテーブルから削除されます。テーブルの弱さは、メタテーブルの`__mode`フィールドによって制御されます。このメタ値が存在する場合、以下のいずれかの文字列である必要があります。ウィークキーを持つテーブルの場合は"`k`"、ウィーク値を持つテーブルの場合は"`v`"、ウィークキーとウィーク値の両方を持つテーブルの場合は"`kv`"です。

ウィークキーとストロング値を持つテーブルは、**エフェメロンテーブル**とも呼ばれます。エフェメロンテーブルでは、値は、そのキーが到達可能な場合にのみ到達可能と見なされます。特に、キーへの唯一の参照がその値を介して行われている場合、ペアは削除されます。

テーブルの弱さの変更は、次の収集サイクルでのみ有効になる場合があります。特に、弱さをより強いモードに変更した場合、変更が有効になる前に、Luaがそのテーブルから一部の項目を収集する可能性があります。

明示的な構築を持つオブジェクトのみがウィークテーブルから削除されます。数値やライトC関数などの値は、ガベージコレクションの対象ではないため、ウィークテーブルから削除されません（関連付けられた値が収集されない限り）。文字列はガベージコレクションの対象ですが、明示的な構築がなく、その等価性は値によって行われるため、オブジェクトよりも値のように動作します。したがって、それらはウィークテーブルから削除されません。

復活したオブジェクト（つまり、ファイナライズ中のオブジェクト、およびファイナライズ中のオブジェクトを通してのみアクセス可能なオブジェクト）は、ウィークテーブルで特別な動作をします。それらはファイナライザを実行する前にウィーク値から削除されますが、ウィークキーからは、それらのオブジェクトが実際に解放される、ファイナライザの実行後の次のコレクションでのみ削除されます。この動作により、ファイナライザはウィークテーブルを介してオブジェクトに関連付けられたプロパティにアクセスできます。

ウィークテーブルがコレクションサイクルで復活したオブジェクトに含まれている場合、次のサイクルまで適切にクリアされない可能性があります。

## 2.6 – コルーチン

Luaは、**協調的マルチスレッディング**とも呼ばれるコルーチンをサポートしています。Luaにおけるコルーチンは、独立した実行スレッドを表します。ただし、マルチスレッドシステムのスレッドとは異なり、コルーチンは明示的にyield関数を呼び出すことによってのみ実行を中断します。

[`coroutine.create`](06-standard-libraries.md#coroutinecreate)を呼び出すことによってコルーチンを作成します。唯一の引数は、コルーチンのメイン関数である関数です。`create`関数は新しいコルーチンを作成し、そのハンドル（*thread*型のオブジェクト）を返すだけで、コルーチンを開始しません。

[`coroutine.resume`](06-standard-libraries.md#coroutineresume)を呼び出すことによってコルーチンを実行します。[`coroutine.resume`](06-standard-libraries.md#coroutineresume)を最初に呼び出す際に、[`coroutine.create`](06-standard-libraries.md#coroutinecreate)によって返されたスレッドを最初の引数として渡すと、コルーチンはそのメイン関数を呼び出すことによって実行を開始します。[`coroutine.resume`](06-standard-libraries.md#coroutineresume)に渡された追加の引数は、その関数への引数として渡されます。コルーチンの実行が開始されると、コルーチンは終了するか、*yield*するまで実行を続けます。

コルーチンは、次の2つの方法で実行を終了できます。1つは、メイン関数が（最後の命令の後、明示的または暗黙的に）戻るときに正常に終了する方法と、もう1つは、保護されていないエラーが発生した場合に異常終了する方法です。正常終了の場合、[`coroutine.resume`](06-standard-libraries.md#coroutineresume)は**true**と、コルーチンのメイン関数から返された値を返します。エラーの場合、[`coroutine.resume`](06-standard-libraries.md#coroutineresume)は**false**とエラーオブジェクトを返します。この場合、コルーチンはスタックを巻き戻さないため、デバッグAPIを使用してエラー後にスタックを検査できます。

コルーチンは、[`coroutine.yield`](06-standard-libraries.md#coroutineyield)を呼び出すことによってyieldします。コルーチンがyieldすると、対応する[`coroutine.resume`](06-standard-libraries.md#coroutineresume)は、yieldがネストされた関数呼び出し内（つまり、メイン関数ではなく、メイン関数によって直接的または間接的に呼び出された関数内）で発生した場合でも、直ちに返ります。yieldの場合、[`coroutine.resume`](06-standard-libraries.md#coroutineresume)は**true**と、[`coroutine.yield`](06-standard-libraries.md#coroutineyield)に渡された値を返します。次回同じコルーチンを再開すると、[`coroutine.yield`](06-standard-libraries.md#coroutineyield)への呼び出しが、[`coroutine.resume`](06-standard-libraries.md#coroutineresume)に渡された追加の引数を返すことで、yieldした場所から実行を継続します。

[`coroutine.create`](06-standard-libraries.md#coroutinecreate)と同様に、[`coroutine.wrap`](06-standard-libraries.md#coroutinewrap)関数もコルーチンを作成しますが、コルーチン自体を返す代わりに、呼び出されるとコルーチンを再開する関数を返します。この関数に渡された引数は、[`coroutine.resume`](06-standard-libraries.md#coroutineresume)への追加の引数として渡されます。[`coroutine.wrap`](06-standard-libraries.md#coroutinewrap)は、[`coroutine.resume`](06-standard-libraries.md#coroutineresume)によって返されたすべての値を、最初の値（ブールエラーコード）を除いて返します。[`coroutine.resume`](06-standard-libraries.md#coroutineresume)とは異なり、[`coroutine.wrap`](06-standard-libraries.md#coroutinewrap)によって作成された関数は、エラーを呼び出し元に伝播します。この場合、関数はコルーチンも閉じます（[`coroutine.close`](06-standard-libraries.md#coroutineclose)を参照）。

コルーチンの動作例として、次のコードを考えてみましょう：

```lua
function foo (a)
  print("foo", a)
  return coroutine.yield(2*a)
end

co = coroutine.create(function (a,b)
      print("co-body", a, b)
      local r = foo(a+1)
      print("co-body", r)
      local r, s = coroutine.yield(a+b, a-b)
      print("co-body", r, s)
      return b, "end"
end)

print("main", coroutine.resume(co, 1, 10))
print("main", coroutine.resume(co, "r"))
print("main", coroutine.resume(co, "x", "y"))
print("main", coroutine.resume(co, "x", "y"))
```

これを実行すると、次の出力が生成されます：

```
co-body 1       10
foo     2
main    true    4
co-body r
main    true    11      -9
co-body x       y
main    true    10      end
main    false   cannot resume dead coroutine
```

C APIを介してコルーチンを作成および操作することもできます。関数[`lua_newthread`](04-c-api.md#lua_newthread)、[`lua_resume`](04-c-api.md#lua_resume)、および[`lua_yield`](04-c-api.md#lua_yield)を参照してください。

---

[← 前へ: 1 – 序論](01-introduction.md) | [目次](./README.md) | [次へ: 3 – 言語 →](03-language.md)
