# 3 – 言語

[← 前へ: 2 – 基本概念](02-basic-concepts.md) | [目次](./README.md) | [次へ: 4 – アプリケーションプログラムインターフェース →](04-c-api.md)

---

このセクションでは、Luaの語彙、構文、および意味について説明します。言い換えれば、どのトークンが有効か、それらをどのように組み合わせることができるか、およびそれらの組み合わせが何を意味するかについて説明します。

言語構成は、通常の拡張BNF表記を使用して説明されます。{*a*}は0個以上の*a*を意味し、[*a*]はオプションの*a*を意味します。非終端記号は`non-terminal`のように表示され、キーワードは**kword**のように表示され、その他の終端記号は`'='`のように表示されます。Luaの完全な構文は、このマニュアルの最後に[§9](09-complete-syntax.md)にあります。

## 3.1 – 字句規則

Luaは自由形式の言語です。2つのトークン間の区切り文字として以外は、字句要素（トークン）間のスペースとコメントを無視します。ソースコードでは、Luaは標準ASCII空白文字（スペース、改ページ、改行、復帰、水平タブ、垂直タブ）をスペースとして認識します。

Luaの**名前**（**識別子**とも呼ばれる）は、ラテン文字、アラビア・インド数字、およびアンダースコアで構成される任意の文字列で、数字で始まらず、予約語でないものであれば使用できます。識別子は、変数、テーブルフィールド、およびラベルに名前を付けるために使用されます。

次の**キーワード**は予約されており、名前として使用することはできません：

```
and       break     do        else      elseif    end
false     for       function  global    goto      if
in        local     nil       not       or        repeat
return    then      true      until     while
```

Luaは大文字と小文字を区別する言語です。`and`は予約語ですが、`And`と`AND`は2つの異なる有効な名前です。慣例として、プログラムはアンダースコアと1つ以上の大文字（[`_VERSION`](06-standard-libraries.md#_VERSION)など）で始まる名前の作成を避ける必要があります。

次の文字列は、他のトークンを示します：

```
+     -     *     /     %     ^     #
&     ~     |     <<    >>    //
==    ~=    <=    >=    <     >     =
(     )     {     }     [     ]     ::
;     :     ,     .     ..    ...
```

**短いリテラル文字列**は、一致する単一引用符または二重引用符で区切ることができ、次のCのようなエスケープシーケンスを含めることができます：`'\a'`（ベル）、`'\b'`（バックスペース）、`'\f'`（改ページ）、`'\n'`（改行）、`'\r'`（復帰）、`'\t'`（水平タブ）、`'\v'`（垂直タブ）、`'\\'`（バックスラッシュ）、`'\"'`（引用符）、および`'\''`（アポストロフィ）。バックスラッシュの後に改行が続くと、文字列内の改行になります。エスケープシーケンス`'\z'`は、改行を含む後続の空白文字スパンをスキップします。これは、文字列の内容に改行やスペースを追加せずに、長いリテラル文字列を複数行に分割してインデントするのに特に役立ちます。短いリテラル文字列には、エスケープされていない改行や、有効なエスケープシーケンスを形成しないエスケープを含めることはできません。

埋め込みゼロを含む、短いリテラル文字列内の任意のバイトを、その数値で指定できます。これは、エスケープシーケンス`\xXX`（*XX*は正確に2つの16進数）またはエスケープシーケンス`\ddd`（*ddd*は最大3つの10進数）を使用して行うことができます。（10進数のエスケープシーケンスの後に数字が続く場合は、正確に3桁で表現する必要があることに注意してください。）

Unicode文字のUTF-8エンコードは、エスケープシーケンス`\u{XXX}`（必須の括弧で囲む）を使用してリテラル文字列に挿入できます。ここで、*XXX*は文字コードポイントを表す1つ以上の16進数です。このコードポイントは、*2³¹*未満の値にすることができます。（Luaはここで元のUTF-8仕様を使用しており、有効なUnicodeコードポイントに限定されません。）

リテラル文字列は、**長い括弧**で囲まれた長い形式を使用して定義することもできます。レベル*n*の**開始長い括弧**を、左角括弧の後に*n*個の等号が続き、その後に別の左角括弧が続くものとして定義します。したがって、レベル0の開始長い括弧は`[[`と記述され、レベル1の開始長い括弧は`[=[`と記述されます。**終了長い括弧**も同様に定義されます。たとえば、レベル4の終了長い括弧は`]====]`と記述されます。**長いリテラル**は、任意のレベルの開始長い括弧で始まり、同じレベルの最初の終了長い括弧で終わります。同じレベルの終了括弧を除く任意のテキストを含めることができます。この括弧形式のリテラルは、複数行にまたがることができ、エスケープシーケンスを解釈せず、他のレベルの長い括弧を無視します。あらゆる種類の行末シーケンス（復帰、改行、復帰に続く改行、または改行に続く復帰）は、単純な改行に変換されます。開始長い括弧の直後に改行が続く場合、その改行は文字列に含まれません。

例として、ASCIIを使用するシステム（`'a'`が97、改行が10、`'1'`が49としてコード化されている）では、以下の5つのリテラル文字列は同じ文字列を表します：

```lua
a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]
```

前の規則によって明示的に影響を受けないリテラル文字列内の任意のバイトは、それ自身を表します。ただし、Luaは解析のためにテキストモードでファイルを開き、システムのファイル関数は一部の制御文字で問題が発生する可能性があります。したがって、バイナリデータは、テキスト以外の文字に対して明示的なエスケープシーケンスを使用する引用符付きリテラルとして表現する方が安全です。

**数値定数**（または**数詞**）は、オプションの小数部と、文字`'e'`または`'E'`でマークされたオプションの10進指数で記述できます。Luaは、`0x`または`0X`で始まる16進定数も受け入れます。16進定数は、オプションの小数部と、文字`'p'`または`'P'`でマークされ10進数で記述されたオプションのバイナリ指数も受け入れます。（たとえば、`0x1.fp10`は1984を示し、これは*0x1f / 16*に*2¹⁰*を乗じたものです。）

基数点または指数を持つ数値定数は浮動小数点数を表します。それ以外の場合、その値が整数に適合するか、16進定数である場合は、整数を表します。それ以外の場合（つまり、オーバーフローする10進整数数詞）、浮動小数点数を表します。基数点も指数もない16進数詞は常に整数値を表します。値がオーバーフローすると、有効な整数に収まるように**折り返され**ます。

有効な整数定数の例：

```lua
3   345   0xff   0xBEBADA
```

有効な浮動小数点定数の例：

```lua
3.0     3.1416     314.16e-2     0.31416E1     34e1
0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
```

**コメント**は、文字列の外側の任意の場所で二重ハイフン（`--`）で始まります。`--`の直後のテキストが開始長い括弧でない場合、コメントは**短いコメント**であり、行末まで続きます。それ以外の場合、**長いコメント**であり、対応する終了長い括弧まで続きます。

## 3.2 – 変数

変数は値を格納する場所です。Luaには、グローバル変数、ローカル変数、およびテーブルフィールドの3種類の変数があります。

単一の名前は、グローバル変数またはローカル変数（または、ローカル変数の特定の種類である関数の仮パラメータ）を表すことができます（[§2.2](02-basic-concepts.md#22--スコープ変数および環境)を参照）：

```
var ::= Name
```

Nameは識別子を示します（[§3.1](#31--字句規則)を参照）。

変数は**レキシカルスコープ**を持つため、ローカル変数はそのスコープ内で定義された関数から自由にアクセスできます（[§2.2](02-basic-concepts.md#22--スコープ変数および環境)を参照）。

変数への最初の代入が行われる前、その値は**nil**です。

角括弧は、テーブルのインデックス付けに使用されます：

```
var ::= prefixexp '[' exp ']'
```

テーブルフィールドへのアクセスは、メタテーブルを介して意味を変更できます（[§2.4](02-basic-concepts.md#24--メタテーブルとメタメソッド)を参照）。

構文`var.Name`は、`var["Name"]`のシンタックスシュガーです：

```
var ::= prefixexp '.' Name
```

グローバル変数`x`へのアクセスは、`_ENV.x`と同等です。

## 3.3 – ステートメント

Luaは、他の一般的な言語と同様の、ほぼ従来のステートメントセットをサポートしています。このセットには、ブロック、代入、制御構造、関数呼び出し、変数宣言が含まれます。

### 3.3.1 – ブロック

ブロックはステートメントのリストであり、順次実行されます：

```
block ::= {stat}
```

Luaには、ステートメントをセミコロンで区切ったり、セミコロンでブロックを開始したり、セミコロンを2つ続けて記述したりできる、**空のステートメント**があります：

```
stat ::= ';'
```

関数呼び出しと代入の両方が、開き括弧で始まることができます。この可能性は、Luaの文法にあいまいさを生じさせます。次のフラグメントを考えてみましょう：

```lua
a = b + c
(print or io.write)('done')
```

文法は、このフラグメントを2つの方法で見ることができます：

```lua
a = b + c(print or io.write)('done')

a = b + c; (print or io.write)('done')
```

現在のパーサーは、常にこのような構造を最初の方法で見て、開き括弧を呼び出しの引数の開始として解釈します。このあいまいさを避けるために、括弧で始まるステートメントの前には常にセミコロンを付けるのが良い習慣です：

```lua
;(print or io.write)('done')
```

ブロックを明示的に区切って、単一のステートメントを作成できます：

```
stat ::= do block end
```

明示的なブロックは、変数宣言のスコープを制御するのに役立ちます。明示的なブロックは、別のブロックの途中に**return**ステートメントを追加するためにも使用されることがあります（[§3.3.4](#334--制御構造)参照）。

### 3.3.2 – チャンク

Luaのコンパイル単位は、**チャンク**と呼ばれます。構文的には、チャンクは単なるブロックです：

```
chunk ::= block
```

Luaは、チャンクを可変数の引数を持つ匿名関数の本体として扱います（[§3.4.11](#3411--関数定義)を参照）。そのため、チャンクはローカル変数を定義したり、引数を受け取ったり、値を返したりできます。さらに、そのような匿名関数は、`_ENV`と呼ばれる外部ローカル変数のスコープ内でコンパイルされます（[§2.2](02-basic-concepts.md#22--スコープ変数および環境)を参照）。結果の関数は、その変数を使用しなくても、常に`_ENV`を唯一の外部変数として持ちます。

チャンクは、ファイルまたはホストプログラム内の文字列に格納できます。チャンクを実行するために、Luaはまずチャンクを**ロード**し、チャンクのコードを仮想マシンの命令にプリコンパイルします。次に、Luaは仮想マシンのインタープリターを使用して、コンパイルされたコードを実行します。

チャンクはバイナリ形式にプリコンパイルすることもできます。詳細については、プログラム`luac`および関数[`string.dump`](06-standard-libraries.md#stringdump)を参照してください。ソース形式とコンパイル形式のプログラムは交換可能です。Luaはファイルタイプを自動的に検出して、それに応じて動作します（[`load`](06-standard-libraries.md#load)を参照）。悪意を持って作成されたバイナリチャンクは、ソースコードとは異なり、インタープリターをクラッシュさせる可能性があることに注意してください。

### 3.3.3 – 代入

Luaでは、複数の代入が可能です。したがって、代入の構文では、左側に変数のリスト、右側に式のリストを定義します。両方のリストの要素は、カンマで区切られます：

```
stat ::= varlist '=' explist
varlist ::= var {',' var}
explist ::= exp {',' exp}
```

式については、[§3.4](#34--式)で説明します。

代入の前に、値のリストは変数のリストの長さに**調整**されます（[§3.4.12](#3412--式のリスト複数の結果および調整)参照）。

複数の代入の中で変数が代入と読み取りの両方を行っている場合、Luaはすべての読み取りが代入前の変数の値を取得するようにします。したがって、次のコード：

```lua
i = 3
i, a[i] = i+1, 20
```

は、`a[i]`の`i`が（4が代入される前に）3と評価されるため、`a[3]`を20に設定し、`a[4]`には影響を与えません。同様に、次の行：

```lua
x, y = y, x
```

は、`x`と`y`の値を交換し、

```lua
x, y, z = y, z, x
```

は、`x`、`y`、および`z`の値を循環的に並べ替えます。

この保証は、代入ステートメントの構文内のアクセスのみを対象としていることに注意してください。代入中に呼び出された関数またはメタメソッドが変数の値を変更した場合、Luaはそのアクセスの順序について保証しません。

グローバル名`x = val`への代入は、代入`_ENV.x = val`と同等です（[§2.2](02-basic-concepts.md#22--スコープ変数および環境)参照）。

テーブルフィールドとグローバル変数（実際にはテーブルフィールドでもあります）への代入の意味は、メタテーブルを介して変更できます（[§2.4](02-basic-concepts.md#24--メタテーブルとメタメソッド)参照）。

### 3.3.4 – 制御構造

制御構造**if**、**while**、および**repeat**は、通常の意味と使い慣れた構文を持ちます：

```
stat ::= while exp do block end
stat ::= repeat block until exp
stat ::= if exp then block {elseif exp then block} [else block] end
```

Luaには、2つの形式の**for**ステートメントもあります（[§3.3.5](#335--forステートメント)参照）。

制御構造の条件式は、任意の値を返すことができます。**false**と**nil**の両方がfalseとして評価されます。**nil**と**false**以外のすべての値はtrueとして評価されます。特に、数値の0と空の文字列もtrueとして評価されます。

**repeat**–**until**ループでは、内部ブロックは**until**キーワードでは終了せず、条件の後でのみ終了します。したがって、条件はループブロック内で宣言されたローカル変数を参照できます。

**goto**ステートメントは、プログラム制御をラベルに転送します。構文上の理由から、Luaのラベルもステートメントと見なされます：

```
stat ::= goto Name
stat ::= label
label ::= '::' Name '::'
```

ラベルは、ネストされた関数内を除き、定義されているブロック全体で可視になります。gotoは、変数宣言のスコープに入らない限り、任意の可視ラベルにジャンプできます。ラベルは、同じ名前の以前のラベルが可視になっている場所では宣言すべきではありません。たとえこの他のラベルが外側のブロックで宣言されている場合でもです。

**break**ステートメントは、**while**、**repeat**、または**for**ループの実行を終了し、ループ後の次のステートメントにスキップします：

```
stat ::= break
```

**break**は、最も内側の囲みループを終了します。

**return**ステートメントは、関数またはチャンク（匿名関数として扱われます）から値を返すために使用されます。関数は複数の値を返すことができるため、**return**ステートメントの構文は次のとおりです：

```
stat ::= return [explist] [';']
```

**return**ステートメントは、ブロックの最後のステートメントとしてのみ記述できます。ブロックの途中で**return**する必要がある場合は、慣用句`do return end`のように、明示的な内部ブロックを使用できます。これは、**return**が（内部）ブロックの最後のステートメントになるためです。

### 3.3.5 – Forステートメント

**for**ステートメントには、数値形式とジェネリック形式の2つの形式があります。

#### 数値forループ

数値**for**ループは、制御変数が算術進行をたどる間、コードブロックを繰り返します。次の構文があります：

```
stat ::= for Name '=' exp ',' exp [',' exp] do block end
```

指定された識別子（Name）は、ループ本体（*block*）のローカルである新しい読み取り専用（`const`）の制御変数を定義します。

ループは、3つの制御式を1回評価することから始まります。それらの値は、それぞれ**初期値**、**制限値**、**ステップ**と呼ばれます。ステップがない場合、デフォルトは1です。

初期値とステップの両方が整数の場合、ループは整数で実行されます。制限値は整数でない場合があることに注意してください。それ以外の場合、3つの値は浮動小数点数に変換され、ループは浮動小数点数で実行されます。この場合、浮動小数点数の精度に注意してください。

その初期化の後、ループ本体は、ステップで指定された共通差で、初期値から始まる算術進行をたどる制御変数の値で繰り返されます。負のステップは減少シーケンスを作成します。ゼロに等しいステップはエラーを発生させます。ループは、値が制限値以下（負のステップの場合は制限値以上）である間、続行します。初期値がすでに制限値よりも大きい（または、ステップが負の場合は小さい）場合、本体は実行されません。

整数ループの場合、制御変数がラップアラウンドすることはありません。代わりに、オーバーフローの場合にループが終了します。

#### ジェネリックforループ

ジェネリック**for**ステートメントは、**イテレーター**と呼ばれる関数を対象として動作します。反復ごとに、イテレーター関数が新しい値を生成するために呼び出され、この新しい値が**nil**になると停止します。ジェネリック**for**ループには、次の構文があります：

```
stat ::= for namelist in explist do block end
namelist ::= Name {',' Name}
```

次のような**for**ステートメント：

```lua
for var_1, ···, var_n in explist do body end
```

は、次のように動作します。

名前*var_i*は、ループ本体のローカルなループ変数を宣言します。これらの変数の最初の変数が**制御変数**であり、読み取り専用（`const`）の変数です。

ループは、*explist*を評価して、4つの値を生成することから始まります：**イテレーター関数**、**状態**、制御変数の初期値、および**終了値**です。

次に、各反復で、Luaはイテレーター関数を2つの引数（状態と制御変数）とともに呼び出します。この呼び出しの結果は、複数代入の規則に従ってループ変数に割り当てられます（[§3.3.3](#333--代入)参照）。制御変数が**nil**になると、ループが終了します。それ以外の場合、本体が実行され、ループは次の反復に進みます。

終了値は、ループが終了したときにリソースを解放するために使用できる、to-be-closedな変数（[§3.3.8](#338--to-be-closedな変数)参照）のように動作します。それ以外の場合は、ループを妨げません。

### 3.3.6 – ステートメントとしての関数呼び出し

副作用の可能性を許可するために、関数呼び出しをステートメントとして実行できます：

```
stat ::= functioncall
```

この場合、返されたすべての値は破棄されます。関数呼び出しについては、[§3.4.10](#3410--関数呼び出し)で説明します。

### 3.3.7 – 変数宣言

ローカル変数とグローバル変数は、ブロック内の任意の場所で宣言できます。宣言には初期化を含めることができます：

```
stat ::= local attnamelist ['=' explist]
stat ::= global attnamelist ['=' explist]
```

初期化がない場合、ローカル変数は**nil**で初期化されます。グローバル変数は変更されずにそのままです。それ以外の場合、初期化は複数代入と同じ調整を受けます（[§3.3.3](#333--代入)参照）。さらに、グローバル変数の場合、変数がすでに定義されている（つまり、非nil値を持つ）場合、初期化はランタイムエラーを発生させます。

名前のリストには、属性（山かっこで囲まれた名前）を前置したり、各変数名に属性を後置したりできます：

```
attnamelist ::= [attrib] Name [attrib] {',' Name [attrib]}
attrib ::= '<' Name '>'
```

前置された属性は、リスト内のすべての名前に適用されます。後置された属性は、その特定の名前に適用されます。可能な属性は2つあります。`const`は、**定数**または**読み取り専用**の変数、つまり代入の左辺として使用できない変数を宣言します。`close`は、to-be-closedな変数を宣言します（[§3.3.8](#338--to-be-closedな変数)参照）。ローカル変数のみが`close`属性を持つことができます。変数のリストには、最大で1つのto-be-closedな変数を含めることができます。

Luaは、グローバル変数の集合宣言も提供しています：

```
stat ::= global [attrib] '*'
```

この特別な形式は、以前に明示的に宣言されていないすべての名前を暗黙的にグローバルとして宣言します。特に、`global<const> *`は、以前に明示的に宣言されていないすべての名前を読み取り専用グローバルとして暗黙的に宣言します。次の例を参照してください：

```lua
global X
global<const> *
print(math.pi)   -- Ok、'print'と'math'は読み取り専用
X = 1            -- Ok、読み書き可能として宣言
Y = 1            -- エラー、Yは読み取り専用
```

[§2.2](02-basic-concepts.md#22--スコープ変数および環境)で述べたように、すべてのチャンクは暗黙の`global *`宣言で始まりますが、この前置宣言は、他の**global**宣言のスコープ内では無効になります。したがって、グローバル宣言を使用しないか、`global *`で始まるプログラムは、任意のグローバルに対して自由に読み書きアクセスできます。`global<const> *`で始まるプログラムは、任意のグローバルに対して自由に読み取り専用アクセスできます。そして、他のグローバル宣言（例：`global none`）で始まるプログラムは、宣言された変数のみを参照できます。

グローバル変数の場合、宣言の効果は構文的なものであることに注意してください（オプションの代入を除く）：

```lua
global X <const>, _G
X = 1           -- エラー
_ENV.X = 1      -- Ok
_G.print(X)     -- Ok
foo()           -- 'foo'は任意のグローバルを自由に変更できる
```

チャンクもブロックであるため（[§3.3.2](#332--チャンク)参照）、変数を明示的なブロックの外部のチャンクで宣言できます。

変数宣言の可視性規則については、[§2.2](02-basic-concepts.md#22--スコープ変数および環境)で説明されています。

### 3.3.8 – To-be-closedな変数

to-be-closedな変数は、定数ローカル変数のように動作しますが、変数がスコープ外になったときに、通常のブロック終了、**break**/**goto**/**return**によるブロックの終了、またはエラーによる終了を含め、その値が**クローズ**される点が異なります。

ここで、値を**クローズする**とは、その`__close`メタメソッドを呼び出すことを意味します。メタメソッドを呼び出すとき、値自体が最初の引数として渡されます。エラーがあった場合、終了を引き起こしたエラーオブジェクトが2番目の引数として渡されます。それ以外の場合、2番目の引数はありません。

to-be-closedな変数に割り当てられる値は、`__close`メタメソッドを持つか、false値である必要があります。（**nil**と**false**は、to-be-closedな値として無視されます。）

同じイベントで複数のto-be-closedな変数がスコープ外になった場合、それらは宣言された逆の順序でクローズされます。

クロージングメソッドの実行中にエラーが発生した場合、そのエラーは、変数が定義された通常のコードでのエラーと同様に処理されます。エラーが発生した後も、他の保留中のクロージングメソッドは引き続き呼び出されます。

コルーチンがyieldし、再開されない場合、一部の変数はスコープから外れない可能性があり、そのためクローズされることはありません。（これらの変数は、コルーチン内で作成され、コルーチンがyieldした時点でスコープ内にあるものです。）同様に、コルーチンがエラーで終了した場合、スタックを巻き戻さないため、変数をクローズしません。どちらの場合も、ファイナライザを使用するか、[`coroutine.close`](06-standard-libraries.md#coroutineclose)を呼び出して変数をクローズできます。ただし、コルーチンが[`coroutine.wrap`](06-standard-libraries.md#coroutinewrap)を介して作成された場合、対応する関数はエラーが発生した場合にコルーチンをクローズします。

## 3.4 – 式

Luaの基本的な式は次のとおりです：

```
exp ::= prefixexp
exp ::= nil | false | true
exp ::= Numeral
exp ::= LiteralString
exp ::= functiondef
exp ::= tableconstructor
exp ::= '...'
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | '(' exp ')'
```

数値とリテラル文字列については[§3.1](#31--字句規則)で、変数については[§3.2](#32--変数)で、関数定義については[§3.4.11](#3411--関数定義)で、関数呼び出しについては[§3.4.10](#3410--関数呼び出し)で、テーブルコンストラクターについては[§3.4.9](#349--テーブルコンストラクタ)で説明されています。3つのドット（`'...'`）で示される可変長引数式は、可変長引数関数の内部でのみ直接使用できます。これについては[§3.4.11](#3411--関数定義)で説明されています。

二項演算子には、算術演算子（[§3.4.1](#341--算術演算子)を参照）、ビット演算子（[§3.4.2](#342--ビット演算子)を参照）、関係演算子（[§3.4.4](#344--関係演算子)を参照）、論理演算子（[§3.4.5](#345--論理演算子)を参照）、および連結演算子（[§3.4.6](#346--連結)を参照）が含まれます。単項演算子には、単項マイナス（[§3.4.1](#341--算術演算子)を参照）、単項ビット単位NOT（[§3.4.2](#342--ビット演算子)を参照）、単項論理**not**（[§3.4.5](#345--論理演算子)を参照）、および単項**長さ演算子**（[§3.4.7](#347--長さ演算子)を参照）が含まれます。

### 3.4.1 – 算術演算子

Luaは次の算術演算子をサポートしています：

- **`+`**: 加算
- **`-`**: 減算
- **`*`**: 乗算
- **`/`**: 浮動小数点除算
- **`//`**: 床除算
- **`%`**: 剰余
- **`^`**: 指数
- **`-`**: 単項マイナス

指数と浮動小数点除算を除いて、算術演算子は次のように動作します：両方のオペランドが整数の場合、演算は整数に対して実行され、結果は整数になります。それ以外の場合、両方のオペランドが数値の場合、それらは浮動小数点数に変換され、浮動小数点演算のマシンルール（通常はIEEE 754標準）に従って演算が実行され、結果は浮動小数点数になります。（文字列ライブラリは算術演算で文字列を数値に強制変換します。詳細については[§3.4.3](#343--強制変換と変換)を参照してください。）

指数と浮動小数点除算（`/`）は、常にオペランドを浮動小数点数に変換し、結果は常に浮動小数点数になります。指数はISO C関数`pow`を使用するため、整数以外の指数にも対応できます。

床除算（`//`）は、商を負の無限大方向に丸める除算であり、オペランドの除算の床を返します。

剰余は、商を負の無限大方向（床除算）に丸める除算の余りとして定義されます。

整数演算でオーバーフローが発生した場合、すべての演算は**折り返され**ます。

### 3.4.2 – ビット演算子

Luaは次のビット演算子をサポートしています：

- **`&`**: ビット単位AND
- **`|`**: ビット単位OR
- **`~`**: ビット単位排他的OR
- **`>>`**: 右シフト
- **`<<`**: 左シフト
- **`~`**: 単項ビット単位NOT

すべてのビット単位演算は、オペランドを整数に変換し（[§3.4.3](#343--強制変換と変換)を参照）、それらの整数のすべてのビットで演算を行い、整数を返します。

右シフトと左シフトの両方で、空いているビットはゼロで埋められます。負の変位は反対方向にシフトします。整数のビット数以上の絶対値を持つ変位は、ゼロになります（すべてのビットがシフトアウトされるため）。

### 3.4.3 – 強制変換と変換

Luaは、実行時にいくつかの型と表現の間で自動変換を行います。ビット単位演算子は、常に浮動小数点オペランドを整数に変換します。指数と浮動小数点除算は、常に整数オペランドを浮動小数点数に変換します。混合数値（整数と浮動小数点数）に適用される他のすべての算術演算は、整数オペランドを浮動小数点数に変換します。C APIは、必要に応じて整数を浮動小数点数に、浮動小数点数を整数に変換します。さらに、文字列連結は、文字列に加えて数値を引数として受け入れます。

整数から浮動小数点数への変換では、整数値が浮動小数点数として正確に表現できる場合、それが結果となります。それ以外の場合、変換は、最も近い大きい値または最も近い小さい表現可能な値を取得します。この種の変換は決して失敗しません。

浮動小数点数から整数への変換では、浮動小数点数が整数として正確に表現できるかどうか（つまり、浮動小数点数が整数値を持ち、整数の表現範囲内にあるかどうか）をチェックします。そうである場合、その表現が結果になります。それ以外の場合、変換は失敗します。

Luaのいくつかの場所では、必要に応じて文字列を数値に強制変換します。特に、文字列ライブラリは、すべての算術演算で文字列を数値に強制変換しようとするメタメソッドを設定します。変換が失敗した場合、ライブラリは他のオペランドのメタメソッド（存在する場合）を呼び出すか、エラーを発生させます。ビット単位演算子は、この強制変換を行わないことに注意してください。

文字列から数値への暗黙的な強制変換に依存しないことは常に良い習慣です。これらは常に適用されるわけではないためです。特に、`"1"==1`はfalseであり、`"1"<1`はエラーを発生させます（[§3.4.4](#344--関係演算子)を参照）。これらの強制変換は主に互換性のために存在し、将来のバージョンの言語で削除される可能性があります。

文字列は、その構文とLuaレクサーのルールに従って、整数または浮動小数点数に変換されます。文字列には、先頭と末尾の空白と符号が含まれる場合もあります。文字列から数値へのすべての変換は、基数文字としてドットと現在のロケールマークの両方を受け入れます。（ただし、Luaレクサーはドットのみを受け入れます。）文字列が有効な数値でない場合、変換は失敗します。必要に応じて、この最初のステップの結果は、浮動小数点数と整数間の変換に関する前のルールに従って、特定の数値サブタイプに変換されます。

数値から文字列への変換では、指定されていない人間が読める形式を使用します。数値を特定の方法で文字列に変換するには、関数[`string.format`](06-standard-libraries.md#stringformat)を使用してください。

### 3.4.4 – 関係演算子

Luaは次の関係演算子をサポートしています：

- **`==`**: 等しい
- **`~=`**: 等しくない
- **`<`**: より小さい
- **`>`**: より大きい
- **`<=`**: 以下
- **`>=`**: 以上

これらの演算子は常に**false**または**true**を返します。

等価性（`==`）は、最初にオペランドの型を比較します。型が異なる場合、結果は**false**です。それ以外の場合、オペランドの値が比較されます。文字列は、バイト内容が同じ場合に等しくなります。数値は、数学的に同じ値を表す場合に等しくなります。

テーブル、ユーザーデータ、およびスレッドは参照によって比較されます：2つのオブジェクトが等しいと見なされるのは、同じオブジェクトである場合のみです。新しいオブジェクト（テーブル、ユーザーデータ、またはスレッド）を作成するたびに、この新しいオブジェクトは、以前に存在したオブジェクトとは異なります。関数は常にそれ自身と等しくなります。検出可能な違い（動作の違い、定義の違い）を持つ関数は常に異なります。異なる時点で作成されたが、検出可能な違いがない関数は、等しいと分類される場合とされない場合があります（内部キャッシュの詳細によって異なります）。

`__eq`メタメソッドを使用すると、Luaがテーブルとユーザーデータを比較する方法を変更できます（[§2.4](02-basic-concepts.md#24--メタテーブルとメタメソッド)を参照）。

等価性比較では、文字列を数値に、またはその逆に変換しません。したがって、`"0"==0`は**false**と評価され、`t[0]`と`t["0"]`はテーブル内の異なるエントリを表します。

演算子`~=`は、等価性（`==`）の否定です。

順序演算子は次のように動作します。両方の引数が数値の場合、それらはサブタイプに関係なく、数学的な値に従って比較されます。それ以外の場合、両方の引数が文字列である場合、それらの値は現在のロケールに従って比較されます。それ以外の場合、Luaは`__lt`または`__le`メタメソッドを呼び出そうとします（[§2.4](02-basic-concepts.md#24--メタテーブルとメタメソッド)を参照）。比較`a > b`は`b < a`に変換され、`a >= b`は`b <= a`に変換されます。

IEEE 754標準に従い、特殊値NaNは、それ自身を含め、どの値よりも小さい、等しい、または大きいとは見なされません。

### 3.4.5 – 論理演算子

Luaの論理演算子は、**and**、**or**、および**not**です。制御構造（[§3.3.4](#334--制御構造)を参照）と同様に、すべての論理演算子は、**false**と**nil**の両方をfalseとみなし、その他をtrueとみなします。

否定演算子**not**は、常に**false**または**true**を返します。論理積演算子**and**は、この値が**false**または**nil**である場合は最初の引数を返し、それ以外の場合は**and**は2番目の引数を返します。論理和演算子**or**は、この値が**nil**および**false**と異なる場合は最初の引数を返し、それ以外の場合は**or**は2番目の引数を返します。**and**と**or**の両方で短絡評価が使用されます。つまり、2番目のオペランドは必要な場合にのみ評価されます。以下にいくつかの例を示します：

```lua
10 or 20            --> 10
10 or error()       --> 10
nil or "a"          --> "a"
nil and 10          --> nil
false and error()   --> false
false and nil       --> false
false or nil        --> nil
10 and 20           --> 20
```

### 3.4.6 – 連結

Luaの文字列連結演算子は、2つのドット（`'..'`）で示されます。両方のオペランドが文字列または数値の場合、数値は指定されていない形式で文字列に変換されます（[§3.4.3](#343--強制変換と変換)を参照）。それ以外の場合、`__concat`メタメソッドが呼び出されます（[§2.4](02-basic-concepts.md#24--メタテーブルとメタメソッド)を参照）。

### 3.4.7 – 長さ演算子

長さ演算子は、単項プレフィックス演算子`#`で示されます。

文字列の長さは、そのバイト数です。（つまり、各文字が1バイトの場合の文字列長の通常の意味です。）

テーブルに適用された長さ演算子は、そのテーブルの境界を返します。テーブル`t`の**境界**は、次の条件を満たす任意の非負の整数です：

```lua
(border == 0 or t[border] ~= nil) and
(t[border + 1] == nil or border == math.maxinteger)
```

言葉で言えば、境界とは、テーブル内に存在する正の整数インデックスであり、それに続いて存在しないインデックスが続く場合と、2つの制限ケースがあります。インデックス1が存在しない場合はゼロ、そのインデックスが存在する場合は整数の最大値です。正の整数ではないキーは、境界に干渉しないことに注意してください。

境界が1つしかないテーブルは、**シーケンス**と呼ばれます。たとえば、テーブル`{10,20,30,40,50}`は境界（5）が1つしかないため、シーケンスです。テーブル`{10,20,30,nil,50}`には2つの境界（3と5）があるため、シーケンスではありません。（インデックス4の**nil**は**穴**と呼ばれます。）テーブル`{nil,20,30,nil,nil,60,nil}`には3つの境界（0、3、および6）があるため、これもシーケンスではありません。テーブル`{}`は境界0のシーケンスです。

`t`がシーケンスの場合、`#t`はその唯一の境界を返し、これはシーケンスの長さという直感的な概念に対応します。`t`がシーケンスでない場合、`#t`はその境界のいずれかを返す可能性があります。（どの境界が返されるかは、テーブルの内部表現の詳細に依存し、テーブルがどのようにデータが格納されたか、および数値ではないキーのメモリアドレスに依存します。）

テーブルの長さの計算は、最悪の場合でも*O(log n)*の時間が保証されています。ここで、*n*はテーブル内の最大の整数キーです。

プログラムは、`__len`メタメソッド（[§2.4](02-basic-concepts.md#24--メタテーブルとメタメソッド)を参照）を使用して、文字列以外の任意の値に対する長さ演算子の動作を変更できます。

### 3.4.8 – 優先順位

Luaにおける演算子の優先順位は、以下の表に従い、低いものから高いものの順に示します：

```
or
and
<     >     <=    >=    ~=    ==
|
~
&
<<    >>
..
+     -
*     /     //    %
unary operators (not   #     -     ~)
^
```

通常どおり、式での優先順位を変更するために括弧を使用できます。連結（`..`）と指数（`^`）演算子は右結合です。その他のすべての二項演算子は左結合です。

### 3.4.9 – テーブルコンストラクタ

テーブルコンストラクタは、テーブルを作成する式です。コンストラクタが評価されるたびに、新しいテーブルが作成されます。コンストラクタは、空のテーブルを作成したり、テーブルを作成してそのフィールドの一部を初期化したりするために使用できます。コンストラクタの一般的な構文は次のとおりです：

```
tableconstructor ::= '{' [fieldlist] '}'
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= '[' exp ']' '=' exp | Name '=' exp | exp
fieldsep ::= ',' | ';'
```

`[exp1] = exp2`の形式の各フィールドは、キーが`exp1`で値が`exp2`のエントリを新しいテーブルに追加します。`name = exp`の形式のフィールドは、`["name"] = exp`と同等です。`exp`の形式のフィールドは、`[i] = exp`と同等です。ここで、`i`は1から始まる連続した整数です。その他の形式のフィールドは、このカウントに影響しません。たとえば：

```lua
a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
```

は、次のものと同等です：

```lua
do
  local t = {}
  t[f(1)] = g
  t[1] = "x"         -- 1st exp
  t[2] = "y"         -- 2nd exp
  t.x = 1            -- t["x"] = 1
  t[3] = f(x)        -- 3rd exp
  t[30] = 23
  t[4] = 45          -- 4th exp
  a = t
end
```

コンストラクタ内での代入の順序は未定義です。（この順序は、キーが繰り返されている場合にのみ重要になります。）

リスト内の最後のフィールドが`exp`の形式であり、その式が複数結果の式である場合、この式によって返されるすべての値がリストに連続して入力されます（[§3.4.12](#3412--式のリスト複数の結果および調整)を参照）。

フィールドリストには、機械生成されたコードの便宜のために、オプションの末尾の区切り記号を含めることができます。

### 3.4.10 – 関数呼び出し

Luaでの関数呼び出しの構文は次のとおりです：

```
functioncall ::= prefixexp args
```

関数呼び出しでは、最初にprefixexpとargsが評価されます。prefixexpの値の型が*function*である場合、この関数は指定された引数で呼び出されます。それ以外の場合、prefixexpの`__call`メタメソッドが存在すればそれが呼び出されます。その最初の引数はprefixexpの値であり、その後に元の呼び出し引数が続きます（[§2.4](02-basic-concepts.md#24--メタテーブルとメタメソッド)を参照）。

次の形式：

```
functioncall ::= prefixexp ':' Name args
```

は、メソッドをエミュレートするために使用できます。`v:name(args)`の呼び出しは、`v.name(v, args)`のシンタックスシュガーです。ただし、`v`は一度だけ評価されます。

引数の構文は次のとおりです：

```
args ::= '(' [explist] ')'
args ::= tableconstructor
args ::= LiteralString
```

すべての引数式は、呼び出し前に評価されます。`f{fields}`の形式の呼び出しは、`f({fields})`のシンタックスシュガーです。つまり、引数リストは単一の新しいテーブルです。`f'string'`（または`f"string"`または`f[[string]]`）の形式の呼び出しは、`f('string')`のシンタックスシュガーです。つまり、引数リストは単一のリテラル文字列です。

to-be-closedな変数のスコープ内にない`return functioncall`の形式の呼び出しは、**末尾呼び出し**と呼ばれます。Luaは、**適切な末尾呼び出し**（または**適切な末尾再帰**）を実装しています。末尾呼び出しでは、呼び出される関数は呼び出し元の関数のスタックエントリを再利用します。したがって、プログラムが実行できるネストされた末尾呼び出しの数に制限はありません。ただし、末尾呼び出しは、呼び出し元の関数に関するデバッグ情報を消去します。末尾呼び出しは、**return**が引数として単一の関数呼び出しを持ち、to-be-closedな変数のスコープ外にある特定の構文でのみ発生することに注意してください。この構文により、呼び出し元の関数は、介入アクションなしに、呼び出された関数の戻り値を正確に返します。したがって、次の例はどれも末尾呼び出しではありません：

```lua
return (f(x))        -- 結果を1に調整
return 2 * f(x)      -- 結果を2倍
return x, f(x)       -- 追加の結果
f(x); return         -- 結果を破棄
return x or f(x)     -- 結果を1に調整
```

### 3.4.11 – 関数定義

関数定義の構文は次のとおりです：

```
functiondef ::= function funcbody
funcbody ::= '(' [parlist] ')' block end
```

次のシンタックスシュガーは、関数定義を簡略化します：

```
stat ::= function funcname funcbody
stat ::= local function Name funcbody
stat ::= global function Name funcbody
funcname ::= Name {'.' Name} [':' Name]
```

文：

```lua
function f () body end
```

は、次のように変換されます：

```lua
f = function () body end
```

文：

```lua
function t.a.b.c.f () body end
```

は、次のように変換されます：

```lua
t.a.b.c.f = function () body end
```

文：

```lua
local function f () body end
```

は、次のように変換されます：

```lua
local f; f = function () body end
```

ではなく：

```lua
local f = function () body end
```

（これは、関数の本体に`f`への再帰的参照が含まれている場合にのみ違いが生じます。）

同様に、文：

```lua
global function f () body end
```

は、次のように変換されます：

```lua
global f; global f = function () body end
```

2番目の**global**は、代入を初期化にし、そのグローバルがすでに定義されている場合はエラーを発生させます。

**コロン**構文は、関数に暗黙的な追加のパラメータ`self`を追加することで、**メソッド**をエミュレートするために使用されます。したがって、文：

```lua
function t.a.b.c:f (params) body end
```

は、次のシンタックスシュガーです：

```lua
t.a.b.c.f = function (self, params) body end
```

関数定義は、型が*function*の実行可能な式です。Luaがチャンクをプリコンパイルするとき、その関数本体はすべてプリコンパイルされますが、まだ作成されていません。その後、Luaが関数定義を実行するたびに、関数は**インスタンス化**（または**クローズ**）されます。この関数インスタンス、または**クロージャ**は、式の最終的な値です。

結果は、**return**ステートメント（[§3.3.4](#334--制御構造)を参照）を使用して返されます。制御が**return**ステートメントに遭遇せずに関数の終わりに到達した場合、関数は結果なしで返されます。

関数が返すことができる値の数には、システムに依存する制限があります。この制限は、1000より大きいことが保証されています。

#### パラメータ

パラメータは、引数値で初期化されるローカル変数として機能します：

```
parlist ::= namelist [',' varargparam] | varargparam
varargparam ::= '...' [Name]
```

Lua関数が呼び出されると、関数が**可変長引数関数**でない限り、引数リストをパラメータリストの長さに調整します（[§3.4.12](#3412--式のリスト複数の結果および調整)を参照）。可変長引数関数は、パラメータリストの最後に3つのドット（`'...'`）で示されます。可変長引数関数は、引数リストを調整しません。代わりに、すべての追加引数を収集し、**可変長引数テーブル**を介して関数に提供します。そのテーブルでは、インデックス1、2などの値が追加引数であり、インデックス`"n"`の値が追加引数の数です。

例として、次の定義を検討してください：

```lua
function f(a, b) end
function g(a, b, ...) end
function r() return 1,2,3 end
```

次に、引数からパラメータと可変長引数テーブルへのマッピングがあります：

```
CALL             PARAMETERS

f(3)             a=3, b=nil
f(3, 4)          a=3, b=4
f(3, 4, 5)       a=3, b=4
f(r(), 10)       a=1, b=10
f(r())           a=1, b=2

g(3)             a=3, b=nil, va. table ->  {n = 0}
g(3, 4)          a=3, b=4,   va. table ->  {n = 0}
g(3, 4, 5, 8)    a=3, b=4,   va. table ->  {5, 8, n = 2}
g(5, r())        a=5, b=1,   va. table ->  {2, 3, n = 2}
```

可変長引数関数の可変長引数テーブルは、3つのドットの後に指定されるオプションの名前を持つことができます。存在する場合、その名前は可変長引数テーブルを参照する読み取り専用ローカル変数を示します。可変長引数テーブルに名前がない場合、可変長引数式を通してのみアクセスできます。

可変長引数式も3つのドットとして記述され、その値は可変長引数テーブル内の値のリストで、1からインデックス`"n"`の整数値までです。（したがって、コードが可変長引数テーブルを変更しない場合、このリストは関数呼び出しの追加引数に対応します。）このリストは、複数の結果を持つ関数の結果と同様に動作します（[§3.4.12](#3412--式のリスト複数の結果および調整)を参照）。

最適化として、可変長引数テーブルがいくつかの条件を満たす場合、コードは実際のテーブルを作成せず、代わりにインデックス式と可変長引数式を内部可変長引数データへのアクセスに変換します。条件は次のとおりです：可変長引数テーブルに名前がある場合、その名前はネストされた関数のアップバリューではなく、構文構造`t[exp]`または`t.id`のベーステーブルとしてのみ使用されます。匿名の可変長引数テーブルは常にこれらの条件を満たすことに注意してください。

### 3.4.12 – 式のリスト、複数の結果、および調整

関数呼び出しと可変長引数式の両方が、複数の値を返す可能性があります。これらの式は、**複数結果の式**と呼ばれます。

複数結果の式が式のリストの最後の要素として使用される場合、式からのすべての結果が式のリストによって生成された値のリストに追加されます。式のリストを予期する場所に単一の式がある場合、その（シングルトン）リストの最後の式になることに注意してください。

これらは、Luaが式のリストを予期する場所です：

- **return**ステートメント。たとえば、`return e1,e2,e3`（[§3.3.4](#334--制御構造)を参照）。
- テーブルコンストラクタ。たとえば、`{e1,e2,e3}`（[§3.4.9](#349--テーブルコンストラクタ)を参照）。
- 関数呼び出しの引数。たとえば、`foo(e1,e2,e3)`（[§3.4.10](#3410--関数呼び出し)を参照）。
- 複数代入。たとえば、`a,b,c = e1,e2,e3`（[§3.3.3](#333--代入)を参照）。
- ローカルまたはグローバル宣言。複数代入と同様。
- 汎用**for**ループでの初期値。たとえば、`for k in e1,e2,e3 do ... end`（[§3.3.5](#335--forステートメント)を参照）。

最後の4つのケースでは、式のリストからの値のリストを特定の長さに**調整**する必要があります。つまり、可変長引数関数ではない関数への呼び出しのパラメータ数（[§3.4.11](#3411--関数定義)を参照）、複数代入または宣言の変数の数、および汎用**for**ループの場合は正確に4つの値です。**調整**は、次の規則に従います。必要な値よりも多くの値がある場合、余分な値は破棄されます。必要な値よりも少ない値がある場合、リストは**nil**で拡張されます。式のリストが複数結果の式で終わる場合、調整の前に、その式からのすべての結果が値のリストに入力されます。

複数結果の式が、最後の要素ではない式のリストで使用されている場合、または構文が単一の式を予期する場所で使用されている場合、Luaはその式の結果リストを1つの要素に調整します。特定の場合として、構文は括弧で囲まれた式の中に単一の式があることを予期します。したがって、複数結果の式の周囲に括弧を追加すると、正確に1つの結果が生成されます。

構文が単一の式を予期する場所で可変長引数式を使用する必要はほとんどありません。（通常、可変長引数部分の前に通常のパラメータを追加して、そのパラメータを使用する方が簡単です。）そのような必要がある場合は、可変長引数式を単一の変数に割り当てて、その変数を代わりに使用することをお勧めします。

複数結果の式の使用例を次に示します。すべての場合において、構成が「n番目の結果」を必要とし、そのような結果がない場合は、**nil**が使用されます：

```lua
print(x, f())      -- xとf()からのすべての結果を出力。
print(x, (f()))    -- xとf()からの最初の結果を出力。
print(f(), x)      -- f()からの最初の結果とxを出力。
print(1 + f())     -- f()からの最初の結果に1を加算して出力。
local x = ...      -- xは最初の可変長引数を取得。
x,y = ...          -- xは最初の可変長引数を取得、
                   -- yは2番目の可変長引数を取得。
x,y,z = w, f()     -- xはwを取得、yはf()からの最初の結果を取得、
                   -- zはf()からの2番目の結果を取得。
x,y,z = f()        -- xはf()からの最初の結果を取得、
                   -- yはf()からの2番目の結果を取得、
                   -- zはf()からの3番目の結果を取得。
x,y,z = f(), g()   -- xはf()からの最初の結果を取得、
                   -- yはg()からの最初の結果を取得、
                   -- zはg()からの2番目の結果を取得。
x,y,z = (f())      -- xはf()からの最初の結果を取得、yとzはnilを取得。
return f()         -- f()からのすべての結果を返す。
return x, ...      -- xと受け取ったすべての可変長引数を返す。
return x,y,f()     -- x、y、およびf()からのすべての結果を返す。
{f()}              -- f()からのすべての結果でリストを作成。
{...}              -- すべての可変長引数でリストを作成。
{f(), 5}           -- f()からの最初の結果と5でリストを作成。
```

## 3.5 – 可視性ルール

Luaは、レキシカルスコープの言語です。ローカル変数のスコープは、宣言の後の最初のステートメントで始まり、宣言を含む最も内側のブロックの最後の非voidステートメントまで続きます。（**Voidステートメント**は、ラベルと空のステートメントです。）次の例を検討してください：

```lua
x = 10                -- グローバル変数
do                    -- 新しいブロック
  local x = x         -- 値10を持つ新しい'x'
  print(x)            --> 10
  x = x+1
  do                  -- 別のブロック
    local x = x+1     -- 別の'x'
    print(x)          --> 12
  end
  print(x)            --> 11
end
print(x)              --> 10  (グローバル変数)
```

`local x = x`のような宣言では、宣言されている新しい`x`はまだスコープ内ではないため、2番目の`x`は外部変数を参照することに注意してください。

レキシカルスコープルールのため、ローカル変数は、そのスコープ内で定義された関数によって自由にアクセスできます。内側の関数で使用されるローカル変数は、内側の関数内で**アップバリュー**（または**外部ローカル変数**、または単に**外部変数**）と呼ばれます。

**local**ステートメントを実行するたびに、新しいローカル変数が定義されることに注意してください。次の例を検討してください：

```lua
a = {}
local x = 20
for i = 1, 10 do
  local y = 0
  a[i] = function () y = y + 1; return x + y end
end
```

ループは、10個のクロージャ（つまり、匿名関数の10個のインスタンス）を作成します。これらの各クロージャは異なる`y`変数を使用しますが、すべて同じ`x`を共有します。

---

[← 前へ: 2 – 基本概念](02-basic-concepts.md) | [目次](./README.md) | [次へ: 4 – アプリケーションプログラムインターフェース →](04-c-api.md)
