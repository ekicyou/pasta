# 4 – アプリケーションプログラムインターフェース

[← 前へ: 3 – 言語](03-language.md) | [目次](./README.md) | [次へ: 5 – 補助ライブラリ →](05-auxiliary-library.md)

---

このセクションでは、LuaのC API、つまりLuaと通信するためにホストプログラムで使用できるC関数のセットについて説明します。すべてのAPI関数および関連する型と定数は、ヘッダーファイル`lua.h`で宣言されています。

「関数」という用語を使用する場合でも、APIの任意の機能は、代わりにマクロとして提供される場合があります。特に明記されていない限り、そのようなすべてのマクロは、引数を正確に一度だけ使用します（常にLuaステートである最初の引数を除く）。したがって、隠れた副作用は生成されません。

ほとんどのCライブラリと同様に、Lua API関数は、引数の有効性または一貫性をチェックしません。ただし、マクロ`LUA_USE_APICHECK`を定義してLuaをコンパイルすることにより、この動作を変更できます。

Luaライブラリは完全にリエントラントです。つまり、グローバル変数はありません。必要なすべての情報を、**Luaステート**と呼ばれる動的な構造に保持します。

各Luaステートには、独立した協調的な実行ラインに対応する1つ以上のスレッドがあります。型[`lua_State`](#lua_State)は（その名前にもかかわらず）スレッドを参照します。（間接的に、スレッドを介して、スレッドに関連付けられているLuaステートも参照します。）

スレッドへのポインタは、ライブラリ内のすべての関数への最初の引数として渡す必要があります。ただし、[`lua_newstate`](#lua_newstate)は例外です。これは、Luaステートを最初から作成し、新しいステートの**メインスレッド**へのポインタを返します。

## 4.1 – スタック

Luaは、値をCとの間で受け渡すために、**仮想スタック**を使用します。このスタック内の各要素は、Lua値（**nil**、数値、文字列など）を表します。API内の関数は、受け取るLuaステートパラメータを介してこのスタックにアクセスできます。

LuaがCを呼び出すたびに、呼び出された関数は新しいスタックを取得します。このスタックは、以前のスタックや、まだアクティブなC関数のスタックとは独立しています。このスタックには、最初にC関数への引数が含まれており、C関数は一時的なLua値を保存し、呼び出し元に返される結果をプッシュする必要があります（[`lua_CFunction`](#lua_CFunction)を参照）。

便宜上、APIのほとんどのクエリ操作は厳密なスタック規律に従いません。代わりに、**インデックス**を使用してスタック内の任意の要素を参照できます。正のインデックスは絶対スタック位置を表し、スタックの底を1として始まります。負のインデックスは、スタックの最上部を基準としたオフセットを表します。より具体的には、スタックに*n*個の要素がある場合、インデックス1は最初の要素（つまり、最初にスタックにプッシュされた要素）を表し、インデックス*n*は最後の要素を表します。インデックス-1も最後の要素（つまり、最上部の要素）を表し、インデックス-*n*は最初の要素を表します。

### 4.1.1 – スタックサイズ

Lua APIを操作するときは、一貫性を確保する責任があります。特に、**スタックオーバーフローを制御する責任があります**。API関数を呼び出すときは、スタックに結果を格納するのに十分な空き容量があることを確認する必要があります。

上記ルールには1つの例外があります。結果の数が固定されていないLua関数を呼び出す場合（[`lua_call`](#lua_call)を参照）、Luaはスタックにすべての結果を格納するのに十分なスペースがあることを保証します。ただし、追加のスペースは保証しません。したがって、このような呼び出しの後にスタックに何かをプッシュする前に、[`lua_checkstack`](#lua_checkstack)を使用する必要があります。

LuaがCを呼び出すたびに、スタックに少なくとも`LUA_MINSTACK`個の追加要素のためのスペースがあることを保証します。つまり、最大で`LUA_MINSTACK`個の値を安全にプッシュできます。`LUA_MINSTACK`は20として定義されているため、コードが要素をスタックにプッシュするループがない限り、通常はスタック領域を気にする必要はありません。必要に応じて、関数[`lua_checkstack`](#lua_checkstack)を使用して、スタックに新しい要素をプッシュするための十分なスペースがあることを確認できます。

### 4.1.2 – 有効なインデックスと許容可能なインデックス

スタックインデックスを受け取るAPIの関数は、**有効なインデックス**または**許容可能なインデックス**でのみ機能します。

**有効なインデックス**とは、変更可能なLua値を格納する位置を参照するインデックスです。これは、1からスタックの最上部（`1 ≤ abs(index) ≤ top`）までのスタックインデックスと、Cコードからアクセスできるがスタックにはないいくつかの位置を表す**擬似インデックス**で構成されます。擬似インデックスは、レジストリ（[§4.3](#43--レジストリ)を参照）とC関数のアップバリュー（[§4.2](#42--cクロージャ)を参照）にアクセスするために使用されます。

特定の変更可能な位置を必要とせず、値のみを必要とする関数（クエリ関数など）は、許容可能なインデックスで呼び出すことができます。**許容可能なインデックス**は、有効なインデックスのいずれかですが、スタック用に割り当てられた領域内のスタックの最上部より後の任意の正のインデックス、つまりスタックサイズまでのインデックスにすることもできます。（0は許容可能なインデックスではないことに注意してください。）現在のC関数の実際のアップバリュー数よりも大きいアップバリュー（[§4.2](#42--cクロージャ)を参照）へのインデックスも許容されます（ただし、無効です）。特に記載がない限り、APIの関数は許容可能なインデックスで動作します。

許容可能なインデックスは、スタックをクエリするときにスタックの最上部に対する追加のテストを回避するのに役立ちます。たとえば、C関数は、3番目の引数があるかどうかを確認する必要なく、つまり3が有効なインデックスであるかどうかを確認する必要なく、3番目の引数をクエリできます。

許容可能なインデックスで呼び出すことができる関数の場合、無効なインデックスは、仮想型`LUA_TNONE`の値を含むかのように扱われ、これはnil値のように動作します。

### 4.1.3 – 文字列へのポインタ

APIのいくつかの関数は、スタック内のLua文字列へのポインタ（`const char*`）を返します。（[`lua_pushfstring`](#lua_pushfstring)、[`lua_pushlstring`](#lua_pushlstring)、[`lua_pushstring`](#lua_pushstring)、[`lua_tolstring`](#lua_tolstring)を参照。また、補助ライブラリの[`luaL_checklstring`](05-auxiliary-library.md#luaL_checklstring)、[`luaL_checkstring`](05-auxiliary-library.md#luaL_checkstring)、[`luaL_tolstring`](05-auxiliary-library.md#luaL_tolstring)も参照）。

一般に、Luaのガベージコレクションは内部メモリを解放または移動し、内部文字列へのポインタを無効にする可能性があります。これらのポインタを安全に使用できるように、APIは、スタックインデックスの文字列へのポインタは、そのインデックスの文字列値がスタックから削除されない限り有効であることを保証します。（ただし、別のインデックスに移動することはできます。）インデックスが（アップバリューを参照する）擬似インデックスである場合、ポインタは、対応する呼び出しがアクティブであり、対応するアップバリューが変更されない限り有効です。

デバッグインターフェースの一部の関数も、[`lua_getlocal`](#lua_getlocal)、[`lua_getupvalue`](#lua_getupvalue)、[`lua_setlocal`](#lua_setlocal)、[`lua_setupvalue`](#lua_setupvalue)など、文字列へのポインタを返します。これらの関数では、呼び出し元の関数がアクティブであり、指定されたクロージャ（指定されている場合）がスタック内にある限り、ポインタが有効であることが保証されます。

これらの保証を除いて、ガベージコレクタは内部文字列へのポインタを自由に無効にすることができます。

## 4.2 – Cクロージャ

C関数が作成されるとき、いくつかの値をそれに関連付けて、**Cクロージャ**を作成できます（[`lua_pushcclosure`](#lua_pushcclosure)を参照）。これらの値は**アップバリュー**と呼ばれ、呼び出されるたびに関数からアクセスできます。

C関数が呼び出されるたびに、そのアップバリューは特定の擬似インデックスに配置されます。これらの擬似インデックスは、マクロ[`lua_upvalueindex`](#lua_upvalueindex)によって生成されます。関数に関連付けられた最初のアップバリューは、インデックス`lua_upvalueindex(1)`にあり、以下同様です。`lua_upvalueindex(n)`へのアクセスは、*n*が現在の関数のアップバリューの数よりも大きい場合（ただし、クロージャ内のアップバリューの最大数に1を加えた256以下の場合）は、許容可能だが無効なインデックスを生成します。

Cクロージャは、対応するアップバリューの値を変更することもできます。

## 4.3 – レジストリ

Luaは、任意のCコードがLua値を格納するために使用できる、事前定義されたテーブルである**レジストリ**を提供します。レジストリテーブルは、常に擬似インデックス`LUA_REGISTRYINDEX`でアクセスできます。任意のCライブラリは、このテーブルにデータを格納できますが、他のライブラリが使用するキーとは異なるキーを選択して、競合を回避する必要があります。通常、キーとしてライブラリ名を含む文字列、またはコード内のCオブジェクトのアドレスを持つライトuserdata、またはコードによって作成された任意のLuaオブジェクトを使用する必要があります。変数名と同様に、アンダースコアで始まり、大文字が続く文字列キーはLua用に予約されています。

レジストリの整数キーは、参照メカニズム（[`luaL_ref`](05-auxiliary-library.md#luaL_ref)を参照）およびいくつかの事前定義された値によって使用されます。したがって、レジストリの整数キーを他の目的で使用しないでください。

新しいLua状態を作成すると、そのレジストリにはいくつかの事前定義された値が付属します。これらの事前定義された値には、`lua.h`の定数として定義された整数キーでインデックスが付けられています。次の定数が定義されています：

- **`LUA_RIDX_MAINTHREAD`**: このインデックスでは、レジストリはステートのメインスレッドを持ちます。（メインスレッドは、ステートとともに作成されたものです。）

- **`LUA_RIDX_GLOBALS`**: このインデックスでは、レジストリはグローバル環境を持ちます。

## 4.4 – Cでのエラー処理

内部的に、LuaはCの`longjmp`機能を使用してエラーを処理します。（Luaは、C++としてコンパイルした場合、例外を使用します。詳細については、ソースコードで`LUAI_THROW`を検索してください。）Luaは、メモリ割り当てエラーや型エラーなどのエラーに直面すると、エラーを**発生**させます。つまり、long jumpを実行します。**保護された環境**は`setjmp`を使用してリカバリポイントを設定します。エラーは、最も最近のアクティブなリカバリポイントにジャンプします。

C関数内では、[`lua_error`](#lua_error)を呼び出すことで、エラーを明示的に発生させることができます。

APIのほとんどの関数は、たとえばメモリ割り当てエラーが原因でエラーを発生させる可能性があります。各関数のドキュメントには、エラーを発生させる可能性があるかどうかが示されています。

保護された環境の外でエラーが発生した場合、Luaは**パニック関数**（[`lua_atpanic`](#lua_atpanic)を参照）を呼び出し、次に`abort`を呼び出して、ホストアプリケーションを終了します。パニック関数は、（たとえば、Luaの外の独自のリカバリポイントにlong jumpを実行して）戻らないことで、この終了を回避できます。

パニック関数は、名前が示すように、最後の手段のメカニズムです。プログラムはそれを避ける必要があります。原則として、C関数がLuaステートを持つLuaによって呼び出される場合、すでに保護されているため、そのLuaステートに対して必要なことを実行できます。ただし、Cコードが他のLuaステート（たとえば、関数へのLuaステート引数、レジストリに格納されているLuaステート、または[`lua_newthread`](#lua_newthread)の結果）を操作する場合、エラーを発生させないAPI呼び出しでのみそれらを使用する必要があります。

パニック関数は、メッセージハンドラのように実行されます（[§2.3](02-basic-concepts.md#23--エラー処理)を参照）。特に、エラーオブジェクトはスタックの最上部にあります。ただし、スタック領域については保証はありません。スタックに何かをプッシュするには、パニック関数は最初に利用可能なスペースを確認する必要があります（[§4.1.1](#411--スタックサイズ)を参照）。

### 4.4.1 – ステータスコード

APIでエラーを報告するいくつかの関数は、さまざまな種類のエラーまたはその他の状態を示すために、次のステータスコードを使用します：

- **`LUA_OK` (0)**: エラーなし。

- **`LUA_ERRRUN`**: ランタイムエラー。

- **`LUA_ERRMEM`**: メモリ割り当てエラー。このようなエラーの場合、Luaはメッセージハンドラを呼び出しません。

- **`LUA_ERRERR`**: 別のスタックオーバーフローによるメッセージハンドラの実行中のスタックオーバーフロー。多くの場合、このエラーは、メッセージハンドラの実行中に別のエラーが発生した結果です。メッセージハンドラでのエラーはハンドラを再度呼び出し、再度エラーを生成し、このループがスタックを使い果たしてこのエラーを引き起こすまで続きます。

- **`LUA_ERRSYNTAX`**: プリコンパイル中の構文エラー、またはバイナリチャンクのフォーマットエラー。

- **`LUA_YIELD`**: スレッド（コルーチン）がyieldしました。

- **`LUA_ERRFILE`**: ファイル関連のエラー。たとえば、ファイルを開いたり読み取ったりできません。

これらの定数は、ヘッダーファイル`lua.h`で定義されています。

## 4.5 – CでのYieldの処理

内部的には、LuaはコルーチンをyieldするためにCの`longjmp`機能を使用します。そのため、C関数`foo`がAPI関数を呼び出し、このAPI関数が（直接的またはyieldする別の関数を呼び出すことによって間接的に）yieldする場合、`longjmp`によってCスタックからフレームが削除されるため、Luaはもはや`foo`に戻ることができません。

この種の問題を回避するために、LuaはAPI呼び出しをまたいでyieldしようとするたびにエラーを発生させます。ただし、[`lua_yieldk`](#lua_yieldk)、[`lua_callk`](#lua_callk)、および[`lua_pcallk`](#lua_pcallk)の3つの関数は例外です。これらの関数はすべて、yield後に実行を継続するための**継続関数**（`k`という名前のパラメータとして）を受け取ります。

継続を説明するために、いくつかの用語を設定する必要があります。Luaから呼び出されたC関数を、**元の関数**と呼びます。この元の関数は、C APIのこれら3つの関数のいずれかを呼び出し、これを**呼び出し先関数**と呼びます。そして、呼び出し先関数が現在のスレッドをyieldします。これは、呼び出し先関数が[`lua_yieldk`](#lua_yieldk)である場合、または呼び出し先関数が[`lua_callk`](#lua_callk)または[`lua_pcallk`](#lua_pcallk)のいずれかであり、それらによって呼び出された関数がyieldする場合に発生します。

呼び出し先関数の実行中に実行中のスレッドがyieldすると仮定します。スレッドが再開した後、最終的に呼び出し先関数の実行が完了します。ただし、Cスタック内のフレームはyieldによって破棄されているため、呼び出し先関数は元の関数に戻ることができません。代わりに、Luaは**継続関数**を呼び出します。この継続関数は、呼び出し先関数の引数として渡されたものです。名前が示すように、継続関数は元の関数のタスクを継続する必要があります。

例として、次の関数を考えてみましょう：

```c
int original_function (lua_State *L) {
  ...     /* code 1 */
  status = lua_pcall(L, n, m, h);  /* calls Lua */
  ...     /* code 2 */
}
```

ここで、[`lua_pcall`](#lua_pcall)によって実行されるLuaコードがyieldできるようにしたいとします。まず、ここで示すように関数を書き直すことができます：

```c
int k (lua_State *L, int status, lua_KContext ctx) {
  ...  /* code 2 */
}

int original_function (lua_State *L) {
  ...     /* code 1 */
  return k(L, lua_pcall(L, n, m, h), ctx);
}
```

上記のコードでは、新しい関数`k`は**継続関数**（[`lua_KFunction`](#lua_KFunction)型）であり、[`lua_pcall`](#lua_pcall)を呼び出した後に元の関数が行っていたすべての作業を行う必要があります。次に、[`lua_pcall`](#lua_pcall)によって実行されているLuaコードが何らかの方法（エラーまたはyield）で中断された場合に`k`を呼び出す必要があることをLuaに通知する必要があります。そのため、[`lua_pcall`](#lua_pcall)を[`lua_pcallk`](#lua_pcallk)に置き換えて、コードをここで示すように書き換えます：

```c
int original_function (lua_State *L) {
  ...     /* code 1 */
  return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
}
```

継続への外部からの明示的な呼び出しに注意してください。Luaは、エラーが発生した場合やyield後に再開する場合など、必要な場合にのみ継続を呼び出します。呼び出された関数がyieldせずに正常に返った場合、[`lua_pcallk`](#lua_pcallk)（および[`lua_callk`](#lua_callk)）も正常に返ります。（もちろん、その場合に継続を呼び出す代わりに、元の関数内で同等の作業を直接行うことができます。）

Luaの状態に加えて、継続関数には他の2つのパラメータがあります。それは呼び出しの最終ステータスと、最初に[`lua_pcallk`](#lua_pcallk)に渡されたコンテキスト値（`ctx`）です。Luaはこのコンテキスト値を使用しません。元の関数から継続関数にこの値を渡すだけです。[`lua_pcallk`](#lua_pcallk)の場合、ステータスは[`lua_pcallk`](#lua_pcallk)によって返される値と同じですが、yield後に実行されている場合は（`LUA_OK`ではなく）`LUA_YIELD`になります。[`lua_yieldk`](#lua_yieldk)および[`lua_callk`](#lua_callk)の場合、Luaが継続を呼び出すときのステータスは常に`LUA_YIELD`です。（これらの2つの関数では、エラーが発生した場合に継続を呼び出すことはありません。エラーを処理しないためです。）同様に、[`lua_callk`](#lua_callk)を使用する場合は、ステータスとして`LUA_OK`を指定して継続関数を呼び出す必要があります。（[`lua_yieldk`](#lua_yieldk)の場合、通常[`lua_yieldk`](#lua_yieldk)は返さないため、継続関数を直接呼び出すことにあまり意味はありません。）

Luaは、継続関数を元の関数であるかのように扱います。継続関数は、元の関数と同じLuaスタックを、呼び出し先関数が返された場合と同じ状態で受け取ります。（たとえば、[`lua_callk`](#lua_callk)の後、関数とその引数はスタックから削除され、呼び出しの結果に置き換えられます。）また、同じアップバリューも持ちます。それが返すものはすべて、元の関数の戻り値としてLuaによって処理されます。

## 4.6 – 関数と型

ここでは、C APIのすべての関数と型をアルファベット順にリストします。各関数には、次のようなインジケータがあります：`[-o, +p, x]`

最初のフィールド`o`は、関数がスタックからポップする要素の数です。2番目のフィールド`p`は、関数がスタックにプッシュする要素の数です。（すべての関数は常に、引数をポップした後で結果をプッシュします。）`x|y`形式のフィールドは、関数が状況に応じて`x`または`y`要素をプッシュ（またはポップ）できることを意味します。疑問符`?`は、引数だけを見て関数がポップ/プッシュする要素の数を知ることができないことを意味します。（たとえば、スタックの内容に依存する場合があります。）3番目のフィールド`x`は、関数がエラーを発生させる可能性があるかどうかを示します：

- `-` は関数がエラーを発生させないことを意味します
- `m` は関数がメモリ不足エラーのみを発生させる可能性があることを意味します
- `v` は、テキストで説明されているエラーを関数が発生させる可能性があることを意味します
- `e` は関数が直接またはメタメソッドを通じて任意のLuaコードを実行できるため、任意のエラーが発生する可能性があることを意味します

> **注意**: §4.6の完全な関数リファレンスは、元のLua 5.5マニュアルを参照してください。このセクションには100を超えるAPI関数・型の詳細なドキュメントが含まれています。

## 4.7 – デバッグインターフェース

Luaには組み込みのデバッグ機能はありません。代わりに、関数とフックのための特別なインターフェースを提供します。このインターフェースにより、プロファイラ、デバッガ、およびその他のインタープリター内の情報を必要とするツールなど、さまざまな種類のデバッガ、プロファイラ、およびその他のツールを構築できます。

> **注意**: §4.7の完全なデバッグインターフェースリファレンスは、元のLua 5.5マニュアルを参照してください。

---

[← 前へ: 3 – 言語](03-language.md) | [目次](./README.md) | [次へ: 5 – 補助ライブラリ →](05-auxiliary-library.md)
