//! Intermediate Representation (IR) for Pasta script events.
//!
//! This module defines the `ScriptEvent` IR that represents conversation control information
//! generated by the Pasta script engine. The IR is independent of UI rendering and animation,
//! making the engine fully unit-testable without user testing.

use rune::Any;

/// Content part of a speech event.
///
/// Represents a fragment of speech content that can be either plain text or
/// sakura script escape sequences.
#[derive(Debug, Clone, PartialEq, Any)]
pub enum ContentPart {
    /// Plain text content.
    Text(String),

    /// Sakura script escape sequence (not interpreted by pasta, passed through as-is).
    ///
    /// Examples: `\\s[0]`, `\\w8`, `\\n[half]`
    ///
    /// These will be output directly when converting IR to sakura script at the SHIORI.DLL layer.
    SakuraScript(String),
}

/// Script event representing conversation control information.
///
/// This is the primary output IR of the Pasta script engine. The engine is responsible for
/// generating these events sequentially, while the areka application layer is responsible
/// for interpreting them (timing control, buffering, synchronization, UI rendering).
///
/// # Design Principles
///
/// - **No timing control**: Wait interpretation is done by the areka layer.
/// - **No buffering**: ScriptEvents are yielded sequentially.
/// - **No synchronization control**: BeginSync/SyncPoint/EndSync are markers only.
/// - **No sakura script interpretation**: SakuraScript is kept as-is in the IR.
#[derive(Debug, Clone, PartialEq, Any)]
pub enum ScriptEvent {
    /// Speech event (speaker name + content).
    ///
    /// **pasta**: Yields speech lines from DSL as a list of ContentPart.
    /// **areka**: Gets or creates the speaker's balloon and feeds content to it.
    ///           SakuraScript is kept as-is without interpretation by pasta.
    Talk {
        speaker: String,
        content: Vec<ContentPart>,
    },

    /// Wait event (duration in seconds).
    ///
    /// **pasta**: Yields wait specification from DSL as-is.
    /// **areka**: Waits for the specified duration in the animation engine.
    Wait { duration: f64 },

    /// Change speaker event (specifies the speaker for the next Talk).
    ///
    /// **pasta**: Yields speaker specification from DSL as a marker.
    /// **areka**: Remembers the speaker to use when processing the next Talk.
    ChangeSpeaker { name: String },

    /// Change surface event (change character's expression/pose).
    ///
    /// **pasta**: Yields surface specification from DSL as-is.
    /// **areka**: Issues a surface change command to the corresponding character entity.
    ChangeSurface { character: String, surface_id: u32 },

    /// Begin synchronized section marker.
    ///
    /// **pasta**: Yields ＠同時発言開始 from DSL as a marker (no control logic).
    /// **areka**: Creates a buffer for the sync_id and starts accumulating subsequent Talk events.
    ///           Participants are automatically determined from Talk events between BeginSync and EndSync.
    BeginSync { sync_id: String },

    /// Synchronization point marker.
    ///
    /// **pasta**: Yields ＠同期 from DSL as a marker (no control logic).
    /// **areka**: Tracks progress of each speaker. When all participants reach the SyncPoint,
    ///           starts animation of all buffered content simultaneously.
    SyncPoint { sync_id: String },

    /// End synchronized section marker.
    ///
    /// **pasta**: Yields ＠同時発言終了 from DSL as a marker (no control logic).
    /// **areka**: Ends the synchronized section and clears the buffer.
    EndSync { sync_id: String },

    /// Runtime error event (notifies error during script execution).
    Error { message: String },

    /// Fire event (event notification to specified entity).
    FireEvent {
        event_name: String,
        params: Vec<(String, String)>, // key-value pairs
    },
}

impl ContentPart {
    /// Returns true if this is a Text part.
    pub fn is_text(&self) -> bool {
        matches!(self, ContentPart::Text(_))
    }

    /// Returns true if this is a SakuraScript part.
    pub fn is_sakura_script(&self) -> bool {
        matches!(self, ContentPart::SakuraScript(_))
    }

    /// Gets the content as a string slice regardless of type.
    pub fn as_str(&self) -> &str {
        match self {
            ContentPart::Text(s) | ContentPart::SakuraScript(s) => s,
        }
    }

    /// Converts this ContentPart into its inner String.
    pub fn into_string(self) -> String {
        match self {
            ContentPart::Text(s) | ContentPart::SakuraScript(s) => s,
        }
    }
}

impl ScriptEvent {
    /// Returns true if this is a Talk event.
    pub fn is_talk(&self) -> bool {
        matches!(self, ScriptEvent::Talk { .. })
    }

    /// Returns true if this is a Wait event.
    pub fn is_wait(&self) -> bool {
        matches!(self, ScriptEvent::Wait { .. })
    }

    /// Returns true if this is a synchronization marker (BeginSync, SyncPoint, or EndSync).
    pub fn is_sync_marker(&self) -> bool {
        matches!(
            self,
            ScriptEvent::BeginSync { .. }
                | ScriptEvent::SyncPoint { .. }
                | ScriptEvent::EndSync { .. }
        )
    }

    /// Returns true if this is an Error event.
    pub fn is_error(&self) -> bool {
        matches!(self, ScriptEvent::Error { .. })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_content_part_text() {
        let part = ContentPart::Text("Hello".to_string());
        assert!(part.is_text());
        assert!(!part.is_sakura_script());
        assert_eq!(part.as_str(), "Hello");
        assert_eq!(part.into_string(), "Hello");
    }

    #[test]
    fn test_content_part_sakura_script() {
        let part = ContentPart::SakuraScript("\\s[0]".to_string());
        assert!(!part.is_text());
        assert!(part.is_sakura_script());
        assert_eq!(part.as_str(), "\\s[0]");
        assert_eq!(part.into_string(), "\\s[0]");
    }

    #[test]
    fn test_script_event_talk() {
        let event = ScriptEvent::Talk {
            speaker: "さくら".to_string(),
            content: vec![ContentPart::Text("こんにちは".to_string())],
        };
        assert!(event.is_talk());
        assert!(!event.is_wait());
        assert!(!event.is_sync_marker());
        assert!(!event.is_error());
    }

    #[test]
    fn test_script_event_wait() {
        let event = ScriptEvent::Wait { duration: 1.5 };
        assert!(!event.is_talk());
        assert!(event.is_wait());
        assert!(!event.is_sync_marker());
    }

    #[test]
    fn test_script_event_sync_markers() {
        let begin = ScriptEvent::BeginSync {
            sync_id: "sync1".to_string(),
        };
        let point = ScriptEvent::SyncPoint {
            sync_id: "sync1".to_string(),
        };
        let end = ScriptEvent::EndSync {
            sync_id: "sync1".to_string(),
        };

        assert!(begin.is_sync_marker());
        assert!(point.is_sync_marker());
        assert!(end.is_sync_marker());
    }

    #[test]
    fn test_script_event_error() {
        let event = ScriptEvent::Error {
            message: "Test error".to_string(),
        };
        assert!(event.is_error());
        assert!(!event.is_talk());
    }

    #[test]
    fn test_content_part_equality() {
        let text1 = ContentPart::Text("hello".to_string());
        let text2 = ContentPart::Text("hello".to_string());
        let text3 = ContentPart::Text("world".to_string());

        assert_eq!(text1, text2);
        assert_ne!(text1, text3);
    }

    #[test]
    fn test_script_event_equality() {
        let event1 = ScriptEvent::Talk {
            speaker: "さくら".to_string(),
            content: vec![ContentPart::Text("test".to_string())],
        };
        let event2 = ScriptEvent::Talk {
            speaker: "さくら".to_string(),
            content: vec![ContentPart::Text("test".to_string())],
        };
        let event3 = ScriptEvent::Talk {
            speaker: "うにゅう".to_string(),
            content: vec![ContentPart::Text("test".to_string())],
        };

        assert_eq!(event1, event2);
        assert_ne!(event1, event3);
    }
}
