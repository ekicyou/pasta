//! Parser2 module for Pasta DSL using pasta2.pest grammar.
//!
//! grammar.pest `file = ( file_scope | global_scene_scope )*` 仕様に完全準拠。
//! 複数の file_scope と global_scene_scope を任意順序・任意回数で正確に処理します。
//!
//! This module provides parsing functionality based on the authoritative
//! pasta2.pest grammar specification (now located at `grammar.pest`).
//! The grammar file is immutable and represents the canonical definition
//! of Pasta DSL syntax.
//!
//! # Migration Purpose
//!
//! This module exists to enable a gradual migration from the legacy `parser`
//! module to a new implementation based on the verified `pasta2.pest` grammar.
//! Both modules coexist during the transition period:
//!
//! - `pasta::parser` - Legacy parser (to be deprecated)
//! - `pasta::parser2` - New parser based on pasta2.pest (this module)
//!
//! # Grammar Authority
//!
//! The `grammar.pest` file in this module is the authoritative specification
//! for Pasta DSL syntax. It was moved from `pasta2.pest` without any content
//! changes and must never be manually edited.
//!
//! # AST Structure (parser2-filescope-bug-fix)
//!
//! `PastaFile.items: Vec<FileItem>` でファイル内の全アイテムを記述順序で保持:
//! - `FileItem::FileAttr` - ファイルレベル属性
//! - `FileItem::GlobalWord` - ファイルレベル単語定義
//! - `FileItem::GlobalSceneScope` - グローバルシーン
//! - `FileItem::ActorScope` - アクター定義
//!
//! # Example
//!
//! ```no_run
//! use pasta_core::parser::{parse_str, parse_file, FileItem};
//! use std::path::Path;
//!
//! // Parse from string
//! let source = "＊挨拶\n  Alice：こんにちは\n";
//! let ast = parse_str(source, "test.pasta").unwrap();
//!
//! // Iterate items directly for order-sensitive processing (recommended)
//! for item in &ast.items {
//!     match item {
//!         FileItem::FileAttr(attr) => println!("FileAttr: {}", attr.key),
//!         FileItem::GlobalWord(word) => println!("GlobalWord: {}", word.name),
//!         FileItem::GlobalSceneScope(scene) => println!("Scene: {}", scene.name),
//!         FileItem::ActorScope(actor) => println!("Actor: {}", actor.name),
//!     }
//! }
//! ```

pub mod ast;

pub use ast::*;

use pest::Parser as PestParser;
use pest::iterators::{Pair, Pairs};
use pest_derive::Parser;
use std::path::Path;

use crate::error::ParseError;

/// Pest parser generated from grammar.pest (pasta2.pest).
///
/// This parser is automatically generated by pest_derive from the
/// grammar.pest file, which contains the authoritative Pasta DSL grammar.
#[derive(Parser)]
#[grammar = "parser/grammar.pest"]
pub struct PastaParser2;

/// Parse a Pasta script from a string using pasta2.pest grammar.
///
/// This function parses the provided source string and constructs a complete
/// AST representation following the 3-layer scope hierarchy defined in the grammar.
///
/// # Arguments
///
/// * `source` - Pasta DSL source code as a string
/// * `filename` - Filename for error reporting (does not need to exist)
///
/// # Returns
///
/// * `Ok(PastaFile)` - Successfully parsed AST
/// * `Err(ParseError)` - Parse error with location information
///
/// # Example
///
/// ```
/// use pasta_core::parser::{parse_str, FileItem};
///
/// let source = r#"＊挨拶
///   Alice：こんにちは
/// "#;
///
/// match parse_str(source, "example.pasta") {
///     Ok(ast) => {
///         let scene_count = ast.items.iter().filter(|i| matches!(i, FileItem::GlobalSceneScope(_))).count();
///         println!("Parsed {} global scenes", scene_count);
///     }
///     Err(e) => eprintln!("Parse error: {}", e),
/// }
/// ```
pub fn parse_str(source: &str, filename: &str) -> Result<PastaFile, ParseError> {
    let pairs = PastaParser2::parse(Rule::file, source).map_err(|e| {
        let (line, column) = match e.line_col {
            pest::error::LineColLocation::Pos((l, c)) => (l, c),
            pest::error::LineColLocation::Span((l, c), _) => (l, c),
        };
        let message = format!("Parse error in {} at {}:{}: {}", filename, line, column, e);
        ParseError::SyntaxError {
            file: filename.to_string(),
            line,
            column,
            message,
        }
    })?;

    build_ast(pairs, filename, source)
}

/// Parse a Pasta script file using pasta2.pest grammar.
///
/// This function reads the file contents and delegates to `parse_str`.
///
/// # Arguments
///
/// * `path` - Path to the .pasta file
///
/// # Returns
///
/// * `Ok(PastaFile)` - Successfully parsed AST with path set to the input path
/// * `Err(ParseError)` - Parse or IO error
///
/// # Example
///
/// ```no_run
/// use pasta_core::parser::{parse_file, FileItem};
/// use pasta_core::ParseError;
/// use std::path::Path;
///
/// let ast = parse_file(Path::new("scripts/main.pasta"))?;
/// println!("File: {:?}", ast.path);
/// let scene_count = ast.items.iter().filter(|i| matches!(i, FileItem::GlobalSceneScope(_))).count();
/// println!("Global scenes: {}", scene_count);
/// # Ok::<(), ParseError>(())
/// ```
pub fn parse_file(path: &Path) -> Result<PastaFile, ParseError> {
    let source = std::fs::read_to_string(path)?;
    let filename = path.to_string_lossy();
    let mut ast = parse_str(&source, &filename)?;
    ast.path = path.to_path_buf();
    Ok(ast)
}

// ============================================================================
// AST Builder
// ============================================================================

/// Build AST from parsed pairs.
///
/// grammar.pest `file = ( file_scope | global_scene_scope | actor_scope )*` に準拠。
/// 複数の file_scope、global_scene_scope、actor_scope を任意順序で処理し、
/// 出現順序を items に保持します。
fn build_ast(pairs: Pairs<Rule>, filename: &str, source: &str) -> Result<PastaFile, ParseError> {
    let mut file = PastaFile::new(std::path::PathBuf::from(filename));
    let mut last_global_scene_name: Option<String> = None;

    // Set file span to cover the entire source
    let line_count = source.lines().count().max(1);
    let last_line_len = source.lines().last().map(|l| l.len()).unwrap_or(0);
    file.span = Span::new(1, 1, line_count, last_line_len + 1, 0, source.len());

    for pair in pairs {
        match pair.as_rule() {
            Rule::file_scope => {
                // file_scope 内の attrs と words を個別の FileItem として追加
                let scope = parse_file_scope(pair)?;
                for attr in scope.attrs {
                    file.items.push(FileItem::FileAttr(attr));
                }
                for word in scope.words {
                    file.items.push(FileItem::GlobalWord(word));
                }
            }
            Rule::global_scene_scope => {
                let scene = parse_global_scene_scope(pair, &mut last_global_scene_name, filename)?;
                file.items.push(FileItem::GlobalSceneScope(scene));
            }
            Rule::actor_scope => {
                let actor = parse_actor_scope(pair)?;
                file.items.push(FileItem::ActorScope(actor));
            }
            Rule::EOI => {}
            _ => {}
        }
    }

    Ok(file)
}

/// Parse file scope.
fn parse_file_scope(pair: Pair<Rule>) -> Result<FileScope, ParseError> {
    let mut scope = FileScope::default();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::file_attr_line => {
                for attr_pair in inner.into_inner() {
                    if attr_pair.as_rule() == Rule::attr {
                        scope.attrs.push(parse_attr(attr_pair)?);
                    }
                }
            }
            Rule::file_word_line => {
                for kw_pair in inner.into_inner() {
                    if kw_pair.as_rule() == Rule::key_words {
                        scope.words.push(parse_key_words(kw_pair)?);
                    }
                }
            }
            _ => {}
        }
    }

    Ok(scope)
}

/// Parse actor scope.
///
/// grammar.pest `actor_scope = { actor_line ~ actor_scope_item* }` に対応。
/// actor_scope_item = _{ global_scene_attr_line | global_scene_word_line | var_set_line | blank_line }
fn parse_actor_scope(pair: Pair<Rule>) -> Result<ActorScope, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut name = String::new();
    let mut attrs = Vec::new();
    let mut words = Vec::new();
    let mut var_sets = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::actor_line => {
                // actor_line = { actor_marker ~ id ~ or_comment_eol }
                for id_pair in inner.into_inner() {
                    if id_pair.as_rule() == Rule::id {
                        name = id_pair.as_str().to_string();
                    }
                }
            }
            Rule::global_scene_attr_line => {
                for attr_pair in inner.into_inner() {
                    if attr_pair.as_rule() == Rule::attr {
                        attrs.push(parse_attr(attr_pair)?);
                    }
                }
            }
            Rule::global_scene_word_line => {
                for kw_pair in inner.into_inner() {
                    if kw_pair.as_rule() == Rule::key_words {
                        words.push(parse_key_words(kw_pair)?);
                    }
                }
            }
            Rule::var_set_local | Rule::var_set_global => {
                var_sets.push(parse_var_set(inner)?);
            }
            _ => {}
        }
    }

    Ok(ActorScope {
        name,
        attrs,
        words,
        var_sets,
        span,
    })
}

/// Parse global scene scope.
fn parse_global_scene_scope(
    pair: Pair<Rule>,
    last_name: &mut Option<String>,
    filename: &str,
) -> Result<GlobalSceneScope, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut scene_name = String::new();
    let mut is_continuation = false;
    let mut attrs = Vec::new();
    let mut words = Vec::new();
    let mut actors = Vec::new();
    let mut code_blocks = Vec::new();
    let mut local_scenes = Vec::new();
    let mut next_actor_number: u32 = 0;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::global_scene_start => {
                let (name, cont) = parse_global_scene_start(inner, last_name, filename)?;
                scene_name = name.clone();
                is_continuation = cont;
                *last_name = Some(name);
            }
            Rule::global_scene_attr_line => {
                for attr_pair in inner.into_inner() {
                    if attr_pair.as_rule() == Rule::attr {
                        attrs.push(parse_attr(attr_pair)?);
                    }
                }
            }
            Rule::global_scene_word_line => {
                for kw_pair in inner.into_inner() {
                    if kw_pair.as_rule() == Rule::key_words {
                        words.push(parse_key_words(kw_pair)?);
                    }
                }
            }
            Rule::scene_actors_line => {
                let items = parse_scene_actors_line(inner, &mut next_actor_number)?;
                actors.extend(items);
            }
            Rule::code_block => {
                code_blocks.push(parse_code_block(inner)?);
            }
            Rule::local_start_scene_scope => {
                local_scenes.push(parse_local_start_scene_scope(inner)?);
            }
            Rule::local_scene_scope => {
                local_scenes.push(parse_local_scene_scope(inner)?);
            }
            _ => {}
        }
    }

    Ok(GlobalSceneScope {
        name: scene_name,
        is_continuation,
        attrs,
        words,
        actors,
        code_blocks,
        local_scenes,
        span,
    })
}

/// Parse global scene start (line or continue line).
fn parse_global_scene_start(
    pair: Pair<Rule>,
    last_name: &Option<String>,
    filename: &str,
) -> Result<(String, bool), ParseError> {
    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::global_scene_line => {
                // Named scene
                for scene_inner in inner.into_inner() {
                    if scene_inner.as_rule() == Rule::id {
                        return Ok((scene_inner.as_str().to_string(), false));
                    }
                }
            }
            Rule::global_scene_continue_line => {
                // Continuation scene - inherit name from last
                if let Some(name) = last_name {
                    return Ok((name.clone(), true));
                } else {
                    let span = inner.as_span();
                    let (line, col) = span.start_pos().line_col();
                    return Err(ParseError::SyntaxError {
                        file: filename.to_string(),
                        line,
                        column: col,
                        message: "Unnamed global scene at start of file. A named global scene must appear before any unnamed scenes.".to_string(),
                    });
                }
            }
            _ => {}
        }
    }

    Ok((String::new(), false))
}

/// Parse scene_actors_line to extract SceneActorItems.
///
/// grammar.pest:
/// - `scene_actors_line = { pad ~ actor_marker ~ actors ~ or_comment_eol }`
/// - `actors = _{ actors_item ~ ( comma_sep ~ actors_item )* ~ comma_sep? }`
///
/// # Arguments
/// * `pair` - Rule::scene_actors_lineのPair
/// * `next_number` - 次の採番値（可変参照、更新される）
///
/// # Returns
/// パースされたSceneActorItemのベクタ
fn parse_scene_actors_line(
    pair: Pair<Rule>,
    next_number: &mut u32,
) -> Result<Vec<SceneActorItem>, ParseError> {
    let mut items = Vec::new();

    // scene_actors_line = { pad ~ actor_marker ~ actors ~ or_comment_eol }
    // actors is a silent rule, so actors_item pairs appear directly
    for inner in pair.into_inner() {
        if inner.as_rule() == Rule::actors_item {
            let item = parse_actors_item(inner, next_number)?;
            items.push(item);
        }
    }

    Ok(items)
}

/// Parse a single actors_item to SceneActorItem.
///
/// grammar.pest: `actors_item = { id ~ ( s ~ set_marker ~ s ~ digit_id )? }`
///
/// C#のenum採番ルール:
/// - 番号指定あり: その番号を使用し、next_number = その番号 + 1
/// - 番号指定なし: next_numberを使用し、next_number += 1
fn parse_actors_item(
    pair: Pair<Rule>,
    next_number: &mut u32,
) -> Result<SceneActorItem, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut name = String::new();
    let mut explicit_number: Option<u32> = None;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                name = inner.as_str().to_string();
            }
            Rule::digit_id => {
                // 全角数字を半角に正規化してパース
                let normalized = normalize_number_str(inner.as_str());
                explicit_number = normalized.parse::<u32>().ok();
            }
            _ => {}
        }
    }

    // C#のenum採番ルールを適用
    let number = if let Some(n) = explicit_number {
        *next_number = n + 1;
        n
    } else {
        let n = *next_number;
        *next_number += 1;
        n
    };

    Ok(SceneActorItem { name, number, span })
}

/// Parse local start scene scope (no name).
fn parse_local_start_scene_scope(pair: Pair<Rule>) -> Result<LocalSceneScope, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut scope = LocalSceneScope::start();
    scope.span = span;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::var_set_local | Rule::var_set_global => {
                scope
                    .items
                    .push(LocalSceneItem::VarSet(parse_var_set(inner)?));
            }
            Rule::call_scene => {
                scope
                    .items
                    .push(LocalSceneItem::CallScene(parse_call_scene(inner)?));
            }
            Rule::action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ActionLine(parse_action_line(inner)?));
            }
            Rule::continue_action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ContinueAction(parse_continue_action_line(
                        inner,
                    )?));
            }
            Rule::code_block => {
                scope.code_blocks.push(parse_code_block(inner)?);
            }
            _ => {}
        }
    }

    Ok(scope)
}

/// Parse local scene scope (with name).
fn parse_local_scene_scope(pair: Pair<Rule>) -> Result<LocalSceneScope, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut scope = LocalSceneScope::start();
    scope.span = span;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::local_scene_line => {
                for scene_inner in inner.into_inner() {
                    if scene_inner.as_rule() == Rule::id {
                        scope.name = Some(scene_inner.as_str().to_string());
                        break;
                    }
                }
            }
            Rule::var_set_local | Rule::var_set_global => {
                scope
                    .items
                    .push(LocalSceneItem::VarSet(parse_var_set(inner)?));
            }
            Rule::call_scene => {
                scope
                    .items
                    .push(LocalSceneItem::CallScene(parse_call_scene(inner)?));
            }
            Rule::action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ActionLine(parse_action_line(inner)?));
            }
            Rule::continue_action_line => {
                scope
                    .items
                    .push(LocalSceneItem::ContinueAction(parse_continue_action_line(
                        inner,
                    )?));
            }
            Rule::code_block => {
                scope.code_blocks.push(parse_code_block(inner)?);
            }
            _ => {}
        }
    }

    Ok(scope)
}

/// Parse attribute.
fn parse_attr(pair: Pair<Rule>) -> Result<Attr, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut key = String::new();
    let mut value = AttrValue::AttrString(String::new());

    for inner in pair.into_inner() {
        if inner.as_rule() == Rule::key_attr {
            for kv_inner in inner.into_inner() {
                match kv_inner.as_rule() {
                    Rule::id => {
                        key = kv_inner.as_str().to_string();
                    }
                    Rule::number_literal => {
                        value = parse_attr_number(kv_inner.as_str());
                    }
                    Rule::string_contents | Rule::string_blank => {
                        value = AttrValue::String(kv_inner.as_str().to_string());
                    }
                    Rule::attr_string => {
                        value = AttrValue::AttrString(kv_inner.as_str().to_string());
                    }
                    _ => {}
                }
            }
        }
    }

    Ok(Attr { key, value, span })
}

/// Parse attribute number value.
fn parse_attr_number(s: &str) -> AttrValue {
    let normalized = normalize_number_str(s);
    if normalized.contains('.') {
        AttrValue::Float(normalized.parse().unwrap_or(0.0))
    } else {
        AttrValue::Integer(normalized.parse().unwrap_or(0))
    }
}

/// Parse key_words.
fn parse_key_words(pair: Pair<Rule>) -> Result<KeyWords, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut name = String::new();
    let mut words = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                name = inner.as_str().to_string();
            }
            Rule::words => {
                for word_inner in inner.into_inner() {
                    match word_inner.as_rule() {
                        Rule::string_contents | Rule::string_blank => {
                            words.push(word_inner.as_str().to_string());
                        }
                        Rule::word_nofenced => {
                            words.push(word_inner.as_str().to_string());
                        }
                        Rule::sakura_script => {
                            words.push(word_inner.as_str().to_string());
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }

    Ok(KeyWords { name, words, span })
}

/// Parse code block.
fn parse_code_block(pair: Pair<Rule>) -> Result<CodeBlock, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut language = None;
    let mut content = String::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                language = Some(inner.as_str().to_string());
            }
            Rule::code_contents => {
                content = inner.as_str().to_string();
            }
            _ => {}
        }
    }

    Ok(CodeBlock {
        language,
        content,
        span,
    })
}

/// Parse var_set.
fn parse_var_set(pair: Pair<Rule>) -> Result<VarSet, ParseError> {
    let span = Span::from(&pair.as_span());
    let scope = match pair.as_rule() {
        Rule::var_set_global => VarScope::Global,
        _ => VarScope::Local,
    };

    let mut name = String::new();
    let mut terms: Vec<Expr> = Vec::new();
    let mut operators: Vec<BinOp> = Vec::new();
    let mut word_ref_name: Option<String> = None;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                // The first id is the variable name
                if name.is_empty() {
                    name = inner.as_str().to_string();
                }
            }
            Rule::word_ref => {
                // word_ref = { word_marker ~ id ~ s }
                // word_marker is a hidden rule, so only id is in inner pairs
                for word_inner in inner.into_inner() {
                    if word_inner.as_rule() == Rule::id {
                        word_ref_name = Some(word_inner.as_str().to_string());
                        break;
                    }
                }
            }
            Rule::add_op => operators.push(BinOp::Add),
            Rule::sub_op => operators.push(BinOp::Sub),
            Rule::mul_op => operators.push(BinOp::Mul),
            Rule::div_op => operators.push(BinOp::Div),
            Rule::modulo_op => operators.push(BinOp::Mod),
            _ => {
                // Try to parse as expression (term)
                if let Some(expr) = try_parse_expr(inner) {
                    terms.push(expr);
                }
            }
        }
    }

    // Build value based on whether we have word_ref or expr
    let value = if let Some(ref_name) = word_ref_name {
        // word_ref was detected
        SetValue::WordRef { name: ref_name }
    } else {
        // Build left-associative binary expression
        let expr = if terms.is_empty() {
            Expr::BlankString
        } else {
            let mut result = terms.remove(0);
            for (i, op) in operators.into_iter().enumerate() {
                if i < terms.len() {
                    result = Expr::Binary {
                        op,
                        lhs: Box::new(result),
                        rhs: Box::new(terms[i].clone()),
                    };
                }
            }
            result
        };
        SetValue::Expr(expr)
    };

    Ok(VarSet {
        name,
        scope,
        value,
        span,
    })
}

/// Parse call_scene.
fn parse_call_scene(pair: Pair<Rule>) -> Result<CallScene, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut target = String::new();
    let mut args = None;

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                target = inner.as_str().to_string();
            }
            Rule::args => {
                args = Some(parse_args(inner)?);
            }
            _ => {}
        }
    }

    Ok(CallScene { target, args, span })
}

/// Parse action_line.
fn parse_action_line(pair: Pair<Rule>) -> Result<ActionLine, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut actor = String::new();
    let mut actions = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                actor = inner.as_str().to_string();
            }
            Rule::actions => {
                actions = parse_actions(inner)?;
            }
            _ => {}
        }
    }

    Ok(ActionLine {
        actor,
        actions,
        span,
    })
}

/// Parse continue_action_line.
fn parse_continue_action_line(pair: Pair<Rule>) -> Result<ContinueAction, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut actions = Vec::new();

    for inner in pair.into_inner() {
        if inner.as_rule() == Rule::actions {
            actions = parse_actions(inner)?;
        }
    }

    Ok(ContinueAction { actions, span })
}

/// Parse actions.
fn parse_actions(pair: Pair<Rule>) -> Result<Vec<Action>, ParseError> {
    let mut actions = Vec::new();

    for inner in pair.into_inner() {
        let action_span = Span::from(&inner.as_span());
        match inner.as_rule() {
            Rule::talk => {
                actions.push(Action::Talk {
                    text: inner.as_str().to_string(),
                    span: action_span,
                });
            }
            Rule::word_ref => {
                for id_inner in inner.into_inner() {
                    if id_inner.as_rule() == Rule::id {
                        actions.push(Action::WordRef {
                            name: id_inner.as_str().to_string(),
                            span: action_span,
                        });
                    }
                }
            }
            Rule::var_ref_local => {
                for var_id_pair in inner.into_inner() {
                    if var_id_pair.as_rule() == Rule::var_id {
                        // var_idの内部構造を確認（idまたはdigit_id）
                        for id_inner in var_id_pair.into_inner() {
                            match id_inner.as_rule() {
                                Rule::id => {
                                    actions.push(Action::VarRef {
                                        name: id_inner.as_str().to_string(),
                                        scope: VarScope::Local,
                                        span: action_span,
                                    });
                                }
                                Rule::digit_id => {
                                    let index = normalize_number_str(id_inner.as_str())
                                        .parse::<u8>()
                                        .unwrap_or(0);
                                    actions.push(Action::VarRef {
                                        name: id_inner.as_str().to_string(),
                                        scope: VarScope::Args(index),
                                        span: action_span,
                                    });
                                }
                                _ => {}
                            }
                        }
                    }
                }
            }
            Rule::var_ref_global => {
                for id_inner in inner.into_inner() {
                    if id_inner.as_rule() == Rule::id {
                        actions.push(Action::VarRef {
                            name: id_inner.as_str().to_string(),
                            scope: VarScope::Global,
                            span: action_span,
                        });
                    }
                }
            }
            Rule::fn_call_local => {
                let (name, args) = parse_fn_call_inner(inner)?;
                actions.push(Action::FnCall {
                    name,
                    args,
                    scope: FnScope::Local,
                    span: action_span,
                });
            }
            Rule::fn_call_global => {
                let (name, args) = parse_fn_call_inner(inner)?;
                actions.push(Action::FnCall {
                    name,
                    args,
                    scope: FnScope::Global,
                    span: action_span,
                });
            }
            Rule::sakura_script => {
                actions.push(Action::SakuraScript {
                    script: inner.as_str().to_string(),
                    span: action_span,
                });
            }
            Rule::at_escape | Rule::dollar_escape | Rule::sakura_escape => {
                actions.push(Action::Escape {
                    sequence: inner.as_str().to_string(),
                    span: action_span,
                });
            }
            _ => {}
        }
    }

    Ok(actions)
}

/// Parse function call inner parts.
fn parse_fn_call_inner(pair: Pair<Rule>) -> Result<(String, Args), ParseError> {
    let mut name = String::new();
    let mut args = Args::empty();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::id => {
                name = inner.as_str().to_string();
            }
            Rule::args => {
                args = parse_args(inner)?;
            }
            _ => {}
        }
    }

    Ok((name, args))
}

/// Parse args.
fn parse_args(pair: Pair<Rule>) -> Result<Args, ParseError> {
    let span = Span::from(&pair.as_span());
    let mut items = Vec::new();

    for inner in pair.into_inner() {
        match inner.as_rule() {
            Rule::positional_arg => {
                // Collect all terms and operators for this positional argument
                // Grammar: expr = term ~ bin*, where bin = bin_op ~ term
                // Since expr and bin are silent rules, we get term, op, term, op, term...
                if let Some(expr) = parse_expr_from_parts(inner) {
                    items.push(Arg::Positional(expr));
                }
            }
            Rule::key_arg => {
                let (key, value) = parse_key_arg(inner)?;
                items.push(Arg::Keyword { key, value });
            }
            _ => {}
        }
    }

    Ok(Args { items, span })
}

/// Parse an expression from parts (terms and binary operators).
/// Handles the case where expr = term ~ (bin_op ~ term)* expands into multiple pairs.
fn parse_expr_from_parts(pair: Pair<Rule>) -> Option<Expr> {
    let mut terms: Vec<Expr> = Vec::new();
    let mut operators: Vec<BinOp> = Vec::new();

    for expr_inner in pair.into_inner() {
        match expr_inner.as_rule() {
            Rule::add_op => operators.push(BinOp::Add),
            Rule::sub_op => operators.push(BinOp::Sub),
            Rule::mul_op => operators.push(BinOp::Mul),
            Rule::div_op => operators.push(BinOp::Div),
            Rule::modulo_op => operators.push(BinOp::Mod),
            _ => {
                if let Some(term) = try_parse_expr(expr_inner) {
                    terms.push(term);
                }
            }
        }
    }

    if terms.is_empty() {
        return None;
    }

    // Build left-associative binary expression
    let mut result = terms.remove(0);
    for (i, op) in operators.into_iter().enumerate() {
        if i < terms.len() {
            result = Expr::Binary {
                op,
                lhs: Box::new(result),
                rhs: Box::new(terms[i].clone()),
            };
        }
    }

    Some(result)
}

/// Parse key_arg.
fn parse_key_arg(pair: Pair<Rule>) -> Result<(String, Expr), ParseError> {
    let mut key = String::new();
    let mut terms: Vec<Expr> = Vec::new();
    let mut operators: Vec<BinOp> = Vec::new();

    for inner in pair.into_inner() {
        if inner.as_rule() == Rule::key_expr {
            for kv_inner in inner.into_inner() {
                match kv_inner.as_rule() {
                    Rule::id => {
                        // The first id is the key name
                        if key.is_empty() {
                            key = kv_inner.as_str().to_string();
                        }
                    }
                    Rule::add_op => operators.push(BinOp::Add),
                    Rule::sub_op => operators.push(BinOp::Sub),
                    Rule::mul_op => operators.push(BinOp::Mul),
                    Rule::div_op => operators.push(BinOp::Div),
                    Rule::modulo_op => operators.push(BinOp::Mod),
                    _ => {
                        if let Some(expr) = try_parse_expr(kv_inner) {
                            terms.push(expr);
                        }
                    }
                }
            }
        }
    }

    // Build left-associative binary expression
    let value = if terms.is_empty() {
        Expr::BlankString
    } else {
        let mut result = terms.remove(0);
        for (i, op) in operators.into_iter().enumerate() {
            if i < terms.len() {
                result = Expr::Binary {
                    op,
                    lhs: Box::new(result),
                    rhs: Box::new(terms[i].clone()),
                };
            }
        }
        result
    };

    Ok((key, value))
}

/// Try to parse an expression from a pair.
fn try_parse_expr(pair: Pair<Rule>) -> Option<Expr> {
    match pair.as_rule() {
        Rule::number_literal => {
            let normalized = normalize_number_str(pair.as_str());
            if normalized.contains('.') {
                Some(Expr::Float(normalized.parse().ok()?))
            } else {
                Some(Expr::Integer(normalized.parse().ok()?))
            }
        }
        Rule::string_contents => Some(Expr::String(pair.as_str().to_string())),
        Rule::string_blank => Some(Expr::BlankString),
        Rule::var_ref_local => {
            for var_id_pair in pair.into_inner() {
                if var_id_pair.as_rule() == Rule::var_id {
                    // var_idの内部構造を確認（idまたはdigit_id）
                    for id_inner in var_id_pair.into_inner() {
                        match id_inner.as_rule() {
                            Rule::id => {
                                return Some(Expr::VarRef {
                                    name: id_inner.as_str().to_string(),
                                    scope: VarScope::Local,
                                });
                            }
                            Rule::digit_id => {
                                let index = normalize_number_str(id_inner.as_str())
                                    .parse::<u8>()
                                    .unwrap_or(0);
                                return Some(Expr::VarRef {
                                    name: id_inner.as_str().to_string(),
                                    scope: VarScope::Args(index),
                                });
                            }
                            _ => {}
                        }
                    }
                }
            }
            None
        }
        Rule::var_ref_global => {
            for inner in pair.into_inner() {
                if inner.as_rule() == Rule::id {
                    return Some(Expr::VarRef {
                        name: inner.as_str().to_string(),
                        scope: VarScope::Global,
                    });
                }
            }
            None
        }
        Rule::fn_call_local => {
            let (name, args) = parse_fn_call_inner(pair).ok()?;
            Some(Expr::FnCall {
                name,
                args,
                scope: FnScope::Local,
            })
        }
        Rule::fn_call_global => {
            let (name, args) = parse_fn_call_inner(pair).ok()?;
            Some(Expr::FnCall {
                name,
                args,
                scope: FnScope::Global,
            })
        }
        Rule::paren_expr => {
            for inner in pair.into_inner() {
                if let Some(expr) = try_parse_expr(inner) {
                    return Some(Expr::Paren(Box::new(expr)));
                }
            }
            None
        }
        Rule::add_op | Rule::sub_op | Rule::mul_op | Rule::div_op | Rule::modulo_op => {
            // Binary operators are handled at a higher level
            None
        }
        _ => {
            // Try recursively for nested expressions
            for inner in pair.into_inner() {
                if let Some(expr) = try_parse_expr(inner) {
                    return Some(expr);
                }
            }
            None
        }
    }
}

/// Normalize number string by converting full-width characters to half-width.
///
/// Converts:
/// - Full-width digits ('０'..'９') to half-width ('0'..'9')
/// - Full-width minus ('－') to half-width ('-')
/// - Full-width decimal point ('．') to half-width ('.')
fn normalize_number_str(s: &str) -> String {
    s.chars()
        .map(|c| match c {
            '０'..='９' => ((c as u32 - '０' as u32) + '0' as u32) as u8 as char,
            '－' => '-',
            '．' => '.',
            _ => c,
        })
        .collect()
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn get_global_scene_scopes(file: &PastaFile) -> Vec<&GlobalSceneScope> {
        file.items
            .iter()
            .filter_map(|item| {
                if let FileItem::GlobalSceneScope(scene) = item {
                    Some(scene)
                } else {
                    None
                }
            })
            .collect()
    }

    fn get_file_attrs(file: &PastaFile) -> Vec<&Attr> {
        file.items
            .iter()
            .filter_map(|item| {
                if let FileItem::FileAttr(attr) = item {
                    Some(attr)
                } else {
                    None
                }
            })
            .collect()
    }

    #[test]
    fn test_normalize_number_str_half_width() {
        assert_eq!(normalize_number_str("123"), "123");
        assert_eq!(normalize_number_str("-456"), "-456");
        assert_eq!(normalize_number_str("3.14"), "3.14");
    }

    #[test]
    fn test_normalize_number_str_full_width() {
        assert_eq!(normalize_number_str("１２３"), "123");
        assert_eq!(normalize_number_str("－４５６"), "-456");
        assert_eq!(normalize_number_str("３．１４"), "3.14");
    }

    #[test]
    fn test_normalize_number_str_mixed() {
        assert_eq!(normalize_number_str("１2３"), "123");
        assert_eq!(normalize_number_str("3．１４"), "3.14");
        assert_eq!(normalize_number_str("－123"), "-123");
    }

    #[test]
    fn test_parse_empty_file() {
        let result = parse_str("", "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        assert!(get_global_scene_scopes(&file).is_empty());
    }

    #[test]
    fn test_parse_simple_global_scene() {
        let source = "＊挨拶\n  Alice：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].name, "挨拶");
        assert!(!scenes[0].is_continuation);
    }

    #[test]
    fn test_parse_continuation_scene() {
        let source = "＊挨拶\n  Alice：こんにちは\n＊\n  Bob：やあ\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 2);
        assert_eq!(scenes[0].name, "挨拶");
        assert!(!scenes[0].is_continuation);
        assert_eq!(scenes[1].name, "挨拶");
        assert!(scenes[1].is_continuation);
    }

    #[test]
    fn test_parse_unnamed_scene_at_start_error() {
        let source = "＊\n  Alice：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_err());
        if let Err(ParseError::SyntaxError { message, .. }) = result {
            assert!(message.contains("Unnamed global scene at start of file"));
        }
    }

    #[test]
    fn test_parse_file_scope() {
        let source = "&author：テスト\n＊挨拶\n  Alice：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let attrs = get_file_attrs(&file);
        assert_eq!(attrs.len(), 1);
        assert_eq!(attrs[0].key, "author");
    }

    #[test]
    fn test_parse_continue_action_line() {
        let source = "＊挨拶\n  Alice：こんにちは\n  ：続きの台詞\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        let local_scene = &scenes[0].local_scenes[0];
        assert!(local_scene.items.len() >= 2);
        // First item should be ActionLine, second should be ContinueAction
        assert!(matches!(
            local_scene.items[0],
            LocalSceneItem::ActionLine(_)
        ));
        assert!(matches!(
            local_scene.items[1],
            LocalSceneItem::ContinueAction(_)
        ));
    }

    #[test]
    fn test_parse_code_block() {
        let source = "＊挨拶\n  Alice：こんにちは\n```rune\nlet x = 1;\n```\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        assert_eq!(get_global_scene_scopes(&file).len(), 1);
        // Code blocks may be in global or local scope depending on grammar
    }

    #[test]
    fn test_pest_parser_compiles() {
        // Verify that PastaParser2 can parse the file rule
        let result = PastaParser2::parse(Rule::file, "");
        assert!(result.is_ok());
    }

    // ========================================================================
    // SceneActorItem Tests (scene-actors-ast-support)
    // ========================================================================

    #[test]
    fn test_parse_scene_actors_single() {
        // 単一アクター「さくら」（番号0）
        let source = "＊挨拶\n　％さくら\n  さくら：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].actors.len(), 1);
        assert_eq!(scenes[0].actors[0].name, "さくら");
        assert_eq!(scenes[0].actors[0].number, 0);
    }

    #[test]
    fn test_parse_scene_actors_with_explicit_number() {
        // 「さくら」（番号0）と「うにゅう＝２」
        let source = "＊挨拶\n　％さくら、うにゅう＝２\n  さくら：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].actors.len(), 2);
        assert_eq!(scenes[0].actors[0].name, "さくら");
        assert_eq!(scenes[0].actors[0].number, 0);
        assert_eq!(scenes[0].actors[1].name, "うにゅう");
        assert_eq!(scenes[0].actors[1].number, 2);
    }

    #[test]
    fn test_parse_scene_actors_csharp_enum_numbering() {
        // C#のenum採番ルール: さくら=0, うにゅう=2, まりか=3
        let source = "＊挨拶\n　％さくら、うにゅう＝２、まりか\n  さくら：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].actors.len(), 3);
        assert_eq!(scenes[0].actors[0].name, "さくら");
        assert_eq!(scenes[0].actors[0].number, 0);
        assert_eq!(scenes[0].actors[1].name, "うにゅう");
        assert_eq!(scenes[0].actors[1].number, 2);
        assert_eq!(scenes[0].actors[2].name, "まりか");
        assert_eq!(scenes[0].actors[2].number, 3);
    }

    #[test]
    fn test_parse_scene_actors_fullwidth_number() {
        // 全角数字「＝１０」が正しくパースされることを確認
        let source = "＊挨拶\n　％さくら＝１０\n  さくら：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].actors.len(), 1);
        assert_eq!(scenes[0].actors[0].name, "さくら");
        assert_eq!(scenes[0].actors[0].number, 10);
    }

    #[test]
    fn test_parse_scene_actors_multiple_lines() {
        // 複数行のアクター宣言で番号が行をまたいで引き継がれることを確認
        // 1行目: さくら=0
        // 2行目: うにゅう=5
        // 3行目: まりか=6
        let source = "＊挨拶\n　％さくら\n　％うにゅう＝５\n　％まりか\n  さくら：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].actors.len(), 3);
        assert_eq!(scenes[0].actors[0].name, "さくら");
        assert_eq!(scenes[0].actors[0].number, 0);
        assert_eq!(scenes[0].actors[1].name, "うにゅう");
        assert_eq!(scenes[0].actors[1].number, 5);
        assert_eq!(scenes[0].actors[2].name, "まりか");
        assert_eq!(scenes[0].actors[2].number, 6);
    }

    #[test]
    fn test_parse_scene_actors_complex_numbering() {
        // 複雑な採番パターン: さくら=0, うにゅう=2, まりか=3, ゆかり=10, あかね=11
        let source = "＊挨拶\n　％さくら、うにゅう＝２、まりか、ゆかり＝１０、あかね\n  さくら：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].actors.len(), 5);
        assert_eq!(scenes[0].actors[0].name, "さくら");
        assert_eq!(scenes[0].actors[0].number, 0);
        assert_eq!(scenes[0].actors[1].name, "うにゅう");
        assert_eq!(scenes[0].actors[1].number, 2);
        assert_eq!(scenes[0].actors[2].name, "まりか");
        assert_eq!(scenes[0].actors[2].number, 3);
        assert_eq!(scenes[0].actors[3].name, "ゆかり");
        assert_eq!(scenes[0].actors[3].number, 10);
        assert_eq!(scenes[0].actors[4].name, "あかね");
        assert_eq!(scenes[0].actors[4].number, 11);
    }

    #[test]
    fn test_parse_scene_actors_span_valid() {
        // SceneActorItemのSpanが有効であることを確認
        let source = "＊挨拶\n　％さくら\n  さくら：こんにちは\n";
        let result = parse_str(source, "test.pasta");
        assert!(result.is_ok());
        let file = result.unwrap();
        let scenes = get_global_scene_scopes(&file);
        assert_eq!(scenes.len(), 1);
        assert_eq!(scenes[0].actors.len(), 1);
        // Spanが有効であることを確認
        assert!(scenes[0].actors[0].span.is_valid());
    }
}
