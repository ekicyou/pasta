// Yield propagation experiment for while-let-yield pattern
// This test verifies that nested generator yields are correctly propagated

/// Inner generator - yields two events
pub fn inner_generator() {
    yield "inner_event_1";
    yield "inner_event_2";
}

/// Middle generator - propagates inner generator's yields
pub fn middle_generator() {
    yield "middle_start";
    
    let inner = inner_generator();
    while let Some(event) = inner.resume(()) {
        yield event; // Propagate inner yields
    }
    
    yield "middle_end";
}

/// Outer generator - propagates middle generator's yields
pub fn outer_generator() {
    yield "outer_start";
    
    let middle = middle_generator();
    while let Some(event) = middle.resume(()) {
        yield event; // Propagate middle yields (including inner's)
    }
    
    yield "outer_end";
}

/// Test nested call simulation (like Call/Jump in Pasta)
pub fn label_a() {
    yield "label_a: before call";
    
    // Simulate calling label_b
    let label_b_gen = label_b();
    while let Some(event) = label_b_gen.resume(()) {
        yield event;
    }
    
    yield "label_a: after call";
}

pub fn label_b() {
    yield "label_b: before call";
    
    // Simulate calling label_c
    let label_c_gen = label_c();
    while let Some(event) = label_c_gen.resume(()) {
        yield event;
    }
    
    yield "label_b: after call";
}

pub fn label_c() {
    yield "label_c: event 1";
    yield "label_c: event 2";
}

/// Main test function
pub fn main() {
    dbg!("=== Test 1: Simple nested generator ===");
    let outer = outer_generator();
    let mut count = 0;
    while let Some(event) = outer.resume(()) {
        count += 1;
        dbg!(`Event ${count}: ${event}`);
    }
    
    dbg!("\n=== Test 2: Deep nested call (A -> B -> C) ===");
    let label_a_gen = label_a();
    count = 0;
    while let Some(event) = label_a_gen.resume(()) {
        count += 1;
        dbg!(`Event ${count}: ${event}`);
    }
    
    dbg!("\n=== All tests completed ===");
}
