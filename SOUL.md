# Pasta ソウルドキュメント

_Memories of pasta twine together—now and then a knot, yet always a delight._

このドキュメントは、pastaプロジェクトの「憲法」です。すべての設計判断、実装方針、開発活動の根拠となる「あるべき姿」を定義します。

**関連ドキュメント**:
- [README.md](README.md) - プロジェクト概要
- [SPECIFICATION.md](SPECIFICATION.md) - 技術仕様書（権威的ソース）
- [GRAMMAR.md](GRAMMAR.md) - DSL文法リファレンス
- [AGENTS.md](AGENTS.md) - AI開発支援

---

## 1. ビジョン

### プロジェクトの存在意義

**pasta**は、「伺か」のようなデスクトップマスコットや、シナリオ型ゲームを実現するための対話スクリプトエンジンです。

### コア概念：「パスタのように絡み合う会話」

会話の記録というのは、長い長い一本の糸です。この糸は時に絡み合い、時に結び目を作りながら、パスタのように複雑に織りなされていきます。

この絡み合いこそが、会話の**意外性**と**面白さ**を生み出します。前方一致によるランダムジャンプを主軸にすることで、スクリプト作者が意図した範囲内での自然な会話の揺らぎを実現します。

### ミッション

1. **ゴースト会話の記述基盤**: デスクトップマスコットの掛け合い会話を直感的に記述できるスクリプト言語を提供する
2. **シナリオエンジンとしての汎用性**: ゲームエンジンとしても流用可能なデータ構造とランタイムを提供する
3. **エコシステムとの統合**: SHIORI.DLLインターフェースによる従来資産の活用と、arekaへの統合による次世代基盤の確立

---

## 2. コアバリュー

pastaの設計を貫く4つの柱：

### 2.1 日本語フレンドリー

**原則**: 日本語話者が直感的に使えること

- **全角キーワード対応**: `＊`、`・`、`＠`、`＄`、`＞`など、全角文字で記述可能
- **タイプ量削減**: 全角文字なら1文字で済むマーカーを採用
- **読みやすさ**: 日本語の文章の中に自然に溶け込む文法設計

**例**:
```pasta
＊会話
  さくら：おはよう！
  うにゅう：やあ、今日もいい天気だね
```

### 2.2 UNICODE識別子

**原則**: グローバルな多言語対応

- **日本語シーン名**: `＊挨拶`、`＊自己紹介`など
- **日本語変数名**: `＄カウンター`、`＄ユーザー名`など
- **Unicode Identifier仕様**: XID_START / XID_CONTINUE準拠
- **文化的柔軟性**: 各言語圏のユーザーが母語で記述可能

### 2.3 yield型エンジン

**原則**: 継続可能な出力ストリーム

- **Generator/yieldパターン**: イベント出力を逐次yield
- **チェイントーク対応**: 連続した会話の中断・再開が可能
- **UI独立性**: 出力ペース制御をエンジン外（areka層）に委譲

**設計意図**: スクリプトエンジンは純粋なロジック層として動作し、UI表現とのカップリングを排除

### 2.4 宣言的フロー

**原則**: if/while/forのない、シンプルな制御構造

- **Call/Jump制御**: シーンへのジャンプ・呼び出しで会話を制御
- **属性フィルタリング**: 条件判定は属性マッチングで表現
- **複雑ロジック**: 必要ならLuaブロックで実装

**設計意図**: スクリプト作者が会話フローに集中できる、読みやすく保守しやすい文法

---

## 3. 設計原則

### 3.1 行指向文法

**原則**: 行頭の数文字で行属性が確定する

- 行の種類は冒頭インデント＋キーワードで判定
- 改行が行の区切り（明確な終端）
- 例外はLuaコードブロックのみ（複数行）

**利点**:
- パーサー実装がシンプル
- スクリプト作者が直感的に理解可能
- エラーメッセージが行単位で明確

### 3.2 前方一致によるランダム選択

**原則**: 意外性と再生可能性の両立

#### シーン検索
- `＞挨拶` → 「挨拶」で始まるすべてのシーンが候補
- 候補からランダムに1つを選択
- 同名シーンの重複定義が意図的にサポートされる

#### 単語選択
- `＠greeting` → 登録された単語値リストからランダム抽出
- 前方一致により、関連語彙を柔軟にグルーピング可能

**設計意図**: 
- 会話に自然な揺らぎを持たせる
- スクリプト作者が意図した範囲内での変化を実現
- 繰り返し実行時の単調さを回避

### 3.3 UI独立性の原則

**原則**: Wait/Syncはマーカーのみ、制御はUI層が実装

- スクリプトエンジンは `Wait`, `Sync` などのイベントを**マーカーとして出力するのみ**
- 実際の待機処理、同期処理はareka層（UI層）が実装
- エンジンは純粋なロジック層として独立

**利点**:
- エンジンのテスタビリティ向上
- UI実装の自由度確保
- プラットフォーム非依存性

---

## 4. 辞書アーキテクチャ

pastaの核となるデータ構造は「シーン辞書」と「単語辞書」です。

### 4.1 シーン辞書（Label Table）

シーンは会話の単位であり、前方一致検索とランダム選択の対象です。

#### グローバルシーン

**定義**: `＊シーン名`

- ファイル全体からアクセス可能
- 前方一致検索の基本単位
- 同名シーンの重複定義が可能（ランダム選択）

**用途**:
- 会話のエントリーポイント
- 独立したイベントハンドラ
- 再利用可能な会話パターン

**例**:
```pasta
＊挨拶
  さくら：おはよう！

＊挨拶
  さくら：こんにちは！

＊挨拶_朝
  さくら：おはようございます！
```

→ `＞挨拶` は3つすべてが候補となりランダム選択

#### ローカルシーン

**定義**: `・シーン名`（親シーン内でインデント）

- 親グローバルシーン内でのみアクセス可能
- スコープが限定された、サブルーチン的な扱い
- 名前空間の汚染を防ぐ

**用途**:
- 選択肢の実装
- 親シーン固有のサブフロー
- 一時的な会話分岐

**例**:
```pasta
＊メニュー
  さくら：何をする？
  ＞選択肢
  
  ・選択肢1
    さくら：選択肢1が選ばれました
  
  ・選択肢2
    さくら：選択肢2が選ばれました
```

### 4.2 単語辞書（Word Dictionary）

単語は文字列のリストであり、ランダム選択により会話に揺らぎを与えます。

#### グローバル単語

**定義**: `＠単語名：値1、値2、値3`（ファイルレベル、インデントなし）

- ファイル全体からアクセス可能
- プロジェクト共通の語彙として機能

**用途**:
- 共通の挨拶表現
- 汎用的な相槌
- 複数箇所で使い回す定型句

**例**:
```pasta
＠挨拶：おはよう、こんにちは、こんばんは
＠相槌：うん、そうだね、なるほど
```

#### シーン単語

**定義**: `＠単語名：値1、値2`（グローバルシーン内、インデント）

- 親グローバルシーン内でのみアクセス可能
- シーン固有の語彙として機能

**用途**:
- そのシーンでのみ使う専門用語
- 文脈依存の表現バリエーション

**例**:
```pasta
＊料理の会話
  ＠食材：トマト、玉ねぎ、じゃがいも
  さくら：今日は＠食材　を使って料理するよ
```

#### アクター単語

**定義**: `＠単語名：値`（アクタースコープ内）

- 特定アクター固有の表現・表情として機能
- さくらスクリプトの`\s[表情ID]`などを格納

**用途**:
- アクター固有の表情定義
- キャラクター特有の口癖バリエーション

**例**:
```pasta
％さくら
  ＠通常：\s[0]
  ＠照れ：\s[1]
  ＠驚き：\s[2]

＊会話
  さくら：＠驚き　えっ、本当！？
```

---

## 5. Phase 0: あるべき基盤

現在Phase 0（一次設計の再構築）進行中。以下は各要素の「あるべき姿」です。

### 5.1 DSL文法の理想形

**あるべき姿**: 曖昧性のない、一貫した文法仕様

- すべてのマーカーが明確に定義されている
- 全角/半角の対応が完全
- パーサーが一意に解釈可能な文法
- エラーメッセージが具体的で理解しやすい

**現状の課題**:
- 一部文法の曖昧性・不完全性
- エッジケースでの解釈の不一致

### 5.2 トランスパイル品質基準

**あるべき姿**: 期待されるLuaコードを確実に生成

- パスタスクリプトの意図が正確にLuaコードに変換される
- 最適化されたコード生成（不要な中間変数なし）
- デバッグ可能なコード（行番号対応、コメント保持）
- 統合テストでの完全一致検証（`comprehensive_control_flow.pasta`）

**現状の課題**:
- トランスパイル結果の品質問題
- 一部機能で期待される出力との乖離

### 5.3 シーンテーブル設計

**あるべき姿**: 前方一致検索を効率的に実現

- Radix Trie等の高効率データ構造
- O(log n)以下の検索時間
- メモリ効率の最適化

**現状の課題**:
- シーンテーブル設計の不備
- 検索アルゴリズムの最適化不足

### 5.4 宣言的制御フロー

**あるべき姿**: Call/Jumpによる明快な制御

- Call: サブルーチン呼び出し、実行後復帰
- Jump: 廃止（Callで統一）
- 属性フィルタリングによる条件分岐
- ネストした制御フローの明確な実装

**現状の課題**:
- Call/Jump文の実装品質
- 戻り値の扱いの不整合

### 5.5 過去完了仕様31件からの知見

**教訓**:
1. **要件と実装の一致**: 仕様書と実装の乖離を継続的に検証
2. **テストファースト**: 新機能は必ずテストを先に書く
3. **段階的な進化**: 大規模な変更は小さなステップに分割
4. **回帰防止**: リグレッションテストの徹底

---

## 6. 開発哲学

### 6.1 テストファースト

**原則**: 実装よりもテストを先に書く

- 新機能は必ずテストケースから始める
- リグレッションテストで品質を保証
- `cargo test --workspace` が常にパスする状態を維持

### 6.2 段階的な進化

**原則**: 大きな変更は小さなステップで

- Phase単位での機能追加
- 各Phaseでの品質ゲート通過
- MVP禁止：中途半端な完成は認めない

### 6.3 仕様と実装の一致

**原則**: ドキュメントとコードは常に同期

- SPECIFICATION.mdが権威的ソース
- 実装変更時は必ず仕様書を更新
- Gap Analysisによる定期的な整合性検証

### 6.4 UI独立性の徹底

**原則**: エンジンは純粋なロジック層

- Wait/Syncはマーカー出力のみ
- UI制御はareka層に委譲
- ユニットテスト可能性を最優先

---

## 7. ターゲットユーザー

1. **デスクトップマスコット作者**: 伺か互換環境での会話スクリプト記述
2. **ゲーム開発者**: シナリオ型ゲームの対話エンジンとして活用
3. **LLM統合開発者**: MCP連携による動的対話システムの構築

---

## 8. ロードマップ

### 現在地: Phase 0（一次設計再構築中）

基盤が未確立の状態。DSL文法、トランスパイル、シーンテーブルの再設計を最優先で実施中。

### Phase 1: 基盤確立（Phase 0完了後）

- 安定したDSL文法
- 信頼性の高いトランスパイラ
- 効率的なシーン検索

### Phase 2: コア機能実装

- シーン継続チェーン
- インライン多段解決
- Luaランタイム拡充

### Phase 3: 高度機能

- イベントハンドリング拡充
- 永続化機能
- デバッグツール

### Phase 4: エコシステム統合

- SHIORI.DLL完全対応
- areka統合
- MCP/LLM連携

---

**最終更新**: 2026-01-24  
**ステータス**: Phase 0（一次設計再構築中）
