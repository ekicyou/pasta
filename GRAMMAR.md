# Pasta DSL Grammar Reference

Pasta DSLは、里々にインスパイアされた対話スクリプト記述言語です。このドキュメントでは、Pasta DSLの文法とその使用方法について説明します。

## 目次

1. [基本構文](#基本構文)
2. [ラベル定義](#ラベル定義)
3. [発言文](#発言文)
4. [変数](#変数)
5. [制御構文](#制御構文)
6. [さくらスクリプトエスケープ](#さくらスクリプトエスケープ)
7. [同期セクション](#同期セクション)
8. [イベントハンドリング](#イベントハンドリング)
9. [属性とフィルタリング](#属性とフィルタリング)
10. [コメント](#コメント)

---

## 基本構文

### ファイル構造

Pastaスクリプトは、複数の**ラベル定義**で構成されます。各ラベルは対話の一単位を表し、複数の**ステートメント**（発言、制御構文など）を含みます。

```pasta
＊ラベル名
    ステートメント
    ステートメント
    ...

＊別のラベル名
    ステートメント
    ...
```

### 空白
- 空白文字は、UnicodeのWhite_Spaceカテゴリの文字から、改行コード`\r``\n`を除いたものとします。


### インデント

- ラベル配下のステートメントは**インデント**（空白文字）で字下げします
- インデントレベルが一貫している必要は**ありません**
- インデントが「あれば」ステートメントです

---

## ラベル定義

### グローバルラベル

グローバルラベルは、行頭が`＊`（全角アスタリスク）で始まります。

```pasta
＊挨拶
    さくら：こんにちは！
    うにゅう：やあ！
```

### ローカルラベル

ローカルラベルは、親ラベル内でのみアクセス可能で、インデント＋`・`で始まるステートメントです。

```pasta
＊メインメニュー
    さくら：何をしますか？

    ・選択肢1
        さくら：選択肢1が選ばれました

    ・選択肢2
        さくら：選択肢2が選ばれました
```

### ラベルの重複

同じ名前のラベルを複数定義できます。実行時にランダムに1つが選択されます。

```pasta
＊挨拶
    さくら：おはよう！

＊挨拶
    さくら：こんにちは！

＊挨拶
    さくら：こんばんは！
```

---

## 発言文

### 基本形式

```
　アクター名：発言内容
```

例：
```pasta
＊会話
    さくら：今日はいい天気だね
    うにゅう：そうだね、散歩に行こうか
```

### アクターの省略

一度アクターを指定すると、次の発言でアクターを省略できます。

```pasta
＊長い会話
    さくら：今日はね
    ：とてもいい天気なんだ
    ：だから散歩に行こうと思ってるんだ

    うにゅう：いいね！
    ：一緒に行こう！
```

---

## 属性

### 属性の設定

変数は、`＆属性名：値`の形式で設定します。ラベル定義の直後にのみ記載できます。

```pasta
＊初期化
    ＆score：100
    ＆username：太郎
    ＆is_active：true
```

---

## 変数

### 変数の設定

変数は、`＄変数名：値`の形式で設定します。ラベル定義、属性の後であれば、どこにでも記載できます。

会話行の中では、`＄変数名`の形式で呼び出せます。変数の内容がそのまま会話になります。

```pasta
＊初期化
    ＄score：100
    ＄ユーザー：太郎
　　さくら：＄ユーザー　がいたよ。
    ＄is_active：true
```

### 変数のトランスパイル
ラベルに展開される関数内に、以下のように展開されます。

```rune
    pub fn __start__(ctx, args){
        ctx.var.score = 100;
        ctx.var.ユーザー = "太郎";
        ctx.actor = さくら; yield Actor(ctx.actor.name);
        let a = ctx.var.ユーザー; yield Talk("${a}");
        yield Talk("がいたよ。");
        ctx.var.is_active = true;
    }
```

### 変数の型
変数の型は、以下のルールで決定されます。
1. `「XXX」`：String
2. true：bool値のtrue
3. false：bool値のfalse
4. 小数点が含まれる、数値と認識できるもの：f64
5. 小数点が含まれない、数値と認識できるもの：i64
6. その他：String

---

## 制御構文（宣言的コントロールフロー）

Pasta DSLは**宣言的言語**であり、命令型制御構文（if/while等）は含みません。
コントロールフローは**Call文**と**ラベル定義**で実現します。

> **破壊的変更 (Phase 1)**: Jump文（`？`）は廃止されました。すべての制御フローにはCall文（`＞`）を使用してください。

### Call文（サブルーチン呼び出し）

Call文は他のラベルを呼び出し、実行後に元の場所に戻ります。

#### 基本構文

```pasta
＊メイン
　　さくら：自己紹介を始めます
　　＞自己紹介
　　さくら：自己紹介が終わりました

　・自己紹介
　　さくら：私はさくらです
```

#### ローカルラベルへのCall

```pasta
＊メイン
    さくら：始めます
    ＞ローカル処理
    さくら：終わりました

　-ローカル処理
    さくら：ローカル処理中です
```

#### グローバルラベルへのCall

```pasta
＊スタート
    さくら：始めます
    ＞＊次のステップ

＊次のステップ
    さくら：次のステップに来ました
```

### 条件分岐の実現

条件分岐はRuneブロック内で実装し、`pasta::call()` を使用して分岐します。

```pasta
＊メイン
    ＄スコア＝７５

    ```rune
    pub fn 分岐判定(ctx, args) {
        let スコア = ctx.var.スコア;
        let label =
            if スコア >= 90 { "優秀" }
            else if スコア >= 50 { "合格" }
            else { "不合格" }
            ;
        for a in crate::pasta::call(ctx, label, #{}, []) { yield a; }
    }
    ```

    ＞＠分岐判定

ー優秀
    さくら：優秀です！

ー合格
    さくら：合格です

ー不合格
    さくら：不合格です
```

### 参考実装

完全な宣言的コントロールフローの例は以下を参照してください：
- `tests/fixtures/comprehensive_control_flow.pasta`

### 単語

#### グローバル単語登録
インデント無し`＠単語キー：単語１　単語２`形式で、グローバル単語を登録します。

#### ローカル単語登録
インデントあり`＠単語キー：単語１　単語２`形式で、グローバル単語を登録します。ローカル単語登録は、グローバルラベルおよびラベル属性行の直後にのみ配置可能です。

#### 単語の呼び出し
会話行の中で`＠単語キー　`とすると、一致する単語キーから、いずれかの単語をランダムに呼び出します。

単語キーの検索は、ローカル単語辞書とグローバル単語辞書の全候補による前方一致検索になります。一致するキーの単語がすべて列挙され、その中から候補がランダムに選択されます。

```pasta
＠挨拶朝：おはよう　ハロー
＠挨拶昼：こんちわ
＊メイン
    ＠挨拶朝：Hello
    さくら：＠挨拶昼。
    うにゅう：＠挨拶。
```

このとき、`＠挨拶昼`の単語候補は「こんちわ」だけであり、`＠挨拶`の候補は「おはよう　ハロー　こんちわ　Hello」となります。


#### グローバル関数

```pasta
＊メイン
    さくら：処理を開始します
    ＠呼び出したいラベル
    さくら：処理が完了しました

＊呼び出したいラベル
    さくら：サブルーチンです
```

#### ローカル関数

```pasta
＊親ラベル
    ＠＊＊サブ処理
    
    ＊＊サブ処理
        さくら：サブ処理実行中
```

#### 明示的グローバル指定

ローカル関数とグローバル関数が同名の場合、`＠＊関数名`でグローバル関数を明示的に呼び出せます。

```pasta
＊親
    ＠＊＊ローカル処理
    ＠＊グローバル処理
    
    ＊＊ローカル処理
        さくら：ローカル

＊グローバル処理
    さくら：グローバル
```

---

## さくらスクリプトエスケープ

Pastaは、さくらスクリプトのエスケープシーケンスを**そのまま**IR出力に含めます。解釈はareka層が行います。

> **破壊的変更 (Phase 1)**: さくらスクリプトのエスケープは**半角のみ**サポートされます。
> - バックスラッシュ: `\` のみ（`＼` は不可）
> - 括弧: `[` と `]` のみ（`［` と `］` は不可）

### サポートされるエスケープ

- `\s[表情ID]`: 表情変更
- `\h`: 目を閉じる
- `\w数字`: ウェイト
- `\n`: 改行
- `\_w[数字]`: 待機
- `\![raise, キャラクター名]`: キャラクター切り替え
- `\]`: ブラケット内での `]` エスケープ

### 使用例

```pasta
＊表情変更
    さくら：\s[0]こんにちは！
    さくら：\s[4]元気だよ
    さくら：\s[1]\w8それで\w8ね...

＊改行とウェイト
    さくら：最初の行\n次の行\n\w9最後の行

＊キャラクター切り替え
    さくら：\![raise,さくら]私がメインだよ
    うにゅう：\![raise,うにゅう]いや、僕だよ！

＊ブラケットエスケープ
    さくら：配列参照\s[a\]b]
```

---

## 同期セクション

複数キャラクターが同時に発言するシーンを記述できます。

### 基本構文

```pasta
＊同時発言
    ＠同時発言開始
        さくら：私は左側で話してる
        ＠同期
        うにゅう：僕は右側で話してる
        ＠同期
        さくら：また左側だよ
        ＠同期
        うにゅう：右側から返事
    ＠同時発言終了
```

### 同期マーカー

- `＠同時発言開始`: 同期セクションの開始
- `＠同期`: 同期ポイント（各キャラクターがここで同期）
- `＠同時発言終了`: 同期セクションの終了

### 実行フロー

1. `BeginSync`マーカーをyield
2. 各発言を順次yield
3. `SyncPoint`マーカーでバッファを同期
4. `EndSync`マーカーで同期セクション終了

**Note**: 実際の同期制御（バッファリング、タイミング調整）はareka層が担当します。

---

## イベントハンドリング

### イベントラベル命名規則

イベントハンドラは、`On<イベント名>`の命名規則に従います。

```pasta
＊OnStartup
    さくら：アプリケーションが起動しました！

＊OnShutdown
    さくら：終了します、またね！

＊OnClick
    さくら：クリックされました！

＊OnDoubleClick
    さくら：ダブルクリック！
```

### イベントの発火

スクリプト内からイベントを発火するには、標準ライブラリ関数を使用します。

```pasta
＊何かの処理
    さくら：処理を実行します
    ＠fire_event：CustomEvent, param1=value1, param2=value2
```

### 大文字小文字の区別

イベント名のマッチングは**大文字小文字を区別しません**。

```pasta
＊OnClick      ← "Click", "click", "CLICK" すべてマッチ
＊onclick      ← 同様にマッチ
＊ONCLICK      ← 同様にマッチ
```

---

## 属性とフィルタリング

ラベルに属性を付与し、実行時にフィルタリングできます。

### 属性の定義

```pasta
＊挨拶
    ＠time：morning
    さくら：おはようございます！

＊挨拶
    ＠time：evening
    さくら：こんばんは！

＊挨拶
    ＠weather：rainy
    さくら：雨ですね...
```

### フィルタの使用

アプリケーション層からラベルを実行する際、フィルタを指定できます：

```rust
let mut filters = HashMap::new();
filters.insert("time".to_string(), "morning".to_string());
engine.execute_label_with_filters("挨拶", &filters)?;
```

フィルタに一致するラベルのみが実行候補となります。複数一致する場合はランダム選択されます。

---

## コメント

### 行コメント

`//` から行末までがコメントとして扱われます。

```pasta
＊テスト
    // これはコメントです
    さくら：これは実行されます // 行末コメント
```

### ブロックコメント

`/*` と `*/` で囲まれた部分がコメントとして扱われます。

```pasta
＊テスト
    /*
    これは
    複数行の
    コメントです
    */
    さくら：実行されます
```

---

## Rune コードブロック（実験的機能）

ローカル関数をRuneで直接記述できます（将来実装予定）。

```pasta
＊メイン
    ＠計算処理

```
pub fn 計算処理() {
    let result = 10 + 20;
    yield pasta_stdlib::emit_text("計算結果は{}".format(result));
}
```
```

**Note**: この機能は現在Task 11として実装中です。

---

## 完全な例

### 基本的な対話スクリプト

```pasta
// 挨拶ラベル（複数定義でランダム選択）
＊挨拶
    さくら：こんにちは！元気してた？
    うにゅう：やあ！久しぶりだね

＊挨拶
    さくら：おはよう！\\s[4]
    うにゅう：おはよう！今日もいい天気だね

＊挨拶
    ＠time：evening
    さくら：こんばんは
    うにゅう：こんばんは、お疲れ様

// 変数を使った対話
＊スコア表示
    ＠＊score：{＊score} + 10
    さくら：スコアが増えたよ！
    さくら：現在のスコアは{＊score}点です

// 条件分岐
＊成績判定
    ＠if：{＊score} >= 100
        さくら：すごい！満点だ！
    ＠elif：{＊score} >= 50
        さくら：合格だね
    ＠else
        さくら：もう少し頑張ろう

// 同期セクション
＊掛け合い
    ＠同時発言開始
        さくら：ねえねえ
        ＠同期
        うにゅう：なに？
        ＠同期
        さくら：今日のお昼、何食べる？
        ＠同期
        うにゅう：パスタがいいな！
    ＠同時発言終了
    
    さくら：じゃあパスタにしよう！

// イベントハンドラ
＊OnClick
    さくら：クリックありがとう！\\s[4]

＊OnDoubleClick
    さくら：ダブルクリックされちゃった\\s[6]
```

---

## パフォーマンスに関する注意

1. **パース結果のキャッシュ**: 同一スクリプトは初回のみパースされ、結果がキャッシュされます
2. **ラベル検索**: HashMap ベースのO(1)検索
3. **重複ラベル**: 事前グルーピングされ、高速にランダム選択されます

---

## エラーハンドリング

### パースエラー

文法エラーが発生すると、行番号とカラム位置を含むエラーが返されます。

```
Parse error at <script>:5:10: Expected ':' after speaker name
```

### ラベル未発見エラー

存在しないラベルを実行しようとすると、`LabelNotFound`エラーが返されます。

```
Label not found: 存在しないラベル名
```

### ランタイムエラー

実行中のエラーは`ScriptEvent::Error`として yield されます。

```rust
ScriptEvent::Error {
    message: "Division by zero".to_string()
}
```

---

## 今後の機能拡張

以下の機能が今後追加される予定です：

- [ ] Runeコードブロックのサポート（Task 11）
- [ ] 関数スコープ自動解決の完成（Task 12）
- [ ] マクロ展開
- [ ] インポート/モジュールシステム
- [ ] デバッグ機能（ブレークポイント、ステップ実行）

---

## 参考資料

- [Pasta設計ドキュメント](design.md)
- [実装タスク一覧](tasks.md)
- [サンプルスクリプト](examples/)
- [API ドキュメント](https://docs.rs/pasta)

---

**Pasta DSL** - Satori/Satoruにインスパイアされた、シンプルで強力な対話スクリプト言語
